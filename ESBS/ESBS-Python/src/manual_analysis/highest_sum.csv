,IsBuggy,ProjectName,ProjectVersion,Priority,StartLine,EndLine,SLOC,IC,MCCABE,NBD,MCCLURE,DIFF,MI,TFO,READABILITY,EFFORT,SourceCode,average_sum
353,True,Closure,173,Medium,107,768,20.354166666666668,0.5296442687747035,19.125,1.3333333333333333,10.733333333333333,3.205972434915773,5.3542723371049545,24.857142857142858,0.0,57.610889691823594,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = getContextForNoInOperator(context);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",143.1037549230952
297,True,Closure,157,Medium,82,722,19.354166666666668,0.3557312252964426,19.375,1.0,10.066666666666666,3.4341500765696784,5.337885290674992,24.357142857142858,0.0,59.76435840180095,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.getType() == Token.EMPTY) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.getType() == Token.COMMA) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.LP:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addList(first, false, context);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type));
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().getType() == Token.NUMBER) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type));
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addLeftExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1);
                cc.addOp("":"", true);
                addExpr(last, 1);
                break;
            }
        case Token.REGEXP:
            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.GET_REF:
            add(first);
            break;
        case Token.REF_SPECIAL:
            Preconditions.checkState(childCount == 1);
            add(first);
            add(""."");
            add((String) n.getProp(Node.NAME_PROP));
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GET:
        case Token.SET:
            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.getType() == Token.FUNCTION);
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GET) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (TokenStream.isJSIdentifier(name) && // unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                add(jsString(n.getString(), outputCharsetEncoder));
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.getType() == Token.VAR) {
                        cc.endStatement();
                    }
                    if (c.getType() == Token.FUNCTION) {
                        cc.maybeLineBreak();
                    }
                    // because top level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.getType() == Token.VAR) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.getType() == Token.STRING, ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.getType() == Token.NUMBER);
                if (needsParens) {
                    add(""("");
                }
                addLeftExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addLeftExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addLeftExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA));
                add("")"");
            } else {
                addLeftExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
        case Token.THIS:
        case Token.FALSE:
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(Node.tokenToName(type));
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_VOID:
            throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            add(jsString(n.getString(), outputCharsetEncoder));
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.getType() == Token.GET || c.getType() == Token.SET) {
                        add(c);
                    } else {
                        // are not JavaScript keywords
                        if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // were unicode escaped.
                        NodeUtil.isLatin(c.getString())) {
                            add(c.getString());
                        } else {
                            // Determine if the string is a simple number.
                            addExpr(c, 1);
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (first.getType() != Token.LABEL_NAME) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        // ignored for our purposes.
        case Token.SETNAME:
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",143.04510118481824
218,True,Closure,123,Medium,107,771,20.354166666666668,0.5296442687747035,19.125,1.3333333333333333,10.733333333333333,3.205972434915773,5.3542723371049545,24.785714285714285,0.0,57.610889691823594,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = Context.OTHER;
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",143.03232635166665
100,True,Closure,34,Medium,85,732,19.854166666666668,0.5191040843214758,18.875,1.3333333333333333,10.533333333333333,3.2411944869831544,5.299648849005073,24.428571428571427,0.0,56.61688245685178,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, Context.OTHER, 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, Context.OTHER);
                cc.addOp("":"", true);
                addExpr(last, 1, Context.OTHER);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            add(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            add(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isString());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && // were unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",140.70123463906626
147,True,Closure,68,Medium,169,913,21.270833333333332,2.7588932806324107,23.5,3.3333333333333335,13.933333333333334,2.20750382848392,6.010534529847836,22.142857142857142,0.0,45.50311835630686,"/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                                    // If RETURN doesn't have a type annotation, record
                                    // it as the unknown type.
                                    typeNode = newNode(Token.QMARK);
                                } else {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                }
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                // error reported during recursive descent
                                // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}",140.66040713812816
690,True,Math,81,High,1430,1672,7.8125,1.4097496706192358,6.125,1.6666666666666667,4.4,11.677641653905054,2.6028092079594223,0.7857142857142857,0.0,101.08729257768074,"/**
 * Compute the shift increment as an estimate of the smallest eigenvalue.
 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
 * @param start start index
 * @param end end index
 * @param deflated number of realEigenvalues just deflated
 */
private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;
    // tType records the type of shift.
    if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }
    int nn = 4 * end + pingPong - 1;
    switch(deflated) {
        case // no realEigenvalues deflated.
        0:
            if (dMin == dN || dMin == dN1) {
                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];
                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5] > work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4] > work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9] > work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }
                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;
                }
            } else if (dMin == dN2) {
                // case 5.
                tType = -5;
                double s = 0.25 * dMin;
                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
                // approximate contribution to norm squared from i < nn-2.
                if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }
                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }
            } else {
                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau = g * dMin;
                tType = -6;
            }
            break;
        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
        1:
            if (dMin1 == dN1 && dMin2 == dN2) {
                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {
                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;
        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
        2:
            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau = 0.25 * dMin2;
                tType = -11;
            }
            break;
        default:
            // case 12, more than two realEigenvalues deflated. no information.
            tau = 0.0;
            tType = -12;
    }
}",137.5673740625454
362,True,Codec,1,High,81,313,7.9375,1.44137022397892,11.875,1.3333333333333333,7.8,4.334609494640122,3.678891923527118,6.357142857142857,0.0,22.89476443543788,"/**
 * Find the metaphone value of a String. This is similar to the
 * soundex algorithm, but better at finding similar sounding words.
 * All input is converted to upper case.
 * Limitations: Input format is expected to be a single ASCII word
 * with only characters in the A - Z range, no punctuation or numbers.
 *
 * @param txt String to find the metaphone code for
 * @return A metaphone code corresponding to the String supplied
 */
public String metaphone(String txt) {
    boolean hard = false;
    if ((txt == null) || (txt.length() == 0)) {
        return """";
    }
    // single character is itself
    if (txt.length() == 1) {
        return txt.toUpperCase();
    }
    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
    // manipulate
    StringBuffer local = new StringBuffer(40);
    // output
    StringBuffer code = new StringBuffer(10);
    // handle initial 2 characters exceptions
    switch(inwd[0]) {
        case 'K':
        case 'G':
        case 'P':
            /* looking for KN, etc*/
            if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A':
            /* looking for AE */
            if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W':
            /* looking for WR or WH */
            if (inwd[1] == 'R') {
                // WR -> R
                local.append(inwd, 1, inwd.length - 1);
                break;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                // WH -> W
                local.setCharAt(0, 'W');
            } else {
                local.append(inwd);
            }
            break;
        case 'X':
            /* initial X becomes S */
            inwd[0] = 'S';
            local.append(inwd);
            break;
        default:
            local.append(inwd);
    }
    // now local has working string with initials fixed
    int wdsz = local.length();
    int n = 0;
    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
        // max code size of 4 works well
        char symb = local.charAt(n);
        // remove duplicate letters except C
        if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
            n++;
        } else {
            // not dup
            switch(symb) {
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U':
                    if (n == 0) {
                        code.append(symb);
                    }
                    // only use vowel if leading char
                    break;
                case 'B':
                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
                        // B is silent if word ends in MB
                        break;
                    }
                    code.append(symb);
                    break;
                case // lots of C special cases
                'C':
                    /* discard if SCI, SCE or SCY */
                    if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) {
                        // ""CIA"" -> X
                        code.append('X');
                        break;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        code.append('S');
                        // CI,CE,CY -> S
                        break;
                    }
                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
                        // SCH->sk
                        code.append('K');
                        break;
                    }
                    if (isNextChar(local, n, 'H')) {
                        // detect CH
                        if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
                            // CH consonant -> K consonant
                            code.append('K');
                        } else {
                            // CHvowel -> X
                            code.append('X');
                        }
                    } else {
                        code.append('K');
                    }
                    break;
                case 'D':
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
                        // DGE DGI DGY -> J
                        code.append('J');
                        n += 2;
                    } else {
                        code.append('T');
                    }
                    break;
                case // GH silent at end or before consonant
                'G':
                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
                        break;
                    }
                    if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
                        // silent G
                        break;
                    }
                    if (isPreviousChar(local, n, 'G')) {
                        hard = true;
                    } else {
                        hard = false;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                        // terminal H
                        break;
                    }
                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
                        break;
                    }
                    if (isVowel(local, n + 1)) {
                        // Hvowel
                        code.append('H');
                    }
                    break;
                case 'F':
                case 'J':
                case 'L':
                case 'M':
                case 'N':
                case 'R':
                    code.append(symb);
                    break;
                case 'K':
                    if (n > 0) {
                        // not initial
                        if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                        // initial K
                        code.append(symb);
                    }
                    break;
                case 'P':
                    if (isNextChar(local, n, 'H')) {
                        // PH -> F
                        code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break;
                case 'Q':
                    code.append('K');
                    break;
                case 'S':
                    if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T':
                    if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
                        code.append('X');
                        break;
                    }
                    if (regionMatch(local, n, ""TCH"")) {
                        // Silent if in ""TCH""
                        break;
                    }
                    // substitute numeral 0 for TH (resembles theta after all)
                    if (regionMatch(local, n, ""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break;
                case 'V':
                    code.append('F');
                    break;
                case 'W':
                case // silent if not followed by vowel
                'Y':
                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
                        code.append(symb);
                    }
                    break;
                case 'X':
                    code.append('K');
                    code.append('S');
                    break;
                case 'Z':
                    code.append('S');
                    break;
            }
            // end switch
            n++;
        }
        // end else from symb != 'C'
        if (code.length() > this.getMaxCodeLen()) {
            code.setLength(this.getMaxCodeLen());
        }
    }
    return code.toString();
}",67.65261226806022
634,True,Math,38,High,1582,1755,4.8125,1.2042160737812913,3.5,1.6666666666666667,3.0,5.922664624808577,1.813109637143971,4.928571428571429,0.0,39.83794283708903,"// altmov
// ----------------------------------------------------------------------------------------
/**
 *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
 *     BMAT and ZMAT for the first iteration, and it maintains the values of
 *     NF and KOPT. The vector X is also changed by PRELIM.
 *
 *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the
 *       same as the corresponding arguments in SUBROUTINE BOBYQA.
 *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU
 *       are the same as the corresponding arguments in BOBYQB, the elements
 *       of SL and SU being set in BOBYQA.
 *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but
 *       it is set by PRELIM to the gradient of the quadratic model at XBASE.
 *       If XOPT is nonzero, BOBYQB will change it to its usual value later.
 *     NF is maintaned as the number of calls of CALFUN so far.
 *     KOPT will be such that the least calculated value of F so far is at
 *       the point XPT(KOPT,.)+XBASE in the space of the variables.
 *
 * @param lowerBound Lower bounds.
 * @param upperBound Upper bounds.
 */
private void prelim(double[] lowerBound, double[] upperBound) {
    // XXX
    printMethod();
    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();
    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;
    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }
    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).
    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    do {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                    // XXX
                    throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                    // XXX
                    throw new PathIsExploredException();
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                    // XXX
                    throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
                // XXX
                throw new PathIsExploredException();
            }
            final int iptMinus1 = ipt;
            final int jptMinus1 = jpt;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }
        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }
        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        // nfm + 1
        final int numEval = getEvaluations();
        fAtInterpolationPoints.setEntry(nfm, f);
        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }
        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                    // XXX
                    throw new PathIsExploredException();
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }
        // Set the off-diagonal second derivatives of the Lagrange functions and
        // the initial quadratic model.
        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);
            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
            // XXX
            throw new PathIsExploredException();
        }
    } while (getEvaluations() < npt);
}",66.68567126806096
599,True,Math,6,High,283,534,6.770833333333333,0.9354413702239791,4.125,1.0,4.0,5.179938744257274,2.2227857978930934,1.5714285714285714,0.0,40.28345104517632,"/**
 * {@inheritDoc}
 */
@Override
protected PointVectorValuePair doOptimize() {
    checkParameters();
    // Number of observed data.
    final int nR = getTarget().length;
    final double[] currentPoint = getStartPoint();
    // Number of parameters.
    final int nC = currentPoint.length;
    // arrays shared with the other private methods
    solvedCols = FastMath.min(nR, nC);
    diagR = new double[nC];
    jacNorm = new double[nC];
    beta = new double[nC];
    permutation = new int[nC];
    lmDir = new double[nC];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] oldObj = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();
    // Evaluate the function at the starting point and calculate its norm.
    double[] currentObjective = computeObjectiveValue(currentPoint);
    double[] currentResiduals = computeResiduals(currentObjective);
    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);
    double currentCost = computeCost(currentResiduals);
    // Outer loop.
    lmPar = 0;
    boolean firstIteration = true;
    int iter = 0;
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    while (true) {
        ++iter;
        final PointVectorValuePair previous = current;
        // QR decomposition of the jacobian matrix
        qrDecomposition(computeWeightedJacobian(currentPoint));
        weightedResidual = weightMatrixSqrt.operate(currentResiduals);
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
        // compute Qt.res
        qTy(qtf);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // Convergence has been reached.
            setCost(currentCost);
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
        // Inner loop.
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
            tmpVec = currentObjective;
            currentObjective = oldObj;
            oldObj = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(qtf, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
            // Evaluate the function at x + p and calculate its norm.
            currentObjective = computeObjectiveValue(currentPoint);
            currentResiduals = computeResiduals(currentObjective);
            current = new PointVectorValuePair(currentPoint, currentObjective);
            currentCost = computeCost(currentResiduals);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                // tests for convergence.
                if (checker != null) {
                    // we use the vectorial convergence checker
                    if (checker.converged(iter, previous, current)) {
                        setCost(currentCost);
                        return current;
                    }
                }
            } else {
                // failed iteration, reset the previous values
                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                tmpVec = currentObjective;
                currentObjective = oldObj;
                oldObj = tmpVec;
                // Reset ""current"" to previous values.
                current = new PointVectorValuePair(currentPoint, currentObjective);
            }
            // Default convergence criteria.
            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                setCost(currentCost);
                return current;
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}",66.08887886231257
145,True,Closure,66,Medium,461,813,10.604166666666666,0.07641633728590251,17.375,1.0,7.466666666666667,0.42189892802450224,4.588763168162311,9.428571428571429,0.0,8.291274487041356,"/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.LP:
            // ignored here.
            if (parent.getType() != Token.FUNCTION) {
                ensureTyped(t, n, getJSType(n.getFirstChild()));
            } else {
                typeable = false;
            }
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.REF_SPECIAL:
            ensureTyped(t, n);
            break;
        case Token.GET_REF:
            ensureTyped(t, n, getJSType(n.getFirstChild()));
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            // Object literal keys are handled with OBJECTLIT
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                ensureTyped(t, n, STRING_TYPE);
            // Object literal keys are not typeable
            }
            break;
        case Token.GET:
        case Token.SET:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            typeable = true;
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !NodeUtil.isExpressionNode(parent);
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                if (result != TernaryValue.UNKNOWN) {
                    if (n.getType() == Token.NE) {
                        result = result.not();
                    }
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.SHEQ:
        case Token.SHNE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
            // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right);
            validator.expectObject(t, n, rightType, ""'in' requires an object"");
            validator.expectString(t, left, leftType, ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            if (!isReference(n.getFirstChild())) {
                report(t, n, BAD_DELETE);
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.getType() == Token.OBJECTLIT) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}",59.25275768241884
663,True,Math,64,High,240,464,5.729166666666667,0.787878787878788,4.0,1.0,3.8666666666666667,5.062021439509953,2.0909090909090904,0.7857142857142857,0.0,33.1606159462545,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            // tests for convergence.
            // we use the vectorial convergence checker
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            } else {
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}",56.482972883599956
672,True,Math,68,High,219,444,5.354166666666667,0.7773386034255598,3.75,1.0,3.4,4.9992343032159265,1.9925868123293018,0.6428571428571429,0.0,31.860274740618458,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return new VectorialPointValuePair(point, objective);
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            // we use the Levenberg-Marquardt specific convergence parameters
            if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                return new VectorialPointValuePair(point, objective);
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", orthoTolerance);
            }
        }
    }
}",53.77645826911306
636,True,Math,40,Low,142,345,4.354166666666667,0.7299077733860342,3.0,0.6666666666666666,2.8666666666666667,6.091117917304748,1.8170113148653921,1.7142857142857142,0.0,26.015316270554997,"/**
 * {@inheritDoc}
 */
@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        // (by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}",47.25513899039689
618,True,Math,23,Low,114,281,4.604166666666667,1.6205533596837947,2.25,1.3333333333333333,3.533333333333333,4.959418070444105,1.7904799063597345,0.7142857142857143,0.0,20.470248559050834,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}",41.27581894315752
619,True,Math,24,Low,108,271,4.604166666666667,1.6205533596837947,2.25,1.3333333333333333,3.533333333333333,4.945635528330781,1.7975029262582911,0.5714285714285714,0.0,20.056539132723536,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return current;
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return current;
        }
        ++iter;
    }
}",40.712492851758306
595,True,Math,6,High,367,515,3.9791666666666665,0.4716732542819497,4.375,0.6666666666666666,4.133333333333334,2.8476263399693718,1.855247756535311,4.285714285714286,0.0,15.799488994005099,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        final int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}",38.41391729717269
669,True,Math,66,High,93,244,4.229166666666667,1.5889328063241106,2.5,1.3333333333333333,3.2,4.856814701378254,1.7803355442840423,0.0,0.0,17.993641313593553,"/**
 * Find the minimum of the function within the interval {@code (lo, hi)}.
 *
 * If the function is defined on the interval {@code (lo, hi)}, then
 * this method finds an approximation {@code x} to the point at which
 * the function attains its minimum.<br/>
 * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}
 * and the function is never evaluated at two points closer together than
 * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and
 * preferable not much less than <em>sqrt(macheps)</em>, where
 * <em>macheps</em> is the relative machine precision. {@code t} should be
 * positive.
 * @param isMinim {@code true} when minimizing the function.
 * @param lo Lower bound of the interval.
 * @param mid Point inside the interval {@code [lo, hi]}.
 * @param hi Higher bound of the interval.
 * @param eps Relative accuracy.
 * @param t Absolute accuracy.
 * @return the optimum point.
 * @throws MaxIterationsExceededException if the maximum iteration count
 * is exceeded.
 * @throws FunctionEvaluationException if an error occurs evaluating
 * the function.
 */
private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {
    if (eps <= 0) {
        throw new NotStrictlyPositiveException(eps);
    }
    if (t <= 0) {
        throw new NotStrictlyPositiveException(t);
    }
    double a, b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(f, x);
    if (goalType == GoalType.MAXIMIZE) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    int count = 0;
    while (count < maximalIterationCount) {
        double m = 0.5 * (a + b);
        final double tol1 = eps * Math.abs(x) + t;
        final double tol2 = 2 * tol1;
        // Check stopping criterion.
        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (Math.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (Math.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(f, u);
            if (goalType == GoalType.MAXIMIZE) {
                fu = -fu;
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || w == x) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || v == x || v == w) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // termination
            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
            return x;
        }
        ++count;
    }
    throw new MaxIterationsExceededException(maximalIterationCount);
}",37.48222436557996
675,True,Math,71,Critical,191,366,3.8541666666666665,1.4782608695652173,2.25,1.0,2.6,3.4984686064318526,1.518142801404603,2.357142857142857,0.0,18.752819039039107,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[y0.length];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
                    }
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // we cannot simply truncate the step, reject the current computation
                        // and let the loop compute another state with the truncated step.
                        // it is so small (much probably exactly 0 due to limited accuracy)
                        // that the code above would fail handling it.
                        // So we set up an artificial 0 size step by copying states
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",37.309000840250306
503,True,Lang,1,High,450,614,4.770833333333333,1.0882740447957842,4.875,1.0,4.0,3.1569678407350685,2.2329301599687876,3.2857142857142856,0.0,12.863691076761105,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
 * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
 * prefix is more than 8 - or BigInteger if there are more than 16 digits.
 * </p>
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>
 * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
 * be Integer, Long or BigDecimal as appropriate.
 * </p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = { ""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#"" };
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) {
        // we have a hex number
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) {
            // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    // assumes both not present
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
    // and the parsing which will detect if e or E appear in a number due to using the wrong offset
    // Check required precision (LANG-693)
    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1) {
            // there is an exponent
            if (expPos < decPos || expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    // small and go from there...
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) {
        // Must be an Integer, Long, Biginteger
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        return createBigInteger(str);
    }
    // Must be a Float, Double, BigDecimal
    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        if (numDecimals <= 7) {
            // If number has 7 or fewer digits past the decimal point then make it a float
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    try {
        if (numDecimals <= 16) {
            // If number has between 8 and 16 digits past the decimal point then make it a double
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    return createBigDecimal(str);
}",37.27341074130837
607,True,Math,15,High,1441,1599,4.145833333333333,0.08168642951251637,3.0,0.3333333333333333,2.2,5.7021439509954055,1.8700741318767076,-0.14285714285714285,0.0,18.887700654913672,"/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */
public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * HEX_40000000;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
        yb = y - ya;
    }
    /* Compute ln(x) */
    final double lores = log(x, lns);
    if (Double.isInfinite(lores)) {
        // don't allow this to be converted to NaN
        return lores;
    }
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * HEX_40000000;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    // result = result + result * z;
    return result;
}",36.07791469110783
689,True,Math,81,High,822,928,2.2708333333333335,1.6679841897233203,1.25,1.0,1.2666666666666666,5.330015313935681,0.9851736246586034,0.21428571428571427,0.0,19.924400857240375,"/**
 * Find realEigenvalues using dqd/dqds algorithms.
 * <p>This implementation is based on Beresford N. Parlett
 * and Osni A. Marques paper <a
 * href=""http://www.netlib.org/lapack/lawnspdf/lawn155.pdf"">An
 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
 * corresponding LAPACK routine DLASQ2.</p>
 * @param n number of rows of the block
 * @exception InvalidMatrixException if block cannot be diagonalized
 * after 30 * n iterations
 */
private void processGeneralBlock(final int n) throws InvalidMatrixException {
    // check decomposed matrix data range
    double sumOffDiag = 0;
    for (int i = 0; i < n - 1; ++i) {
        final int fourI = 4 * i;
        final double ei = work[fourI + 2];
        sumOffDiag += ei;
    }
    if (sumOffDiag == 0) {
        // matrix is already diagonal
        return;
    }
    // initial checks for splits (see Parlett & Marques section 3.3)
    flipIfWarranted(n, 2);
    // two iterations with Li's test for initial splits
    initialSplits(n);
    // initialize parameters used by goodStep
    tType = 0;
    dMin1 = 0;
    dMin2 = 0;
    dN = 0;
    dN1 = 0;
    dN2 = 0;
    tau = 0;
    // process split segments
    int i0 = 0;
    int n0 = n;
    while (n0 > 0) {
        // retrieve shift that was temporarily stored as a negative off-diagonal element
        sigma = (n0 == n) ? 0 : -work[4 * n0 - 2];
        sigmaLow = 0;
        // find start of a new split segment to process
        double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
        double offDiagMax = 0;
        double diagMax = work[4 * n0 - 4];
        double diagMin = diagMax;
        i0 = 0;
        for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
            if (work[i + 2] <= 0) {
                i0 = 1 + i / 4;
                break;
            }
            if (diagMin >= 4 * offDiagMax) {
                diagMin = Math.min(diagMin, work[i + 4]);
                offDiagMax = Math.max(offDiagMax, work[i + 2]);
            }
            diagMax = Math.max(diagMax, work[i] + work[i + 2]);
            offDiagMin = Math.min(offDiagMin, work[i + 2]);
        }
        work[4 * n0 - 2] = offDiagMin;
        // lower bound of Gershgorin disk
        dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));
        pingPong = 0;
        int maxIter = 30 * (n0 - i0);
        for (int k = 0; i0 < n0; ++k) {
            if (k >= maxIter) {
                throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
            }
            // perform one step
            n0 = goodStep(i0, n0);
            pingPong = 1 - pingPong;
            // when the last elements of qd array are very small
            if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
                int split = i0 - 1;
                diagMax = work[4 * i0];
                offDiagMin = work[4 * i0 + 2];
                double previousEMin = work[4 * i0 + 3];
                for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                    if ((work[i + 3] <= TOLERANCE_2 * work[i]) && (work[i + 2] <= TOLERANCE_2 * sigma)) {
                        // insert a split
                        work[i + 2] = -sigma;
                        split = i / 4;
                        diagMax = 0;
                        offDiagMin = work[i + 6];
                        previousEMin = work[i + 7];
                    } else {
                        diagMax = Math.max(diagMax, work[i + 4]);
                        offDiagMin = Math.min(offDiagMin, work[i + 2]);
                        previousEMin = Math.min(previousEMin, work[i + 3]);
                    }
                }
                work[4 * n0 - 2] = offDiagMin;
                work[4 * n0 - 1] = previousEMin;
                i0 = split + 1;
            }
        }
    }
}",33.90935969984369
227,True,Closure,132,Medium,636,868,4.9375,1.1778656126482214,1.875,1.0,4.866666666666666,0.9563552833078101,1.723371049551308,9.857142857142858,0.0,7.157660756644095,"/**
 * Try turning IF nodes into smaller HOOKs
 *
 * Returns the replacement for n or the original if no replacement was
 * necessary.
 */
private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();
    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                // until CollapseProperties has been run.
                return n;
            }
            if (cond.isNot()) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return n;
                }
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                // we can further optimize its parent.
                return n;
            }
            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else {
            // Try to combine two IF-ELSE
            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
                Node innerIf = thenBranch.getFirstChild();
                if (innerIf.isIf()) {
                    Node innerCond = innerIf.getFirstChild();
                    Node innerThenBranch = innerCond.getNext();
                    Node innerElseBranch = innerThenBranch.getNext();
                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                        n.detachChildren();
                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                        n.addChildrenToBack(innerThenBranch.detachFromParent());
                        reportCodeChange();
                        // the inner IF-ELSE wasn't able to be folded into && anyways.
                        return n;
                    }
                }
            }
        }
        return n;
    }
    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...
                !mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
        // if(x)foo();else bar(); -> x?foo():bar()
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }
    return n;
}",33.55156222596096
504,True,Lang,3,Low,450,610,4.604166666666667,1.1040843214756257,4.625,1.0,3.8,2.5199081163859107,2.1681623097932112,3.2857142857142856,0.0,10.441790147299404,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
 * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
 * prefix is more than 8 - or BigInteger if there are more than 16 digits.
 * </p>
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>
 * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
 * be Integer, Long or BigDecimal as appropriate.
 * </p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = { ""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#"" };
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) {
        // we have a hex number
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) {
            // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    // assumes both not present
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
    // and the parsing which will detect if e or E appear in a number due to using the wrong offset
    // Check required precision (LANG-693)
    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1) {
            // there is an exponent
            if (expPos < decPos || expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    // small and go from there...
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) {
        // Must be an Integer, Long, Biginteger
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        return createBigInteger(str);
    }
    // Must be a Float, Double, BigDecimal
    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    return createBigDecimal(str);
}",33.54882584733511
508,True,Lang,7,High,445,598,4.395833333333333,1.040843214756258,4.375,1.0,4.2,2.6531393568147013,2.105735466250487,3.4285714285714284,0.0,10.285736448872118,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it
 * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x
 * prefix is more than 8.
 * Values with leading <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        // drop 0x
        int hexDigits = str.length() - 2;
        if (str.startsWith(""-"")) {
            // drop -
            hexDigits--;
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",33.484859248598326
679,True,Math,74,High,191,359,3.7291666666666665,1.3570487483530962,2.0,1.0,2.3333333333333335,3.1906584992343032,1.479126024190401,2.2857142857142856,0.0,16.05406755850195,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale;
                if (vecAbsoluteTolerance == null) {
                    scale = new double[y0.length];
                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);
                } else {
                    scale = vecAbsoluteTolerance;
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // rejecting the step would lead to a too small next step, we accept it
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",33.42911511599404
156,True,Closure,74,Medium,887,1069,5.229166666666667,0.903820816864295,8.0,1.0,3.8,1.6546707503828484,2.885290674990246,2.357142857142857,0.0,5.872264550457028,"/**
 * Try to fold comparison nodes, e.g ==
 */
@SuppressWarnings(""fallthrough"")
private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {
        // We only handle non-literal operands for LT and GT.
        if (n.getType() != Token.GT && n.getType() != Token.LT) {
            return n;
        }
    }
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    switch(lhType) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
                return n;
            } else if (!rightLiteral) {
                return n;
            } else {
                result = compareToUndefined(right, op);
            }
            break;
        case Token.NULL:
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = lhType == rhType;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = lhType != rhType;
                    break;
                case Token.GE:
                case Token.LE:
                case Token.GT:
                case Token.LT:
                    Boolean compareResult = compareAsNumbers(op, left, right);
                    if (compareResult != null) {
                        result = compareResult;
                    } else {
                        return n;
                    }
                    break;
                default:
                    // we only handle == and != here
                    return n;
            }
            break;
        case Token.THIS:
            if (right.getType() != Token.THIS) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = true;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = false;
                    break;
                // whether it is a string, NaN or other number value.
                default:
                    return n;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return n;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
                result = compareResult;
            } else {
                return null;
            }
            break;
        case Token.NAME:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    result = compareToUndefined(right, op);
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return n;
            }
            switch(op) {
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return n;
            }
            break;
        default:
            // assert, this should cover all consts
            return n;
    }
    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();
    return newNode;
}",31.70235631650394
519,True,Lang,16,High,444,594,4.104166666666667,1.098814229249012,4.125,1.0,3.6666666666666665,2.7021439509954055,2.031603589543504,3.0714285714285716,0.0,9.599325720314095,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",31.399149394863922
529,True,Lang,27,High,452,599,3.9791666666666665,1.1251646903820816,3.875,1.0,3.533333333333333,2.5826952526799385,1.9793211080764739,2.9285714285714284,0.0,8.89005453512471,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",29.893307014834633
635,True,Math,39,High,190,328,2.8541666666666665,1.3886693017127798,1.625,1.0,1.5333333333333334,2.9441041347626338,1.1841591884510327,2.2857142857142856,0.0,14.141047712081933,"/**
 * {@inheritDoc}
 */
@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}",28.956194622722663
558,True,Lang,44,High,138,286,3.9791666666666665,1.1251646903820816,3.875,1.0,3.4,2.0022970903522204,1.987124463519314,2.9285714285714284,0.0,7.101024258875467,"// --------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // empty catch
                }
            // Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            return createBigInteger(val);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            return createBigDecimal(val);
        }
    }
}",27.398348598367175
578,True,Lang,58,High,397,545,3.9791666666666665,1.1251646903820816,3.875,1.0,3.4,1.94104134762634,1.981662114709326,3.0,0.0,7.029941356284379,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // Fall through
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",27.331976175668796
548,True,Lang,36,Low,448,595,3.9791666666666665,1.1251646903820816,3.875,1.0,3.466666666666667,1.9104134762633993,1.985563792430745,2.9285714285714284,0.0,6.87524434881509,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}",27.14579106979608
574,True,Lang,53,High,620,744,2.7291666666666665,2.0685111989459815,2.625,1.3333333333333333,2.3333333333333335,3.4065849923430322,1.4650799843932898,0.8571428571428571,0.0,10.138621075573464,"// -----------------------------------------------------------------------
/**
 * <p>Internal calculation method.</p>
 *
 * @param val  the calendar
 * @param field  the field constant
 * @param round  true to round, false to truncate
 * @throws ArithmeticException if the year is over 280 million
 */
private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }
    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    // see http://issues.apache.org/jira/browse/LANG-59
    // 
    // Manually truncate milliseconds, seconds and minutes, rather than using
    // Calendar methods.
    Date date = val.getTime();
    long time = date.getTime();
    boolean done = false;
    // truncate milliseconds
    int millisecs = val.get(Calendar.MILLISECOND);
    if (!round || millisecs < 500) {
        time = time - millisecs;
        if (field == Calendar.SECOND) {
            done = true;
        }
    }
    // truncate seconds
    int seconds = val.get(Calendar.SECOND);
    if (!done && (!round || seconds < 30)) {
        time = time - (seconds * 1000L);
        if (field == Calendar.MINUTE) {
            done = true;
        }
    }
    // truncate minutes
    int minutes = val.get(Calendar.MINUTE);
    if (!done && (!round || minutes < 30)) {
        time = time - (minutes * 60000L);
    }
    // reset time
    if (date.getTime() != time) {
        date.setTime(time);
        val.setTime(date);
    }
    // ----------------- Fix for LANG-59 ----------------------- END ----------------
    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                // This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        // we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        // We need at add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        // We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        // These are special types of fields that require different rounding rules
        switch(field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    // If we're going to drop the DATE field's value,
                    // we want to do this our own way.
                    // We need to subtrace 1 since the date has a minimum of 1
                    offset = val.get(Calendar.DATE) - 1;
                    // bottom half of the month and should stay accordingly.
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    // Record whether we're in the top or bottom half of that range
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    // If we're going to drop the HOUR field's value,
                    // we want to do this our own way.
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            // Calculate the offset from the minimum allowed value
            offset = val.get(fields[i][0]) - min;
            // Set roundUp if this is more than half way between the minimum and maximum
            roundUp = offset > ((max - min) / 2);
        }
        // We need to remove this field
        if (offset != 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",26.956773441731958
552,True,Lang,39,High,3605,3731,2.3125,0.5349143610013174,2.125,0.6666666666666666,2.466666666666667,4.186064318529862,1.2434646898166215,0.7142857142857143,0.0,11.99994971255913,"/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, *) = IllegalArgumentException
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {
    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {
        return text;
    }
    // if recursing, this shouldnt be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }
    int searchLength = searchList.length;
    int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: "" + searchLength + "" vs "" + replacementLength);
    }
    // keep track of which still have matches
    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}",26.249512129525982
214,True,Closure,119,Low,306,430,3.8958333333333335,2.268774703557312,5.5,1.3333333333333333,2.7333333333333334,1.186064318529862,2.2898946547015218,1.5,0.0,3.803927128148449,"public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();
    String name;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;
    switch(n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            // This may be a key in an object literal declaration.
            name = null;
            if (parent != null && parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;
            switch(n.getType()) {
                case Token.STRING_KEY:
                    type = getValueType(n.getFirstChild());
                    break;
                case Token.GETTER_DEF:
                    type = Name.Type.GET;
                    break;
                case Token.SETTER_DEF:
                    type = Name.Type.SET;
                    break;
                default:
                    throw new IllegalStateException(""unexpected:"" + n);
            }
            break;
        case Token.NAME:
            // This may be a variable get or set.
            if (parent != null) {
                switch(parent.getType()) {
                    case Token.VAR:
                        isSet = true;
                        Node rvalue = n.getFirstChild();
                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                        break;
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                        }
                        break;
                    case Token.GETPROP:
                        return;
                    case Token.FUNCTION:
                        Node gramps = parent.getParent();
                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                            return;
                        }
                        isSet = true;
                        type = Name.Type.FUNCTION;
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            // This may be a namespaced name get or set.
            if (parent != null) {
                switch(parent.getType()) {
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                            isPropAssign = true;
                        }
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    case Token.GETPROP:
                        return;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }
    // We are only interested in global names.
    if (!isGlobalNameReference(name, scope)) {
        return;
    }
    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}",24.511160804937145
676,True,Math,71,Critical,95,220,2.5208333333333335,1.2042160737812913,1.5,1.0,1.8,2.6745788667687593,1.1654311353882174,1.2142857142857142,0.0,9.710901782208303,"/**
 * {@inheritDoc}
 */
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        for (boolean loop = true; loop; ) {
            // first stage
            computeDerivatives(stepStart, y, yDotK[0]);
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                    // we cannot simply truncate the step, reject the current computation
                    // and let the loop compute another state with the truncated step.
                    // it is so small (much probably exactly 0 due to limited accuracy)
                    // that the code above would fail handling it.
                    // So we set up an artificial 0 size step by copying states
                    loop = false;
                } else {
                    // reject the step to match exactly the next switch time
                    stepSize = dt;
                }
            } else {
                loop = false;
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (manager.reset(stepStart, y) && !lastStep) {
            // some events handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        // make sure step size is set to default before next step
        stepSize = forward ? step : -step;
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}",22.79024690576562
527,True,Lang,24,High,1319,1421,2.3958333333333335,0.4400527009222661,2.25,1.3333333333333333,2.933333333333333,3.7373660030627867,1.3886071010534522,-0.5,0.0,8.537259248876826,"/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                // str == ""0x""
                return false;
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    // don't want to loop to the last char, check it afterwords
    sz--;
    // for type qualifiers
    int i = start;
    // make a valid number (e.g. chars[0..5] = ""1234E"")
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            // we've already taken care of hex.
            if (hasExp) {
                // two E's
                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            // we need a digit after the E
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            // no type qualifier, OK
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            // can't have an E at the last byte
            return false;
        }
        if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            // single trailing decimal point after non-exponent is ok
            return foundDigit;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            // not allowing L with an exponent or decimal point
            return foundDigit && !hasExp;
        }
        // last character is illegal
        return false;
    }
    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
    return !allowSigns && foundDigit;
}",22.51578505391533
521,True,Lang,18,High,463,584,4.6875,0.6245059288537548,6.0,1.3333333333333333,1.6666666666666667,0.5045941807044411,2.455325790089739,1.2857142857142858,0.0,3.020585752391061,"// Parse the pattern
// -----------------------------------------------------------------------
/**
 * <p>Returns a list of Rules given a pattern.</p>
 *
 * @return a {@code List} of Rule objects
 * @throws IllegalArgumentException if pattern is invalid
 */
protected List<Rule> parsePattern() {
    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
    List<Rule> rules = new ArrayList<Rule>();
    String[] ERAs = symbols.getEras();
    String[] months = symbols.getMonths();
    String[] shortMonths = symbols.getShortMonths();
    String[] weekdays = symbols.getWeekdays();
    String[] shortWeekdays = symbols.getShortWeekdays();
    String[] AmPmStrings = symbols.getAmPmStrings();
    int length = mPattern.length();
    int[] indexRef = new int[1];
    for (int i = 0; i < length; i++) {
        indexRef[0] = i;
        String token = parseToken(mPattern, indexRef);
        i = indexRef[0];
        int tokenLen = token.length();
        if (tokenLen == 0) {
            break;
        }
        Rule rule;
        char c = token.charAt(0);
        switch(c) {
            case // era designator (text)
            'G':
                rule = new TextField(Calendar.ERA, ERAs);
                break;
            case // year (number)
            'y':
                if (tokenLen >= 4) {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
                } else {
                    rule = TwoDigitYearField.INSTANCE;
                }
                break;
            case // month in year (text and number)
            'M':
                if (tokenLen >= 4) {
                    rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    rule = TwoDigitMonthField.INSTANCE;
                } else {
                    rule = UnpaddedMonthField.INSTANCE;
                }
                break;
            case // day in month (number)
            'd':
                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
                break;
            case // hour in am/pm (number, 1..12)
            'h':
                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
                break;
            case // hour in day (number, 0..23)
            'H':
                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
                break;
            case // minute in hour (number)
            'm':
                rule = selectNumberRule(Calendar.MINUTE, tokenLen);
                break;
            case // second in minute (number)
            's':
                rule = selectNumberRule(Calendar.SECOND, tokenLen);
                break;
            case // millisecond (number)
            'S':
                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
                break;
            case // day in week (text)
            'E':
                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                break;
            case // day in year (number)
            'D':
                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                break;
            case // day of week in month (number)
            'F':
                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
                break;
            case // week in year (number)
            'w':
                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
                break;
            case // week in month (number)
            'W':
                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
                break;
            case // am/pm marker (text)
            'a':
                rule = new TextField(Calendar.AM_PM, AmPmStrings);
                break;
            case // hour in day (1..24)
            'k':
                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
                break;
            case // hour in am/pm (0..11)
            'K':
                rule = selectNumberRule(Calendar.HOUR, tokenLen);
                break;
            case // time zone (text)
            'z':
                if (tokenLen >= 4) {
                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);
                } else {
                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);
                }
                break;
            case // time zone (value)
            'Z':
                if (tokenLen == 1) {
                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
                } else {
                    rule = TimeZoneNumberRule.INSTANCE_COLON;
                }
                break;
            case // literal text
            '\'':
                String sub = token.substring(1);
                if (sub.length() == 1) {
                    rule = new CharacterLiteral(sub.charAt(0));
                } else {
                    rule = new StringLiteral(sub);
                }
                break;
            default:
                throw new IllegalArgumentException(""Illegal pattern component: "" + token);
        }
        rules.add(rule);
    }
    return rules;
}",21.57822593775328
650,True,Math,50,High,128,253,2.9375,1.7523056653491438,4.625,1.0,2.3333333333333335,2.103369065849923,2.055013655872026,0.5,0.0,3.6954432088951,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Nothing.
                    if (x == x1) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",21.001964929299525
549,True,Lang,36,Low,1312,1406,2.1458333333333335,0.4664031620553359,2.0,1.3333333333333333,2.7333333333333334,3.5597243491577335,1.2668747561451414,-0.5,0.0,7.881337688725022,"/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                // str == ""0x""
                return false;
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    // don't want to loop to the last char, check it afterwords
    sz--;
    // for type qualifiers
    int i = start;
    // make a valid number (e.g. chars[0..5] = ""1234E"")
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            // we've already taken care of hex.
            if (hasExp) {
                // two E's
                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            // we need a digit after the E
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            // no type qualifier, OK
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            // can't have an E at the last byte
            return false;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            // not allowing L with an exponent
            return foundDigit && !hasExp;
        }
        // last character is illegal
        return false;
    }
    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
    return !allowSigns && foundDigit;
}",20.886839956083232
645,True,Math,48,High,129,251,2.7708333333333335,1.6996047430830037,4.5,1.0,2.2,1.7802450229709035,2.035505267264925,0.2857142857142857,0.0,2.7864238888882946,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",19.058326541254743
626,True,Math,31,High,123,199,1.7291666666666667,0.909090909090909,1.625,1.0,1.6666666666666667,3.144716692189893,1.0241904018728054,0.21428571428571427,0.0,7.124287015033805,"/**
 * <p>
 * Evaluates the continued fraction at the value x.
 * </p>
 *
 * <p>
 * The implementation of this method is based on the modified Lentz algorithm as described
 * on page 18 ff. in:
 * <ul>
 * <li>
 *   I. J. Thompson,  A. R. Barnett. ""Coulomb and Bessel Functions of Complex Arguments and Order.""
 *   <a target=""_blank"" href=""http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf"">
 *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>
 * </li>
 * </ul>
 * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in
 * <a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">Continued Fraction / MathWorld</a>.
 * </p>
 *
 * @param x the evaluation point.
 * @param epsilon maximum error allowed.
 * @param maxIterations maximum number of convergents
 * @return the value of the continued fraction evaluated at x.
 * @throws ConvergenceException if the algorithm fails to converge.
 */
public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);
    // use the value of small as epsilon criteria for zero checks
    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }
    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;
    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);
        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            double scaleFactor = 1d;
            double lastScaleFactor = 1d;
            final int maxPower = 5;
            final double scale = FastMath.max(a, b);
            if (scale <= 0) {
                // Can't scale
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
            }
            for (int i = 0; i < maxPower; i++) {
                lastScaleFactor = scaleFactor;
                scaleFactor *= scale;
                if (a != 0.0 && a > b) {
                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                } else if (b != 0) {
                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                }
                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                    break;
                }
            }
        }
        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;
        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }
        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }
        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }
    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }
    return hN;
}",18.43740406580646
651,True,Math,51,High,128,247,2.6458333333333335,1.7154150197628457,4.125,1.0,2.1333333333333333,1.8062787136294025,1.944986344127974,0.2857142857142857,0.0,2.7626882167966476,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                // search interval.
                default:
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",18.419249246697824
596,True,Math,6,High,172,268,2.3125,0.5032938076416338,1.0,0.3333333333333333,0.8666666666666667,2.760336906584992,1.071790870074131,0.7857142857142857,0.0,8.602733496892345,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
        // Default convergence check.
        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
            // User-defined stopping criteria.
            if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}",18.236369366907386
124,True,Closure,50,Low,367,476,2.7708333333333335,0.5296442687747035,1.875,0.3333333333333333,1.6666666666666667,1.4019908116385913,1.401872805306282,3.2142857142857144,0.0,4.621179358182463,"/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }
    Node right = callTarget.getNext();
    if (right != null) {
        if (!NodeUtil.isImmutableValue(right)) {
            return n;
        }
    }
    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return n;
    }
    // "","" is the default, it doesn't need to be explicit
    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            if (sb != null) {
                Preconditions.checkNotNull(prev);
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
                sb = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }
    if (sb != null) {
        Preconditions.checkNotNull(prev);
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            n.getParent().replaceChild(n, emptyStringNode);
            reportCodeChange();
            return emptyStringNode;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD, Node.newString("""").copyInformationFrom(n), foldedStringNode);
                foldedStringNode = replacement;
            }
            n.getParent().replaceChild(n, foldedStringNode);
            reportCodeChange();
            return foldedStringNode;
        default:
            // No folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return n;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            reportCodeChange();
            break;
    }
    return n;
}",17.814806291521087
685,True,Math,78,High,167,263,1.6041666666666667,1.9420289855072461,1.5,1.3333333333333333,1.5333333333333334,2.4111791730474734,0.9539602028872413,0.9285714285714286,0.0,5.5586463904851895,"/**
 * Evaluate the impact of the proposed step on the event handler.
 * @param interpolator step interpolator for the proposed step
 * @return true if the event handler triggers an event before
 * the end of the proposed step (this implies the step should be
 * rejected)
 * @exception DerivativeException if the interpolator fails to
 * compute the switching function somewhere within the step
 * @exception EventException if the switching function
 * cannot be evaluated
 * @exception ConvergenceException if an event cannot be located
 */
public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {
    try {
        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
        final double h = (t1 - t0) / n;
        double ta = t0;
        double ga = g0;
        double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
        for (int i = 0; i < n; ++i) {
            // evaluate handler value at the end of the substep
            tb += h;
            interpolator.setInterpolatedTime(tb);
            final double gb = handler.g(tb, interpolator.getInterpolatedState());
            // check events occurrence
            if (g0Positive ^ (gb >= 0)) {
                // there is a sign change: an event is expected during this step
                // this is a corner case:
                // - there was an event near ta,
                // - there is another event between ta and tb
                // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                // this implies that the real sign of ga is the same as gb, so we need to slightly
                // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                // about bracketing
                // this should never happen
                // variation direction, with respect to the integration direction
                increasing = gb >= ga;
                final UnivariateRealFunction f = new UnivariateRealFunction() {

                    public double value(final double t) throws FunctionEvaluationException {
                        try {
                            interpolator.setInterpolatedTime(t);
                            return handler.g(t, interpolator.getInterpolatedState());
                        } catch (DerivativeException e) {
                            throw new FunctionEvaluationException(e, t);
                        } catch (EventException e) {
                            throw new FunctionEvaluationException(e, t);
                        }
                    }
                };
                final BrentSolver solver = new BrentSolver();
                solver.setAbsoluteAccuracy(convergence);
                solver.setMaximalIterationCount(maxIterationCount);
                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {
                    // we have either found nothing or found (again ?) a past event, we simply ignore it
                    ta = tb;
                    ga = gb;
                } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                        // properly ends exactly at the event occurrence
                        return false;
                    }
                    // either we were not waiting for the event or it has
                    // moved in such a way the step cannot be accepted
                    pendingEvent = true;
                    return true;
                }
            } else {
                // no sign change: there is no event for now
                ta = tb;
                ga = gb;
            }
        }
        // no event during the whole step
        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;
    } catch (FunctionEvaluationException e) {
        final Throwable cause = e.getCause();
        if ((cause != null) && (cause instanceof DerivativeException)) {
            throw (DerivativeException) cause;
        } else if ((cause != null) && (cause instanceof EventException)) {
            throw (EventException) cause;
        }
        throw new EventException(e);
    }
}",17.765219513831912
97,True,Closure,31,Medium,1236,1387,3.2708333333333335,0.9723320158102766,2.875,1.0,2.066666666666667,0.5061255742725881,1.7538041357783847,3.0,0.0,2.188249429986508,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;
        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }
            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);
                    input.getModule().remove(input);
                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }
        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",17.633011155847758
594,True,Math,6,High,191,288,2.2291666666666665,0.5559947299077732,1.75,0.6666666666666666,1.1333333333333333,2.5719754977029092,1.2044479126024195,0.42857142857142855,0.0,6.981453563828138,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    final double[] point = getStartPoint();
    final GoalType goal = getGoalType();
    final int n = point.length;
    double[] r = computeObjectiveGradient(point);
    if (goal == GoalType.MINIMIZE) {
        for (int i = 0; i < n; i++) {
            r[i] = -r[i];
        }
    }
    // Initial search direction.
    double[] steepestDescent = preconditioner.precondition(point, r);
    double[] searchDirection = steepestDescent.clone();
    double delta = 0;
    for (int i = 0; i < n; ++i) {
        delta += r[i] * searchDirection[i];
    }
    PointValuePair current = null;
    int iter = 0;
    int maxEval = getMaxEvaluations();
    while (true) {
        ++iter;
        final double objective = computeObjectiveValue(point);
        PointValuePair previous = current;
        current = new PointValuePair(point, objective);
        if (previous != null) {
            if (checker.converged(iter, previous, current)) {
                // We have found an optimum.
                return current;
            }
        }
        // Find the optimal step in the search direction.
        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
        final double uB = findUpperBound(lsf, 0, initialStep);
        // XXX Last parameters is set to a value close to zero in order to
        // work around the divergence problem in the ""testCircleFitting""
        // unit test (see MATH-439).
        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
        // Subtract used up evaluations.
        maxEval -= solver.getEvaluations();
        // Validate new point.
        for (int i = 0; i < point.length; ++i) {
            point[i] += step * searchDirection[i];
        }
        r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; ++i) {
                r[i] = -r[i];
            }
        }
        // Compute beta.
        final double deltaOld = delta;
        final double[] newSteepestDescent = preconditioner.precondition(point, r);
        delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * newSteepestDescent[i];
        }
        final double beta;
        switch(updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        steepestDescent = newSteepestDescent;
        // Compute conjugate search direction.
        if (iter % n == 0 || beta < 0) {
            // Break conjugation: reset search direction.
            searchDirection = steepestDescent.clone();
        } else {
            // Compute new conjugate search direction.
            for (int i = 0; i < n; ++i) {
                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
            }
        }
    }
}",17.521609799279332
609,True,Math,16,High,443,553,2.2291666666666665,-0.7035573122529645,0.25,-0.3333333333333333,-0.06666666666666667,3.872128637059724,0.9274287943815835,-0.35714285714285715,0.0,11.587487842743684,"/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */
public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20) {
        // Avoid overflow (MATH-905).
        return 0.5 * exp(x);
    }
    if (x < -20) {
        // Avoid overflow (MATH-905).
        return -0.5 * exp(-x);
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * HEX_40000000;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * HEX_40000000;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * HEX_40000000;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * HEX_40000000;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}",17.405511771455835
461,True,Csv,15,High,1151,1256,2.2291666666666665,2.142292490118577,2.375,1.6666666666666667,1.7333333333333334,1.5750382848392037,1.4026531408505656,0.42857142857142855,0.0,3.5598233305907065,"/*
     * Note: must only be called if quoting is enabled, otherwise will generate NPE
     */
// the original object is needed so can check for Number
private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;
    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
        case ALL_NON_NULL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = value.charAt(pos);
                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {
                    quote = true;
                } else if (c <= COMMENT) {
                    // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
        // no encapsulation needed - write out the original value
        out.append(value, start, end);
        return;
    }
    // we hit something that needed encapsulation
    out.append(quoteChar);
    // the need for encapsulation.
    while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
            // write out the chunk up until this point
            // add 1 to the length to write out the encapsulator also
            out.append(value, start, pos + 1);
            // put the next starting position on the encapsulator so we will
            // write it out again with the next string (effectively doubling it)
            start = pos;
        }
        pos++;
    }
    // write the last segment
    out.append(value, start, pos);
    out.append(quoteChar);
}",17.112545341637148
460,True,Csv,14,Low,1001,1106,2.1875,2.163372859025033,2.25,1.6666666666666667,1.6666666666666667,1.650076569678407,1.3730003901677723,0.42857142857142855,0.0,3.6401441430645596,"/*
     * Note: must only be called if quoting is enabled, otherwise will generate NPE
     */
// the original object is needed so can check for Number
private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;
    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = value.charAt(pos);
                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {
                    quote = true;
                } else if (c <= COMMENT) {
                    // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
        // no encapsulation needed - write out the original value
        out.append(value, start, end);
        return;
    }
    // we hit something that needed encapsulation
    out.append(quoteChar);
    // the need for encapsulation.
    while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
            // write out the chunk up until this point
            // add 1 to the length to write out the encapsulator also
            out.append(value, start, pos + 1);
            // put the next starting position on the encapsulator so we will
            // write it out again with the next string (effectively doubling it)
            start = pos;
        }
        pos++;
    }
    // write the last segment
    out.append(value, start, pos);
    out.append(quoteChar);
}",17.025998723840534
155,True,Closure,73,Medium,988,1058,1.8125,1.1673254281949934,2.625,1.0,1.4666666666666666,2.0972434915773355,1.3183769020678902,1.5714285714285714,0.0,3.79075181863995,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",16.849292878575408
364,True,Codec,2,High,414,473,1.4791666666666667,0.888010540184453,1.25,0.6666666666666666,1.2,3.5520673813169985,0.8852906749902458,-0.35714285714285715,0.0,7.127528950051732,"/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes.
 * Must be called at least twice:  once with the data to encode, and once
 * with inAvail set to ""-1"" to alert encoder that EOF has been reached,
 * so flush last remaining bytes (if not multiple of 3).
 * </p><p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
 * and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in byte[] array of binary data to base64 encode.
 * @param inPos Position to start reading data from.
 * @param inAvail Amount of bytes available from input for encoding.
 */
void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // encoding.
    if (inAvail < 0) {
        eof = true;
        if (buf == null || buf.length - pos < encodeSize) {
            resizeBuf();
        }
        switch(modulus) {
            case 1:
                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buf[pos++] = PAD;
                    buf[pos++] = PAD;
                }
                break;
            case 2:
                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buf[pos++] = PAD;
                }
                break;
        }
        if (lineLength > 0) {
            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buf == null || buf.length - pos < encodeSize) {
                resizeBuf();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            x = (x << 8) + b;
            if (0 == modulus) {
                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buf[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && lineLength <= currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}",16.691588022733907
162,True,Closure,78,Medium,664,746,1.7708333333333333,0.33992094861660055,2.75,0.6666666666666666,1.6,2.2947932618683,1.2684354272337104,1.2142857142857142,0.0,4.640977630648377,"/**
 * Try to fold arithmetic binary operators
 */
private Node performArithmeticOp(int opType, Node left, Node right) {
    // to Number.
    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }
    double result;
    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.
    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
        return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
        return null;
    }
    double lval = lValObj;
    double rval = rValObj;
    switch(opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval % rval;
            break;
        case Token.DIV:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // point, fixed-point math starts to break down and become inaccurate.
    Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    } else if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }
    return null;
}",16.545912982652702
161,True,Closure,77,High,956,1025,1.6875,1.230566534914361,2.375,1.0,1.4,2.1370597243491574,1.2356613343737817,1.5,0.0,3.7225706083817403,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",16.28835820201904
588,True,Lang,65,High,619,713,1.4791666666666667,2.0790513833992095,1.625,1.3333333333333333,1.0666666666666667,2.625574272588055,0.9921966445571601,0.2857142857142857,0.0,4.7816647710798,"// -----------------------------------------------------------------------
/**
 * <p>Internal calculation method.</p>
 *
 * @param val  the calendar
 * @param field  the field constant
 * @param round  true to round, false to truncate
 * @throws ArithmeticException if the year is over 280 million
 */
private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    // see http://issues.apache.org/jira/browse/LANG-59
    // 
    // Manually truncate milliseconds, seconds and minutes, rather than using
    // Calendar methods.
    // truncate milliseconds
    // truncate seconds
    // truncate minutes
    // reset time
    // ----------------- Fix for LANG-59 ----------------------- END ----------------
    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                // This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        // we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        // We need at add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        // We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        // These are special types of fields that require different rounding rules
        switch(field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    // If we're going to drop the DATE field's value,
                    // we want to do this our own way.
                    // We need to subtrace 1 since the date has a minimum of 1
                    offset = val.get(Calendar.DATE) - 1;
                    // bottom half of the month and should stay accordingly.
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    // Record whether we're in the top or bottom half of that range
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    // If we're going to drop the HOUR field's value,
                    // we want to do this our own way.
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            // Calculate the offset from the minimum allowed value
            offset = val.get(fields[i][0]) - min;
            // Set roundUp if this is more than half way between the minimum and maximum
            roundUp = offset > ((max - min) / 2);
        }
        // We need to remove this field
        val.set(fields[i][0], val.get(fields[i][0]) - offset);
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",16.268368024005177
365,True,Codec,3,Low,418,469,0.7291666666666666,-0.18181818181818193,0.75,2.0,2.2666666666666666,2.501531393568147,0.28755364806866973,1.7142857142857142,0.0,5.950552466384987,"/**
 * Handles 'G' cases
 */
private int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {
    if (charAt(value, index + 1) == 'H') {
        index = handleGH(value, result, index);
    } else if (charAt(value, index + 1) == 'N') {
        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {
            result.append(""KN"", ""N"");
        } else if (!contains(value, index + 2, 2, ""EY"") && charAt(value, index + 1) != 'Y' && !slavoGermanic) {
            result.append(""N"", ""KN"");
        } else {
            result.append(""KN"");
        }
        index = index + 2;
    } else if (contains(value, index + 1, 2, ""LI"") && !slavoGermanic) {
        result.append(""KL"", ""L"");
        index += 2;
    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {
        // -- -ges-, -gep-, -gel-, -gie- at beginning --//
        result.append('K', 'J');
        index += 2;
    } else if ((contains(value, index + 1, 2, ""ER"") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, ""DANGER"", ""RANGER"", ""MANGER"") && !contains(value, index - 1, 1, ""E"", ""I"") && !contains(value, index - 1, 3, ""RGY"", ""OGY"")) {
        // -- -ger-, -gy- --//
        result.append('K', 'J');
        index += 2;
    } else if (contains(value, index + 1, 1, ""E"", ""I"", ""Y"") || contains(value, index - 1, 4, ""AGGI"", ""OGGI"")) {
        // -- Italian ""biaggi"" --//
        if ((contains(value, 0, 4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"")) || contains(value, index + 1, 2, ""ET"")) {
            // -- obvious germanic --//
            result.append('K');
        } else if (contains(value, index + 1, 4, ""IER"")) {
            result.append('J');
        } else {
            result.append('J', 'K');
        }
        index += 2;
    } else if (charAt(value, index + 1) == 'G') {
        index += 2;
        result.append('K');
    } else {
        index++;
        result.append('K');
    }
    return index;
}",16.01793837382267
144,True,Closure,65,Medium,1005,1075,1.8125,1.1673254281949934,2.625,1.0,1.4666666666666666,1.6347626339969372,1.3199375731564569,1.5714285714285714,0.0,3.092336301005642,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",15.689957174449265
316,True,Closure,163,High,236,309,1.0625,2.010540184453228,1.5,2.0,2.6666666666666665,0.826186830015314,0.7768240343347629,2.9285714285714284,0.0,1.7525226641216232,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isGetProp()) {
        String propName = n.getFirstChild().getNext().getString();
        if (propName.equals(""prototype"")) {
            processPrototypeParent(t, parent);
        } else if (compiler.getCodingConvention().isExported(propName)) {
            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
        } else {
            // Do not mark prototype prop assigns as a 'use' in the global scope.
            addSymbolUse(propName, t.getModule(), PROPERTY);
        }
    } else if (n.isObjectLit() && // Foo.prototype = {bar: 3, baz: 5};
    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(""prototype""))) {
        // should count as a use of property a and b.
        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {
            // May be STRING, GET, or SET, but NUMBER isn't interesting.
            if (!propNameNode.isQuotedString()) {
                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);
            }
        }
    } else if (n.isName()) {
        String name = n.getString();
        Var var = t.getScope().getVar(name);
        if (var != null) {
            // Only process global functions.
            if (var.isGlobal()) {
                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {
                    if (t.inGlobalScope()) {
                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {
                            addGlobalUseOfSymbol(name, t.getModule(), VAR);
                        }
                    } else {
                        addSymbolUse(name, t.getModule(), VAR);
                    }
                }
            // If it is not a global, it might be accessing a local of the outer
            // scope. If that's the case the functions between the variable's
            // declaring scope and the variable reference scope cannot be moved.
            } else if (var.getScope() != t.getScope()) {
                for (int i = symbolStack.size() - 1; i >= 0; i--) {
                    NameContext context = symbolStack.get(i);
                    if (context.scope == var.getScope()) {
                        break;
                    }
                    context.name.readClosureVariables = true;
                }
            }
        }
    }
    // Process prototype assignments to non-functions.
    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {
        symbolStack.pop();
    }
}",15.523811808163023
565,True,Lang,46,Critical,178,253,2.1875,1.5889328063241106,3.375,2.0,0.9333333333333333,0.7557427258805512,1.6913772922356602,1.5714285714285714,0.0,1.3362860264041165,"/**
 * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>
 *
 * @param out write to receieve the escaped string
 * @param str String to escape values in, may be null
 * @param escapeSingleQuote escapes single quotes if <code>true</code>
 * @param escapeForwardSlash TODO
 * @throws IOException if an IOException occurs
 */
private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz;
    sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);
        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + hex(ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + hex(ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + hex(ch));
        } else if (ch < 32) {
            switch(ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    if (ch > 0xf) {
                        out.write(""\\u00"" + hex(ch));
                    } else {
                        out.write(""\\u000"" + hex(ch));
                    }
                    break;
            }
        } else {
            switch(ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                case '/':
                    out.write('\\');
                    out.write('/');
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}",15.439600755606342
439,True,Compress,41,Low,219,324,2.3958333333333335,-0.4242424242424243,1.0,0.6666666666666666,1.3333333333333333,1.4678407350689129,1.0936402653140842,2.4285714285714284,0.0,5.400163915658333,"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        return null;
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;
        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;
        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        }
    }
    entriesRead++;
    return current.entry;
}",15.361807253703667
585,True,Lang,63,High,262,361,2.3958333333333335,-0.45586297760210814,1.125,0.0,1.4666666666666666,1.5781010719754975,1.083495903238392,2.0,0.0,6.1174382935652405,"/**
 * <p>Formats the time gap as a string, using the specified format.
 * Padding the left hand side of numbers with zeroes is optional and
 * the timezone may be specified.
 *
 * @param startMillis  the start of the duration
 * @param endMillis  the end of the duration
 * @param format  the way in which to format the duration
 * @param padWithZeros whether to pad the left hand side of numbers with 0's
 * @param timezone the millis are defined in
 * @return the time as a String
 */
public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
    long millis = endMillis - startMillis;
    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
        return formatDuration(millis, format, padWithZeros);
    }
    Token[] tokens = lexx(format);
    // timezones get funky around 0, so normalizing everything to GMT
    // stops the hours being off
    Calendar start = Calendar.getInstance(timezone);
    start.setTime(new Date(startMillis));
    Calendar end = Calendar.getInstance(timezone);
    end.setTime(new Date(endMillis));
    // initial estimates
    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);
    // each initial estimate is adjusted in case it is under 0
    while (milliseconds < 0) {
        milliseconds += 1000;
        seconds -= 1;
    }
    while (seconds < 0) {
        seconds += 60;
        minutes -= 1;
    }
    while (minutes < 0) {
        minutes += 60;
        hours -= 1;
    }
    while (hours < 0) {
        hours += 24;
        days -= 1;
    }
    while (days < 0) {
        days += 31;
        // days += 31; // TODO: Need tests to show this is bad and the new code is good.
        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is
        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
        // Also it's contextual - if asked for no M in the format then I should probably
        // be doing no calculating here.
        months -= 1;
    }
    while (months < 0) {
        months += 12;
        years -= 1;
    }
    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
    // number of months and get the real count and not just 0->11.
    if (!Token.containsTokenWithValue(tokens, y)) {
        if (Token.containsTokenWithValue(tokens, M)) {
            months += 12 * years;
            years = 0;
        } else {
            // TODO: this is a bit weak, needs work to know about leap years
            days += 365 * years;
            years = 0;
        }
    }
    if (!Token.containsTokenWithValue(tokens, M)) {
        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        months = 0;
    }
    if (!Token.containsTokenWithValue(tokens, d)) {
        hours += 24 * days;
        days = 0;
    }
    if (!Token.containsTokenWithValue(tokens, H)) {
        minutes += 60 * hours;
        hours = 0;
    }
    if (!Token.containsTokenWithValue(tokens, m)) {
        seconds += 60 * minutes;
        minutes = 0;
    }
    if (!Token.containsTokenWithValue(tokens, s)) {
        milliseconds += 1000 * seconds;
        seconds = 0;
    }
    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
}",15.31067229117702
584,True,Lang,62,Low,884,945,1.6458333333333333,3.570487483530962,1.25,2.0,0.8,1.391271056661562,1.1193913382754586,1.0,0.0,2.204904202425139,"/**
 * <p>Unescapes the escaped entities in the <code>String</code> passed and
 * writes the result to the <code>Writer</code> passed.</p>
 *
 * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.
 * @param string The <code>String</code> to write the results to; assumed to be non-null.
 * @throws IOException when <code>Writer</code> passed throws the exception from
 *                                       calls to the {@link Writer#write(int)} methods.
 *
 * @see #escape(String)
 * @see Writer
 */
public void unescape(Writer writer, String string) throws IOException {
    int firstAmp = string.indexOf('&');
    if (firstAmp < 0) {
        writer.write(string);
        return;
    }
    writer.write(string, 0, firstAmp);
    int len = string.length();
    for (int i = firstAmp; i < len; i++) {
        char c = string.charAt(i);
        if (c == '&') {
            int nextIdx = i + 1;
            int semiColonIdx = string.indexOf(';', nextIdx);
            if (semiColonIdx == -1) {
                writer.write(c);
                continue;
            }
            int amphersandIdx = string.indexOf('&', i + 1);
            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {
                // Then the text looks like &...&...;
                writer.write(c);
                continue;
            }
            String entityContent = string.substring(nextIdx, semiColonIdx);
            int entityValue = -1;
            int entityContentLen = entityContent.length();
            if (entityContentLen > 0) {
                if (entityContent.charAt(0) == '#') {
                    // escaped value content is an integer (decimal or hexidecimal)
                    if (entityContentLen > 1) {
                        char isHexChar = entityContent.charAt(1);
                        try {
                            switch(isHexChar) {
                                case 'X':
                                case 'x':
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                    }
                                default:
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                    }
                            }
                        } catch (NumberFormatException e) {
                        }
                    }
                } else {
                    // escaped value content is an entity name
                    entityValue = this.entityValue(entityContent);
                }
            }
            if (entityValue == -1) {
                writer.write('&');
                writer.write(entityContent);
                writer.write(';');
            } else {
                writer.write(entityValue);
            }
            // move index up to the semi-colon
            i = semiColonIdx;
        } else {
            writer.write(c);
        }
    }
}",14.981887414226454
573,True,Lang,52,Low,171,242,2.0208333333333335,1.6416337285902505,3.125,2.0,0.8666666666666667,0.711332312404288,1.607101053452985,1.4285714285714286,0.0,1.2018366685319386,"/**
 * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>
 *
 * @param out write to receieve the escaped string
 * @param str String to escape values in, may be null
 * @param escapeSingleQuote escapes single quotes if <code>true</code>
 * @throws IOException if an IOException occurs
 */
private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz;
    sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);
        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + hex(ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + hex(ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + hex(ch));
        } else if (ch < 32) {
            switch(ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    if (ch > 0xf) {
                        out.write(""\\u00"" + hex(ch));
                    } else {
                        out.write(""\\u000"" + hex(ch));
                    }
                    break;
            }
        } else {
            switch(ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}",14.602975191550891
256,True,Closure,144,Medium,550,644,1.3541666666666667,1.6521739130434783,1.5,1.0,2.066666666666667,0.729709035222052,0.7908700741318762,2.2857142857142856,0.0,2.5644294461854837,"/**
 * Gets the function type from the function node and its attached
 * {@link JSDocInfo}.
 * @param name the function's name
 * @param rValue the function node. It must be a {@link Token#FUNCTION}.
 * @param info the {@link JSDocInfo} attached to the function definition
 * @param lvalueNode The node where this function is being
 *     assigned. For example, {@code A.prototype.foo = ...} would be used to
 *     determine that this function is a method of A.prototype. May be
 *     null to indicate that this is not being assigned to a qualified name.
 */
private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
    FunctionType functionType = null;
    // Handle function aliases.
    if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
            functionType = (FunctionType) var.getType();
            if (functionType != null && functionType.isConstructor()) {
                typeRegistry.declareType(name, functionType.getInstanceType());
            }
        }
        return functionType;
    }
    Node owner = null;
    if (lvalueNode != null) {
        owner = getPrototypePropertyOwner(lvalueNode);
    }
    Node errorRoot = rValue == null ? lvalueNode : rValue;
    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;
    Node fnRoot = isFnLiteral ? rValue : null;
    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;
    if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);
        // Known to be not null since we have the FUNCTION token there.
        type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
            functionType = (FunctionType) type;
            functionType.setJSDocInfo(info);
        }
    }
    if (functionType == null) {
        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
            // to this function.
            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {
                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());
                if (var != null) {
                    ObjectType ownerType = ObjectType.cast(var.getType());
                    FunctionType propType = null;
                    if (ownerType != null) {
                        String propName = lvalueNode.getLastChild().getString();
                        propType = findOverriddenFunction(ownerType, propName);
                    }
                    if (propType != null) {
                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();
                    }
                }
            }
        }
    }
    if (functionType == null) {
        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();
    }
    // assigning the function type to the function node
    if (rValue != null) {
        setDeferredType(rValue, functionType);
    }
    // all done
    return functionType;
}",13.94373008763051
513,True,Lang,11,Low,223,289,1.5208333333333333,1.225296442687747,1.375,1.0,1.6666666666666667,2.3514548238897395,1.0101443620756922,-0.21428571428571427,0.0,4.005909309275252,"/**
 * <p>Creates a random string based on a variety of options, using
 * supplied source of randomness.</p>
 *
 * <p>If start and end are both {@code 0}, start and end are set
 * to {@code ' '} and {@code 'z'}, the ASCII printable
 * characters, will be used, unless letters and numbers are both
 * {@code false}, in which case, start and end are set to
 * {@code 0} and {@code Integer.MAX_VALUE}.
 *
 * <p>If set is not {@code null}, characters between start and
 * end are chosen.</p>
 *
 * <p>This method accepts a user-supplied {@link Random}
 * instance to use as a source of randomness. By seeding a single
 * {@link Random} instance with a fixed seed and using it for each call,
 * the same random sequence of strings can be generated repeatedly
 * and predictably.</p>
 *
 * @param count  the length of random string to create
 * @param start  the position in set of chars to start at
 * @param end  the position in set of chars to end before
 * @param letters  only allow letters?
 * @param numbers  only allow numbers?
 * @param chars  the set of chars to choose randoms from, must not be empty.
 *  If {@code null}, then it will use the set of all chars.
 * @param random  a source of randomness.
 * @return the random string
 * @throws ArrayIndexOutOfBoundsException if there are not
 *  {@code (end - start) + 1} characters in the set array.
 * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.
 * @since 2.0
 */
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }
    char[] buffer = new char[count];
    int gap = end - start;
    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }
        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 0) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[count] = ch;
                    count--;
                    buffer[count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 0) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[count] = (char) (56320 + random.nextInt(128));
                    count--;
                    buffer[count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}",13.941019223642716
196,True,Closure,105,Medium,1461,1549,2.1041666666666665,0.5559947299077732,1.625,0.3333333333333333,1.2666666666666666,1.1202143950995407,1.2052282481467027,2.642857142857143,0.0,3.080684593961014,"/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }
    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return;
    }
    String joinString = NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getStringValue(elem));
        } else {
            if (sb.length() > 0) {
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    if (sb.length() > 0) {
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        default:
            // No folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}",13.93414577663884
134,True,Closure,58,Medium,178,263,2.0208333333333335,0.6561264822134388,2.25,1.0,1.7333333333333334,0.6378254211332313,1.36285602809208,2.5714285714285716,0.0,1.6083068432647465,"/**
 * Computes the GEN and KILL set.
 *
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at
 *        {@code n} will be added to this set.
 * @param kill Local variables that are killed because of the instruction at
 *        {@code n} will be added to this set.
 * @param conditional {@code true} if any assignments encountered are
 *        conditionally executed. These assignments might not kill a variable.
 */
private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {
    switch(n.getType()) {
        case Token.SCRIPT:
        case Token.BLOCK:
        case Token.FUNCTION:
            return;
        case Token.WHILE:
        case Token.DO:
        case Token.IF:
            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            return;
        case Token.FOR:
            if (!NodeUtil.isForIn(n)) {
                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            } else {
                // for(x in y) {...}
                Node lhs = n.getFirstChild();
                Node rhs = lhs.getNext();
                if (NodeUtil.isVar(lhs)) {
                    // for(var x in y) {...}
                    lhs = lhs.getLastChild();
                }
                addToSetIfLocal(lhs, kill);
                addToSetIfLocal(lhs, gen);
                computeGenKill(rhs, gen, kill, conditional);
            }
            return;
        case Token.VAR:
            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                if (c.hasChildren()) {
                    computeGenKill(c.getFirstChild(), gen, kill, conditional);
                    if (!conditional) {
                        addToSetIfLocal(c, kill);
                    }
                }
            }
            return;
        case Token.AND:
        case Token.OR:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // May short circuit.
            computeGenKill(n.getLastChild(), gen, kill, true);
            return;
        case Token.HOOK:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // Assume both sides are conditional.
            computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
            computeGenKill(n.getLastChild(), gen, kill, true);
            return;
        case Token.NAME:
            if (isArgumentsName(n)) {
                markAllParametersEscaped();
            } else {
                addToSetIfLocal(n, gen);
            }
            return;
        default:
            if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
                Node lhs = n.getFirstChild();
                if (!conditional) {
                    addToSetIfLocal(lhs, kill);
                }
                if (!NodeUtil.isAssign(n)) {
                    // assignments such as a += 1 reads a.
                    addToSetIfLocal(lhs, gen);
                }
                computeGenKill(lhs.getNext(), gen, kill, conditional);
            } else {
                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                    computeGenKill(c, gen, kill, conditional);
                }
            }
            return;
    }
}",13.840710012798734
75,True,Closure,14,Medium,692,789,1.7291666666666667,1.2938076416337287,2.125,1.6666666666666667,2.0,0.3652373660030627,1.2785797893094026,2.142857142857143,0.0,0.9762450688884444,"/**
 * Computes the follow() node of a given node and its parent. There is a side
 * effect when calling this function. If this function computed an edge that
 * exists a FINALLY, it'll attempt to connect the fromNode to the outer
 * FINALLY according to the finallyMap.
 *
 * @param fromNode The original source node since {@code node} is changed
 *        during recursion.
 * @param node The node that follow() should compute.
 */
private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }
    // If we are just before a IF/WHILE/DO/FOR:
    switch(parent.getType()) {
        // The follow() of any of the path from IF would be what follows IF.
        case Token.IF:
            return computeFollowNode(fromNode, parent, cfa);
        case Token.CASE:
        case Token.DEFAULT_CASE:
            // case, without having to go to the case condition.
            if (parent.getNext() != null) {
                if (parent.getNext().isCase()) {
                    return parent.getNext().getFirstChild().getNext();
                } else if (parent.getNext().isDefaultCase()) {
                    return parent.getNext().getFirstChild();
                } else {
                    Preconditions.checkState(false, ""Not reachable"");
                }
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
            break;
        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                return parent.getFirstChild().getNext().getNext();
            }
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
            // If we are coming out of the TRY block...
            if (parent.getFirstChild() == node) {
                if (NodeUtil.hasFinally(parent)) {
                    // and have FINALLY block.
                    return computeFallThrough(parent.getLastChild());
                } else {
                    // and have no FINALLY.
                    return computeFollowNode(fromNode, parent, cfa);
                }
            // CATCH block.
            } else if (NodeUtil.getCatchBlock(parent) == node) {
                if (NodeUtil.hasFinally(parent)) {
                    // and have FINALLY block.
                    return computeFallThrough(node.getNext());
                } else {
                    return computeFollowNode(fromNode, parent, cfa);
                }
            // If we are coming out of the FINALLY block...
            } else if (parent.getLastChild() == node) {
                if (cfa != null) {
                    for (Node finallyNode : cfa.finallyMap.get(parent)) {
                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
                    }
                }
                return computeFollowNode(fromNode, parent, cfa);
            }
    }
    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();
    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
        nextSibling = nextSibling.getNext();
    }
    if (nextSibling != null) {
        return computeFallThrough(nextSibling);
    } else {
        // If there are no more siblings, control is transferred up the AST.
        return computeFollowNode(fromNode, parent, cfa);
    }
}",13.577560342025114
120,True,Closure,48,Medium,1416,1561,1.5208333333333333,0.41897233201581024,1.5,0.6666666666666666,2.6,0.48468606431852984,0.8134998049161127,3.0,0.0,2.4971213114964583,"/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
    // Precedence of type information on GETPROPs:
    // 1) @type annnotation / @enum annotation
    // 2) ASSIGN to FUNCTION literal
    // 3) @param/@return annotation (with no function literal)
    // 4) ASSIGN to something marked @const
    // 5) ASSIGN to anything else
    // 
    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
    // the function has jsdoc or has not been declared before.
    // 
    // FUNCTION literals are special because TypedScopeCreator is very smart
    // about getting as much type information as possible for them.
    // Determining type for #1 + #2 + #3 + #4
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
    }
    // allow F.prototype to be redefined arbitrarily.
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to an object literal,
            // then they are responsible for making sure that the object literal's
            // implicit prototype is set up appropriately. We just obey
            // the @extends tag.
            ObjectType qVarType = ObjectType.cast(qVar.getType());
            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {
                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());
            } else if (!qVar.isTypeInferred()) {
                // what props are going to be on that prototype.
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.isExprResult()) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    // NOTE(nicksantos): Determining whether a property is declared or not
    // is really really obnoxious.
    // 
    // The problem is that there are two (equally valid) coding styles:
    // 
    // (function() {
    // /* The authoritative definition of goog.bar. */
    // goog.bar = function() {};
    // })();
    // 
    // function f() {
    // goog.bar();
    // /* Reset goog.bar to a no-op. */
    // goog.bar = function() {};
    // }
    // 
    // In a dynamic language with first-class functions, it's very difficult
    // to know which one the user intended without looking at lots of
    // contextual information (the second example demonstrates a small case
    // of this, but there are some really pathological cases as well).
    // 
    // The current algorithm checks if either the declaration has
    // jsdoc type information, or @const with a known type,
    // or a function literal with a name we haven't seen before.
    boolean inferred = true;
    if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            // Only declare this as an official property if it has not been
            // declared yet.
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                // If the property is undeclared or inferred, declare it now.
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",13.501779512746912
583,True,Lang,62,Low,813,870,1.4375,1.6890645586297761,1.0,1.6666666666666667,0.8,1.6148545176110263,0.9508388607101057,1.2857142857142858,0.0,2.6545980375058718,"/**
 * <p>Unescapes the entities in a <code>String</code>.</p>
 *
 * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),
 * unescape(&quot;&amp;foo;&quot;) will return &quot;\u00A1&quot;</p>
 *
 * @param str The <code>String</code> to escape.
 * @return A new escaped <code>String</code>.
 */
public String unescape(String str) {
    int firstAmp = str.indexOf('&');
    if (firstAmp < 0) {
        return str;
    }
    StringBuffer buf = new StringBuffer(str.length());
    buf.append(str.substring(0, firstAmp));
    for (int i = firstAmp; i < str.length(); ++i) {
        char ch = str.charAt(i);
        if (ch == '&') {
            int semi = str.indexOf(';', i + 1);
            if (semi == -1) {
                buf.append(ch);
                continue;
            }
            int amph = str.indexOf('&', i + 1);
            if (amph != -1 && amph < semi) {
                // Then the text looks like &...&...;
                buf.append(ch);
                continue;
            }
            String entityName = str.substring(i + 1, semi);
            int entityValue;
            if (entityName.length() == 0) {
                entityValue = -1;
            } else if (entityName.charAt(0) == '#') {
                if (entityName.length() == 1) {
                    entityValue = -1;
                } else {
                    char charAt1 = entityName.charAt(1);
                    try {
                        if (charAt1 == 'x' || charAt1 == 'X') {
                            entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();
                        } else {
                            entityValue = Integer.parseInt(entityName.substring(1));
                        }
                    } catch (NumberFormatException ex) {
                        entityValue = -1;
                    }
                }
            } else {
                entityValue = this.entityValue(entityName);
            }
            if (entityValue == -1) {
                buf.append('&');
                buf.append(entityName);
                buf.append(';');
            } else {
                buf.append((char) (entityValue));
            }
            i = semi;
        } else {
            buf.append(ch);
        }
    }
    return buf.toString();
}",13.099236926837733
622,True,Math,28,High,90,154,1.0625,1.2779973649538867,1.0,1.3333333333333333,1.3333333333333333,1.7695252679938742,0.7182988685134597,0.9285714285714286,0.0,2.939034502534166,"/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(SimplexTableau tableau, final int col) {
    // create a list of all the rows that tie for the lowest score in the minimum ratio test
    List<Integer> minRatioPositions = new ArrayList<Integer>();
    double minRatio = Double.MAX_VALUE;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            final double ratio = rhs / entry;
            // check if the entry is strictly equal to the current min ratio
            // do not use a ulp/epsilon check
            final int cmp = Double.compare(ratio, minRatio);
            if (cmp == 0) {
                minRatioPositions.add(i);
            } else if (cmp < 0) {
                minRatio = ratio;
                minRatioPositions = new ArrayList<Integer>();
                minRatioPositions.add(i);
            }
        }
    }
    if (minRatioPositions.size() == 0) {
        return null;
    } else if (minRatioPositions.size() > 1) {
        // 1. check if there's an artificial variable that can be forced out of the basis
        for (Integer row : minRatioPositions) {
            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                int column = i + tableau.getArtificialVariableOffset();
                final double entry = tableau.getEntry(row, column);
                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                    return row;
                }
            }
        }
        // 2. apply Bland's rule to prevent cycling:
        // take the row for which the corresponding basic variable has the smallest index
        // 
        // see http://www.stanford.edu/class/msande310/blandrule.pdf
        // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
        // 
        // Additional heuristic: if we did not get a solution after half of maxIterations
        // revert to the simple case of just returning the top-most row
        // This heuristic is based on empirical data gathered while investigating MATH-828.
        Integer minRow = null;
        int minIndex = tableau.getWidth();
        for (Integer row : minRatioPositions) {
            int i = tableau.getNumObjectiveFunctions();
            for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                if (row == tableau.getBasicRow(i)) {
                    if (i < minIndex) {
                        minIndex = i;
                        minRow = row;
                    }
                }
            }
        }
        return minRow;
    }
    return minRatioPositions.get(0);
}",12.362594099233483
396,True,Compress,4,High,67,129,1.1875,1.1620553359683794,1.125,1.0,1.6,0.8062787136294026,0.7635583300819351,2.642857142857143,0.0,1.9240520549909217,"/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */
public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}",12.211301577527781
80,True,Closure,18,Medium,1240,1362,2.5208333333333335,0.8142292490118577,2.125,0.6666666666666666,1.4666666666666666,0.02986217457886681,1.5009754194303542,2.2142857142857144,0.0,0.8362212946983131,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        hoistExterns(externsRoot);
        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        hoistNoCompileFiles();
        if (staleInputs) {
            repartitionInputs();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",12.174740518671774
128,True,Closure,54,Medium,1373,1489,1.3958333333333333,0.36627140974967076,1.375,0.6666666666666666,2.2666666666666666,0.4739663093415007,0.7541943035505262,2.5714285714285716,0.0,2.2970008356274754,"/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
    // Precedence of type information on GETPROPs:
    // 1) @type annnotation / @enum annotation
    // 2) ASSIGN to FUNCTION literal
    // 3) @param/@return annotation (with no function literal)
    // 4) ASSIGN to something marked @const
    // 5) ASSIGN to anything else
    // 
    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
    // the function has jsdoc or has not been declared before.
    // 
    // FUNCTION literals are special because TypedScopeCreator is very smart
    // about getting as much type information as possible for them.
    // Determining type for #1 + #2 + #3 + #4
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
    }
    // allow F.prototype to be redefined arbitrarily.
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            // the @extends tag.
            if (!qVar.isTypeInferred()) {
                // what props are going to be on that prototype.
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    boolean inferred = true;
    if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            // Only declare this as an official property if it has not been
            // declared yet.
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                // If the property is undeclared or inferred, declare it now.
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",12.16702809636441
514,True,Lang,12,Critical,223,282,1.2291666666666667,1.2621870882740447,1.0,1.0,1.4,2.210566615620214,0.8376902067889183,-0.21428571428571427,0.0,3.3772114437096303,"/**
 * <p>Creates a random string based on a variety of options, using
 * supplied source of randomness.</p>
 *
 * <p>If start and end are both {@code 0}, start and end are set
 * to {@code ' '} and {@code 'z'}, the ASCII printable
 * characters, will be used, unless letters and numbers are both
 * {@code false}, in which case, start and end are set to
 * {@code 0} and {@code Integer.MAX_VALUE}.
 *
 * <p>If set is not {@code null}, characters between start and
 * end are chosen.</p>
 *
 * <p>This method accepts a user-supplied {@link Random}
 * instance to use as a source of randomness. By seeding a single
 * {@link Random} instance with a fixed seed and using it for each call,
 * the same random sequence of strings can be generated repeatedly
 * and predictably.</p>
 *
 * @param count  the length of random string to create
 * @param start  the position in set of chars to start at
 * @param end  the position in set of chars to end before
 * @param letters  only allow letters?
 * @param numbers  only allow numbers?
 * @param chars  the set of chars to choose randoms from, must not be empty.
 *  If {@code null}, then it will use the set of all chars.
 * @param random  a source of randomness.
 * @return the random string
 * @throws ArrayIndexOutOfBoundsException if there are not
 *  {@code (end - start) + 1} characters in the set array.
 * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.
 * @since 2.0
 */
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (start == 0 && end == 0) {
        if (!letters && !numbers) {
            end = Integer.MAX_VALUE;
        } else {
            end = 'z' + 1;
            start = ' ';
        }
    }
    char[] buffer = new char[count];
    int gap = end - start;
    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }
        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 0) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[count] = ch;
                    count--;
                    buffer[count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 0) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[count] = (char) (56320 + random.nextInt(128));
                    count--;
                    buffer[count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}",12.102536306773759
216,True,Closure,121,Medium,254,327,1.1458333333333333,1.0144927536231882,0.75,0.6666666666666666,2.0,1.1937212863705973,0.6472883339836121,1.8571428571428572,0.0,2.7765696903684574,"private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;
    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
            // Create a new node for variable that is never initialized.
            Node srcLocation = declaration.getNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            // The only reference is the initialization, remove the assignment and
            // the variable declaration.
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
    // the next pass.)
    if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        // Inlining the variable based solely on well-defined and assigned
        // once is *NOT* correct. We relax the correctness requirement if
        // the variable is declared constant.
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; /* start from a read */
        i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }
}",12.051714921488712
290,True,Closure,155,Medium,229,297,1.1458333333333333,1.0144927536231882,0.75,0.6666666666666666,1.8666666666666667,1.2059724349157734,0.6550916894264542,1.8571428571428572,0.0,2.7376900089554446,"// Any reference that is not a read of the arguments property
// consider a escape of the arguments object.
private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;
    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
            // Create a new node for variable that is never initialized.
            Node srcLocation = declaration.getNameNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            // The only reference is the initialization, remove the assignment and
            // the variable declaration.
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
    // the next pass.)
    if (!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; /* start from a read */
        i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNameNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }
}",11.899556410730384
366,True,Codec,5,Critical,550,599,0.9375,1.5836627140974966,1.125,1.0,1.0,2.7297090352220517,0.7393679282091297,-0.5714285714285714,0.0,3.3526262348509084,"/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to base64 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */
void decode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    if (inAvail < 0) {
        eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        byte b = in[inPos++];
        if (b == PAD) {
            // We're done.
            eof = true;
            break;
        } else {
            if (b >= 0 && b < DECODE_TABLE.length) {
                int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }
    }
    // This approach makes the '=' padding characters completely optional.
    if (eof && modulus != 0) {
        x = x << 6;
        switch(modulus) {
            case 2:
                x = x << 6;
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                break;
            case 3:
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                break;
        }
    }
}",11.896437340951014
84,True,Closure,22,Medium,83,155,1.2708333333333333,0.787878787878788,1.75,0.3333333333333333,2.8666666666666667,0.39739663093415,0.904799063597347,2.2857142857142856,0.0,1.296734419185408,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // so we'll allow it.
    if (n.isEmpty() || n.isComma()) {
        return;
    }
    if (parent == null) {
        return;
    }
    // fix up the tree in more clever ways when these are removed.
    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }
        // be attached to the name. This check should not complain about it.
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA)
                    continue;
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
                    return;
                else
                    break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {
        } else {
            return;
        }
    }
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.isExprResult()) {
            return;
        }
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        // try to protect side-effect free statements as well.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",11.893356520643312
442,True,Compress,43,Low,1041,1127,1.2708333333333333,-0.6772068511198946,0.375,0.3333333333333333,0.7333333333333333,1.5306278713629404,0.5161919625438947,2.7857142857142856,0.0,4.997643979897864,"private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {
    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);
    if (oldAlignmentEx != null) {
        ze.removeExtraField(ResourceAlignmentExtraField.ID);
    }
    int alignment = ze.getAlignment();
    if (alignment <= 0 && oldAlignmentEx != null) {
        alignment = oldAlignmentEx.getAlignment();
    }
    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {
        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;
        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));
        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));
    }
    final byte[] extra = ze.getLocalFileDataExtra();
    final int nameLen = name.limit() - name.position();
    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;
    final byte[] buf = new byte[len];
    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);
    // store method in local variable to prevent multiple method calls
    final int zipMethod = ze.getMethod();
    final boolean dataDescriptor = usesDataDescriptor(zipMethod);
    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);
    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);
    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);
    // compression method
    putShort(zipMethod, buf, LFH_METHOD_OFFSET);
    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);
    // CRC
    if (phased) {
        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
    } else if (zipMethod == DEFLATED || channel != null) {
        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);
    } else {
        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
    }
    // uncompressed length
    if (hasZip64Extra(entry.entry)) {
        // point to ZIP64 extended information extra field for
        // sizes, may get rewritten once sizes are known if
        // stream is seekable
        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);
        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);
    } else if (phased) {
        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
    } else if (zipMethod == DEFLATED || channel != null) {
        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);
        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);
    } else {
        // Stored
        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
    }
    // file name length
    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);
    // extra field length
    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);
    // file name
    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);
    // extra fields
    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);
    return buf;
}",11.86547124839909
98,True,Closure,32,Medium,1328,1429,1.8125,1.847167325428195,1.375,1.0,0.8666666666666667,0.6914241960183767,1.1232930159968797,1.2857142857142858,0.0,1.7902040065181084,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    do {
        switch(token) {
            case STAR:
                if (ignoreStar) {
                // Mark the position after the star as the new start of the line.
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // in the block are ok.
                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}",11.791969496342512
251,True,Closure,142,Medium,1112,1206,1.7708333333333333,1.541501976284585,1.625,1.0,0.8,0.6087289433384381,1.1732344908310572,1.2857142857142858,0.0,1.505544992815316,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    do {
        switch(token) {
            case STAR:
                if (!ignoreStar) {
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;
            case ANNOTATION:
            case EOC:
            case EOF:
                // When we're capturing a license block, annotations
                // in the block are ok.
                String multilineText = builder.toString();
                if (option != WhitespaceOption.PRESERVE) {
                    multilineText = multilineText.trim();
                }
                int endLineno = stream.getLineno();
                int endCharno = stream.getCharno();
                if (multilineText.length() > 0) {
                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                }
                return new ExtractionInfo(multilineText, token);
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}",11.310558022317016
2,True,Chart,2,Low,1229,1289,1.2708333333333333,1.225296442687747,1.125,1.0,1.2666666666666666,1.265696784073507,0.8314475224346471,0.7857142857142857,0.0,2.4881337688725025,"/**
 * Iterates over the data items of the xy dataset to find
 * the range bounds.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the y-interval or just the
 *          y-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 *
 * @since 1.0.10
 */
public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    // handle three cases by dataset type
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        // handle special case of IntervalXYDataset
        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ixyd.getStartYValue(series, item);
                double uvalue = ixyd.getEndYValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else if (includeInterval && dataset instanceof OHLCDataset) {
        // handle special case of OHLCDataset
        OHLCDataset ohlc = (OHLCDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ohlc.getLowValue(series, item);
                double uvalue = ohlc.getHighValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        // standard case - plain XYDataset
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double value = dataset.getYValue(series, item);
                if (!Double.isNaN(value)) {
                    minimum = Math.min(minimum, value);
                    maximum = Math.max(maximum, value);
                }
            }
        }
    }
    if (minimum == Double.POSITIVE_INFINITY) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}",11.25878880378269
152,True,Closure,71,Medium,407,500,0.9791666666666666,0.6561264822134388,1.25,1.3333333333333333,1.7333333333333334,0.5199081163859113,0.6074912212251267,2.2857142857142856,0.0,1.6808684106065845,"/**
 * Determines whether the given property is visible in the current context.
 * @param t The current traversal.
 * @param getprop The getprop node.
 */
private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {
    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();
    if (objectType != null) {
        // Is this a normal property access, or are we trying to override
        // an existing property?
        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
        // information.
        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        JSDocInfo docInfo = null;
        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
        }
        if (objectType == null) {
            // We couldn't find a visibility modifier; assume it's public.
            return;
        }
        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            // Check an ASSIGN statement that's trying to override a property
            // on a superclass.
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();
            // visibility of the original property.
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {
                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                // private access is always allowed in the same file.
                return;
            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                // private access is not allowed outside the file from a different
                // enclosing class.
                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                // The first two have already been checked for.
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",11.04594184947868
79,True,Closure,17,Medium,1267,1317,0.5208333333333334,2.300395256916996,0.75,2.6666666666666665,1.8,0.20750382848392043,0.400702301989855,1.7857142857142858,0.0,0.5421446202602751,"/**
 * Look for a type declaration on a property assignment
 * (in an ASSIGN or an object literal key).
 *
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                JSType knownType = null;
                if (rValue != null) {
                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",10.973960293365332
427,True,Compress,29,High,324,405,1.9375,0.42951251646903843,2.125,1.6666666666666667,1.4,0.2871362940275651,1.3690987124463512,0.8571428571428571,0.0,0.8979528731782841,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws StreamingNotSupportedException if the format cannot be
 * read from a stream
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = IOUtils.readFully(in, signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new ZipArchiveInputStream(in, entryEncoding);
            } else {
                return new ZipArchiveInputStream(in);
            }
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new JarArchiveInputStream(in, entryEncoding);
            } else {
                return new JarArchiveInputStream(in);
            }
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new CpioArchiveInputStream(in, entryEncoding);
            } else {
                return new CpioArchiveInputStream(in);
            }
        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
            return new ArjArchiveInputStream(in);
        } else if (SevenZFile.matches(signature, signatureLength)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = IOUtils.readFully(in, dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in, entryEncoding);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = IOUtils.readFully(in, tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in, entryEncoding);
        }
        // COMPRESS-117 - improve auto-recognition
        if (signatureLength >= 512) {
            TarArchiveInputStream tais = null;
            try {
                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                // COMPRESS-191 - verify the header checksum
                if (tais.getNextTarEntry().isCheckSumOK()) {
                    return new TarArchiveInputStream(in, encoding);
                }
            } catch (Exception e) {
            // NOPMD
            // can generate IllegalArgumentException as well
            // as IOException
            // autodetection, simply not a TAR
            // ignored
            } finally {
                IOUtils.closeQuietly(tais);
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}",10.970009919930762
61,True,Closure,3,High,280,411,1.8541666666666667,0.461133069828722,1.875,0.6666666666666666,2.3333333333333335,-0.031393568147013794,1.3097932110807646,1.6428571428571428,0.0,0.4677234875517185,"private boolean canInline() {
    // Cannot inline a parameter.
    if (getDefCfgNode().isFunction()) {
        return false;
    }
    // so we just back off for now.
    for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
            return false;
        }
    }
    getDefinition(getDefCfgNode(), null);
    getNumUseInUseCfgNode(useCfgNode, null);
    // Definition was not found.
    if (def == null) {
        return false;
    }
    // TODO(user): Certain cases we can still inline.
    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
    }
    // x = readProp(b), modifyProp(b); print(x);
    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
    }
    // x = readProp(b); modifyProp(b), print(x);
    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
    }
    // side-effect analysis tool.
    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
    }
    // correctly inlining twice increases code size.
    if (numUseWithinUseCfgNode != 1) {
        return false;
    }
    // Make sure that the name is not within a loop
    if (NodeUtil.isWithinLoop(use)) {
        return false;
    }
    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());
    if (uses.size() != 1) {
        return false;
    }
    // need to be special cased.
    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            switch(input.getType()) {
                case Token.GETELEM:
                case Token.GETPROP:
                case Token.ARRAYLIT:
                case Token.OBJECTLIT:
                case Token.REGEXP:
                case Token.NEW:
                    return true;
            }
            return false;
        }
    }, new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            // Recurse if the node is not a function.
            return !input.isFunction();
        }
    })) {
        return false;
    }
    // they are just next to each other.
    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
        // Similar side effect check as above but this time the side effect is
        // else where along the path.
        // x = readProp(b); while(modifyProp(b)) {}; print(x);
        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);
        if (pathCheck.somePathsSatisfyPredicate()) {
            return false;
        }
    }
    return true;
}",10.579280009838001
201,True,Closure,108,Medium,357,445,1.1458333333333333,0.6455862977602106,0.75,1.6666666666666667,1.0,0.4739663093415007,0.633242294186501,2.5714285714285716,0.0,1.65404915543848,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
        // Bleeding functions already get a BAD_PARAMETERS error, so just
        // do nothing.
        } else if (parent.getType() == Token.LP) {
        // Parameters of the scope function also get a BAD_PARAMETERS
        // error.
        } else if (isVar || isFunctionDecl) {
            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
            Node grandparent = parent.getParent();
            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;
            Node varNode = null;
            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));
            compiler.ensureLibraryInjected(""base"");
            // to be used in another expression.
            if (isFunctionDecl) {
                // Replace ""function NAME() { ... }"" with ""var NAME;"".
                Node existingName = v.getNameNode();
                // We can't keep the local name on the function expression,
                // because IE is buggy and will leak the name into the global
                // scope. This is covered in more detail here:
                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
                // 
                // This will only cause problems if this is a hoisted, recursive
                // function, and the programmer is using the hoisting.
                Node newName = IR.name("""").useSourceInfoFrom(existingName);
                value.replaceChild(existingName, newName);
                varNode = IR.var(existingName).useSourceInfoFrom(existingName);
                grandparent.replaceChild(parent, varNode);
            } else {
                if (value != null) {
                    // If this is a VAR, we can just detach the expression and
                    // the tree will still be valid.
                    value.detachFromParent();
                }
                varNode = parent;
            }
            // Make sure we copy over all the jsdoc and debug info.
            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);
                if (isHoisted) {
                    grandparent.addChildToFront(newDecl);
                } else {
                    grandparent.addChildBefore(newDecl, varNode);
                }
            }
            // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));
            recordAlias(v);
        } else {
            // Do not other kinds of local symbols, like catch params.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}",10.540772628155265
653,True,Math,54,Low,2303,2384,1.5625,-0.5138339920948617,1.125,0.0,1.0,1.8813169984686064,1.0249707374170889,1.2142857142857142,0.0,3.0804406463755063,"/**
 * Convert the instance into a double.
 * @return a double approximating the instance
 * @see #toSplitDouble()
 */
public double toDouble() {
    if (isInfinite()) {
        if (lessThan(getZero())) {
            return Double.NEGATIVE_INFINITY;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (isNaN()) {
        return Double.NaN;
    }
    Dfp y = this;
    boolean negate = false;
    if (lessThan(getZero())) {
        y = negate();
        negate = true;
    }
    /* Find the exponent, first estimate by integer log10, then adjust.
         Should be faster than doing a natural logarithm.  */
    int exponent = (int) (y.log10() * 3.32);
    if (exponent < 0) {
        exponent--;
    }
    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
        tempDfp = tempDfp.multiply(2);
        exponent++;
    }
    exponent--;
    /* We have the exponent, now work on the mantissa */
    y = y.divide(DfpMath.pow(getTwo(), exponent));
    if (exponent > -1023) {
        y = y.subtract(getOne());
    }
    if (exponent < -1074) {
        return 0;
    }
    if (exponent > 1023) {
        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
    }
    y = y.multiply(newInstance(4503599627370496l)).rint();
    String str = y.toString();
    str = str.substring(0, str.length() - 1);
    long mantissa = Long.parseLong(str);
    if (mantissa == 4503599627370496L) {
        // Handle special case where we round up to next power of two
        mantissa = 0;
        exponent++;
    }
    /* Its going to be subnormal, so make adjustments */
    if (exponent <= -1023) {
        exponent--;
    }
    while (exponent < -1023) {
        exponent++;
        mantissa >>>= 1;
    }
    long bits = mantissa | ((exponent + 1023L) << 52);
    double x = Double.longBitsToDouble(bits);
    if (negate) {
        x = -x;
    }
    return x;
}",10.374680104452054
620,True,Math,25,Low,257,329,1.4375,-0.05533596837944663,0.25,0.3333333333333333,0.4,1.977794793261868,0.656652360515021,0.0,0.0,5.137196978045788,"/**
 * Estimate a first guess of the amplitude and angular frequency.
 * This method assumes that the {@link #sortObservations()} method
 * has been called previously.
 *
 * @throws ZeroException if the abscissa range is zero.
 * @throws MathIllegalStateException when the guessing procedure cannot
 * produce sensible results.
 */
private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;
    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;
    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();
        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        // considering a linear model for f (and therefore constant f')
        final double dx = currentX - previousX;
        final double dy = currentY - previousY;
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;
        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;
        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }
    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the
        // observations are sorted.
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;
        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 1; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        // In some ill-conditioned cases (cf. MATH-844), the guesser
        // procedure cannot produce sensible results.
        a = FastMath.sqrt(c1 / c2);
        omega = FastMath.sqrt(c2 / c3);
    }
}",10.137141496776565
598,True,Math,6,High,79,169,1.7291666666666667,0.6613965744400526,1.25,0.6666666666666666,0.7333333333333333,0.8491577335375192,0.9703472493172067,0.5714285714285714,0.0,2.657994044683066,"/**
 * {@inheritDoc}
 */
@Override
public PointVectorValuePair doOptimize() {
    checkParameters();
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    // Computation will be useless without a checker (see ""for-loop"").
    if (checker == null) {
        throw new NullArgumentException();
    }
    final double[] targetValues = getTarget();
    // Number of observed data.
    final int nR = targetValues.length;
    final RealMatrix weightMatrix = getWeight();
    // Diagonal of the weight matrix.
    final double[] residualsWeights = new double[nR];
    for (int i = 0; i < nR; i++) {
        residualsWeights[i] = weightMatrix.getEntry(i, i);
    }
    final double[] currentPoint = getStartPoint();
    final int nC = currentPoint.length;
    // iterate until convergence is reached
    PointVectorValuePair current = null;
    int iter = 0;
    for (boolean converged = false; !converged; ) {
        ++iter;
        // evaluate the objective function and its jacobian
        PointVectorValuePair previous = current;
        // Value of the objective function at ""currentPoint"".
        final double[] currentObjective = computeObjectiveValue(currentPoint);
        final double[] currentResiduals = computeResiduals(currentObjective);
        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
        current = new PointVectorValuePair(currentPoint, currentObjective);
        // build the linear problem
        final double[] b = new double[nC];
        final double[][] a = new double[nC][nC];
        for (int i = 0; i < nR; ++i) {
            final double[] grad = weightedJacobian.getRow(i);
            final double weight = residualsWeights[i];
            final double residual = currentResiduals[i];
            // compute the normal equation
            final double wr = weight * residual;
            for (int j = 0; j < nC; ++j) {
                b[j] += wr * grad[j];
            }
            // build the contribution matrix for measurement i
            for (int k = 0; k < nC; ++k) {
                double[] ak = a[k];
                double wgk = weight * grad[k];
                for (int l = 0; l < nC; ++l) {
                    ak[l] += wgk * grad[l];
                }
            }
        }
        try {
            // solve the linearized least squares problem
            RealMatrix mA = new BlockRealMatrix(a);
            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();
            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
            // update the estimated parameters
            for (int i = 0; i < nC; ++i) {
                currentPoint[i] += dX[i];
            }
        } catch (SingularMatrixException e) {
            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
        }
        // Check convergence.
        if (previous != null) {
            converged = checker.converged(iter, previous, current);
            if (converged) {
                setCost(computeCost(currentResiduals));
                return current;
            }
        }
    }
    // Must never happen.
    throw new MathInternalError();
}",10.089490840073083
397,True,Compress,5,High,191,246,1.2291666666666667,0.5191040843214758,1.375,0.6666666666666666,1.4,1.481623277182236,0.9313304721030047,0.2857142857142857,0.0,2.1889320552477085,"public int read(byte[] buffer, int start, int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (inf.finished() || current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) {
        if (current.getMethod() == ZipArchiveOutputStream.STORED) {
            int csize = (int) current.getSize();
            if (readBytesOfEntry >= csize) {
                return -1;
            }
            if (offsetInBuffer >= lengthOfLastRead) {
                offsetInBuffer = 0;
                if ((lengthOfLastRead = in.read(buf)) == -1) {
                    return -1;
                }
                count(lengthOfLastRead);
                bytesReadFromStream += lengthOfLastRead;
            }
            int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length;
            if ((csize - readBytesOfEntry) < toRead) {
                toRead = csize - readBytesOfEntry;
            }
            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);
            offsetInBuffer += toRead;
            readBytesOfEntry += toRead;
            crc.update(buffer, start, toRead);
            return toRead;
        }
        if (inf.needsInput()) {
            fill();
            if (lengthOfLastRead > 0) {
                bytesReadFromStream += lengthOfLastRead;
            }
        }
        int read = 0;
        try {
            read = inf.inflate(buffer, start, length);
        } catch (DataFormatException e) {
            throw new ZipException(e.getMessage());
        }
        if (read == 0 && inf.finished()) {
            return -1;
        }
        crc.update(buffer, start, read);
        return read;
    }
    throw new ArrayIndexOutOfBoundsException();
}",10.077537507902044
221,True,Closure,126,Medium,106,201,1.6458333333333333,0.007905138339921014,1.375,0.3333333333333333,1.3333333333333333,0.503062787136294,1.0827155676941087,2.4285714285714284,0.0,1.3301060209045965,"/**
 * Attempts to minimize the number of explicit exit points in a control
 * structure to take advantage of the implied exit at the end of the
 * structure.  This is accomplished by removing redundant statements, and
 * moving statements following a qualifying IF node into that node.
 * For example:
 *
 * function () {
 *   if (x) return;
 *   else blah();
 *   foo();
 * }
 *
 * becomes:
 *
 * function () {
 *  if (x) ;
 *  else {
 *    blah();
 *    foo();
 *  }
 *
 * @param n The execution node of a parent to inspect.
 * @param exitType The type of exit to look for.
 * @param labelName If parent is a label the name of the label to look for,
 *   null otherwise.
 * @nullable labelName non-null only for breaks within labels.
 */
void tryMinimizeExits(Node n, int exitType, String labelName) {
    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        NodeUtil.removeChild(n.getParent(), n);
        compiler.reportCodeChange();
        return;
    }
    // Just an 'if'.
    if (n.isIf()) {
        Node ifBlock = n.getFirstChild().getNext();
        tryMinimizeExits(ifBlock, exitType, labelName);
        Node elseBlock = ifBlock.getNext();
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }
    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        tryMinimizeExits(tryBlock, exitType, labelName);
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (NodeUtil.hasCatchHandler(allCatchNodes)) {
            Preconditions.checkState(allCatchNodes.hasOneChild());
            Node catchNode = allCatchNodes.getFirstChild();
            Node catchCodeBlock = catchNode.getLastChild();
            tryMinimizeExits(catchCodeBlock, exitType, labelName);
        }
        /* Don't try to minimize the exits of finally blocks, as this
       * can cause problems if it changes the completion type of the finally
       * block. See ECMA 262 Sections 8.9 & 12.14
       */
        if (NodeUtil.hasFinally(n)) {
            Node finallyBlock = n.getLastChild();
            tryMinimizeExits(finallyBlock, exitType, labelName);
        }
    }
    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        tryMinimizeExits(labelBlock, exitType, labelName);
    }
    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {
        // An 'if' block to process below.
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock, falseBlock;
            // First, the true condition block.
            trueBlock = ifTree.getFirstChild().getNext();
            falseBlock = trueBlock.getNext();
            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);
            // Now the else block.
            // The if blocks may have changed, get them again.
            trueBlock = ifTree.getFirstChild().getNext();
            falseBlock = trueBlock.getNext();
            if (falseBlock != null) {
                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
            }
        }
        if (c == n.getLastChild()) {
            break;
        }
    }
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
        tryMinimizeExits(c, exitType, labelName);
        // If the node is still the last child, we are done.
        if (c == n.getLastChild()) {
            break;
        }
    }
}",10.039860942646348
287,True,Closure,154,Medium,1014,1098,1.0625,0.7193675889328065,1.25,0.6666666666666666,1.6,0.23506891271056662,0.6941084666406564,2.642857142857143,0.0,1.0923983578475693,"/**
 * Given a constructor type and a property name, check that the property has
 * the JSDoc annotation @override iff the property is declared on a
 * superclass. Several checks regarding inheritance correctness are also
 * performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {
    // already.
    if (hasUnknownOrEmptySupertype(ctorType)) {
        return;
    }
    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();
    boolean foundInterfaceProperty = false;
    if (ctorType.isConstructor()) {
        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
                continue;
            }
            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();
            Preconditions.checkNotNull(interfaceType);
            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);
            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
                // @override not present, but the property does override an interface
                // property
                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));
            }
            if (interfaceHasProperty) {
                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);
                if (!propertyType.canAssignTo(interfacePropType)) {
                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));
                }
            }
        }
    }
    if (!declaredOverride && !superClassHasProperty) {
        // nothing to do here, it's just a plain new property
        return;
    }
    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;
    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {
        // @override not present, but the property does override a superclass
        // property
        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));
    }
    if (!declaredOverride) {
        // there's no @override to check
        return;
    }
    // @override is present and we have to check that it is ok
    if (superClassHasProperty) {
        // there is a superclass implementation
        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);
        if (!propertyType.canAssignTo(superClassPropType)) {
            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));
        }
    } else if (!foundInterfaceProperty) {
        // there is no superclass nor interface implementation
        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));
    }
}",9.962967135655408
600,True,Math,7,Critical,296,405,2.1458333333333335,-0.03425559947299075,1.125,0.3333333333333333,0.3333333333333333,0.6592649310872895,1.159188451033944,2.0714285714285716,0.0,2.1585691404164447,"/**
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an event
 * asks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded
 * @exception NoBracketingException if the location of an event cannot be bracketed
 * @exception DimensionMismatchException if arrays dimensions do not match equations settings
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {
    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    // initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }
    // search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

        /**
         * {@inheritDoc}
         */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });
    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(state);
        }
    }
    while (!occuringEvents.isEmpty()) {
        // handle the chronologically first event
        final Iterator<EventState> iterator = occuringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();
        // restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);
        // get state at event time
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState().clone();
        // advance all event states to current time
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();
        // handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }
        if (isLastStep) {
            // the event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            for (final EventState remaining : occuringEvents) {
                remaining.stepAccepted(eventT, eventY);
            }
            return eventT;
        }
        boolean needReset = currentEvent.reset(eventT, eventY);
        if (needReset) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            for (final EventState remaining : occuringEvents) {
                remaining.stepAccepted(eventT, eventY);
            }
            return eventT;
        }
        // prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);
        // check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(currentEvent);
        }
    }
    // last part of the step, after the last event
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);
    // handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }
    return currentT;
}",9.95169549449326
83,True,Closure,21,Medium,83,148,1.1458333333333333,0.8616600790513833,1.625,0.3333333333333333,2.1333333333333333,0.3575803981623277,0.904799063597347,1.5714285714285714,0.0,0.919272608216968,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // so we'll allow it.
    if (n.isEmpty() || n.isComma()) {
        return;
    }
    if (parent == null) {
        return;
    }
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult()) {
        return;
    }
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (parent.getType() == Token.COMMA) {
        if (isResultUsed) {
            return;
        }
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA)
                    continue;
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
                    return;
                else
                    break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
            return;
        }
    }
    if ((isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        // try to protect side-effect free statements as well.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",9.852240720456596
342,True,Closure,169,Medium,520,606,1.1041666666666667,-0.22924901185770755,1.25,0.3333333333333333,1.8666666666666667,0.9027565084226646,0.864221615294576,2.0714285714285716,0.0,1.39770518078335,"/**
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {
    if (this == that) {
        return true;
    }
    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
        if (tolerateUnknowns) {
            // both unknown.
            return thisUnknown && thatUnknown;
        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
            // we won't unbox the unknowns further down.
            return false;
        }
    }
    if (isUnionType() && that.isUnionType()) {
        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), tolerateUnknowns);
    }
    if (isFunctionType() && that.isFunctionType()) {
        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), tolerateUnknowns);
    }
    if (isRecordType() && that.isRecordType()) {
        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), tolerateUnknowns);
    }
    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
        // Check if one type is parameterized, but the other is not.
        boolean paramsMatch = false;
        if (thisParamType != null && thatParamType != null) {
            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), tolerateUnknowns);
        } else if (tolerateUnknowns) {
            // If one of the type parameters is unknown, but the other is not,
            // then we consider these the same for the purposes of data flow
            // and invariance.
            paramsMatch = true;
        } else {
            paramsMatch = false;
        }
        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);
    }
    if (isNominalType() && that.isNominalType()) {
        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
    }
    // Unbox other proxies.
    if (this instanceof ProxyObjectType) {
        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, tolerateUnknowns);
    }
    if (that instanceof ProxyObjectType) {
        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);
    }
    // identical, then the type member must be different.
    return this == that;
}",9.561029530738121
64,True,Closure,5,High,155,253,1.2708333333333333,0.9670619235836627,1.25,1.0,1.4,0.41117917304747326,0.9750292625829112,1.2857142857142858,0.0,0.8345115217086605,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically, we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        // 
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target may be using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // Deleting a property has different semantics from deleting
            // a variable, so deleted properties should not be inlined.
            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            // 
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}",9.394329499970327
526,True,Lang,22,Low,581,624,0.4791666666666667,-0.21343873517786552,0.625,0.0,0.5333333333333333,4.452526799387442,0.4639094810768626,-0.5,0.5,3.4074973224612606,"/**
 * <p>Gets the greatest common divisor of the absolute value of
 * two numbers, using the ""binary gcd"" method which avoids
 * division and modulo operations.  See Knuth 4.5.2 algorithm B.
 * This algorithm is due to Josef Stein (1961).</p>
 *
 * @param u  a non-zero number
 * @param v  a non-zero number
 * @return the greatest common divisor, never zero
 */
private static int greatestCommonDivisor(int u, int v) {
    // if either operand is abs 1, return 1:
    if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
        return 1;
    }
    // make u negative
    if (u > 0) {
        u = -u;
    }
    // make v negative
    if (v > 0) {
        v = -v;
    }
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are both even...
        // cast out twos.
        u /= 2;
        // cast out twos.
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}",9.2479948677477
614,True,Math,19,High,504,561,0.9791666666666666,0.6508563899868249,1.625,0.6666666666666666,0.9333333333333333,1.6776416539050538,0.8985563792430736,-0.14285714285714285,0.0,1.8752839368004566,"/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
            // because mixed cases are not supported by the current code.
            throw new MathUnsupportedOperationException();
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
        // Abort early if the normalization will overflow (cf. ""encode"" method).
        }
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}",9.163647883744932
149,True,Closure,68,Medium,1757,1826,1.5208333333333333,1.6521739130434783,1.0,1.0,0.9333333333333333,0.03751914241960185,1.103004291845493,1.4285714285714286,0.0,0.39135505394130504,"/**
 * FunctionType := 'function' FunctionSignatureType
 * FunctionSignatureType :=
 *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token) {
    // just throw out TypeParameters.
    if (token != JsDocToken.LP) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
    }
    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        token = next();
        boolean hasParams = true;
        if (token == JsDocToken.STRING) {
            String tokenStr = stream.getString();
            boolean isThis = ""this"".equals(tokenStr);
            boolean isNew = ""new"".equals(tokenStr);
            if (isThis || isNew) {
                if (match(JsDocToken.COLON)) {
                    next();
                    skipEOLs();
                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));
                    if (contextType == null) {
                        return null;
                    }
                    functionType.addChildToFront(contextType);
                } else {
                    return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
                }
                if (match(JsDocToken.COMMA)) {
                    next();
                    skipEOLs();
                    token = next();
                } else {
                    hasParams = false;
                }
            }
        }
        if (hasParams) {
            parameters = parseParametersType(token);
            if (parameters == null) {
                return null;
            }
        }
    }
    if (parameters != null) {
        functionType.addChildToBack(parameters);
    }
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }
    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
        return null;
    } else {
        functionType.addChildToBack(resultType);
    }
    return functionType;
}",9.066790496487974
707,True,Math,94,Low,411,460,0.4791666666666667,-0.21343873517786552,0.625,0.0,0.3333333333333333,4.452526799387442,0.4678111587982837,-0.5,2.0,3.368664718652468,"/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */
public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}",9.013063941660327
210,True,Closure,115,Medium,689,758,1.0208333333333333,0.8353096179183136,1.0,0.6666666666666666,1.6666666666666667,0.6638591117917304,0.8049161139289894,1.2857142857142858,0.0,1.0315933522143061,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    boolean hasSideEffects = false;
    if (block.hasChildren()) {
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter check if a mutable argument use more than one.
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                // parameter reference will be in a loop.
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            // Move to the next name.
            fnParam = fnParam.getNext();
        }
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}",8.975559148234291
435,True,Compress,37,High,452,502,0.8125,2.9802371541501973,0.875,1.6666666666666667,0.06666666666666667,0.846094946401225,0.6706984003121342,-0.14285714285714285,0.0,1.1072021244838852,"// NOTE, using a Map here makes it impossible to ever support GNU
// sparse files using the PAX Format 0.0, see
// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188
Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {
    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
    // Format is ""length keyword=value\n"";
    while (true) {
        // get length
        int ch;
        int len = 0;
        int read = 0;
        while ((ch = i.read()) != -1) {
            read++;
            if (ch == ' ') {
                // Get keyword
                final ByteArrayOutputStream coll = new ByteArrayOutputStream();
                while ((ch = i.read()) != -1) {
                    read++;
                    if (ch == '=') {
                        // end of keyword
                        final String keyword = coll.toString(CharsetNames.UTF_8);
                        // Get rest of entry
                        final int restLen = len - read;
                        if (restLen == 1) {
                            // only NL
                            headers.remove(keyword);
                        } else {
                            final byte[] rest = new byte[restLen];
                            final int got = IOUtils.readFully(i, rest);
                            if (got != restLen) {
                                throw new IOException(""Failed to read "" + ""Paxheader. Expected "" + restLen + "" bytes, read "" + got);
                            }
                            // Drop trailing NL
                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);
                            headers.put(keyword, value);
                        }
                        break;
                    }
                    coll.write((byte) ch);
                }
                // Processed single header
                break;
            }
            len *= 10;
            len += ch - '0';
        }
        if (ch == -1) {
            // EOF
            break;
        }
    }
    return headers;
}",8.882208815823633
713,True,Math,99,Low,539,592,0.5625,-0.2345191040843214,0.625,0.0,0.4,3.8491577335375187,0.4795161919625448,-0.42857142857142855,0.0,3.477741387740778,"/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}",8.730824780585092
312,True,Closure,162,Medium,297,367,1.1041666666666667,0.6561264822134388,1.0,0.6666666666666666,1.4666666666666666,0.08039816232771828,0.712836519703472,2.0,0.0,0.7741687325532005,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    // Validate the top level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        int type = n.getType();
        if (type == Token.NAME && parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = t.getScope().getVar(name);
                aliases.put(name, aliasVar);
                aliasDefinitionsInOrder.add(n);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (n.getType() == Token.NAME) {
            String name = n.getString();
            Var aliasVar = aliases.get(name);
            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {
                // Note, to support the transitive case, it's important we don't
                // clone aliasedNode here.  For example,
                // var g = goog; var d = g.dom; d.createElement('DIV');
                // The node in aliasedNode (which is ""g"") will be replaced in the
                // changes pass above with ""goog"".  If we cloned here, we'd end up
                // with <code>g.dom.createElement('DIV')</code>.
                Node aliasedNode = aliasVar.getInitialValue();
                aliasUsages.add(new AliasedNode(n, aliasedNode));
            }
        }
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}",8.461029896797829
640,True,Math,44,High,274,374,1.8958333333333333,-0.2187088274044796,0.875,0.0,0.4666666666666667,0.6194486983154672,1.0530628170113154,1.8571428571428572,0.0,1.8652542672103418,"/**
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an event
 * asks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MathIllegalStateException if the value of one event state cannot be evaluated
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {
    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;
    // initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }
    // search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

        /**
         * {@inheritDoc}
         */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });
    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(state);
        }
    }
    while (!occuringEvents.isEmpty()) {
        // handle the chronologically first event
        final Iterator<EventState> iterator = occuringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();
        // restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);
        // trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();
        // handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }
        if (isLastStep) {
            // the event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }
        if (currentEvent.reset(eventT, eventY)) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }
        // prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);
        // check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(currentEvent);
        }
    }
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);
    // handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }
    return currentT;
}",8.413699812275501
186,True,Closure,97,High,652,713,0.8958333333333334,0.3188405797101449,1.0,0.3333333333333333,0.5333333333333333,1.862940275650842,0.7565353101833785,0.42857142857142855,0.0,2.0144453348769082,"/**
 * Try to fold shift operations
 */
private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        // a 32-bit range, since the user likely does not intend that.
        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }
        // if the shift amount is outside [0,32)
        if (!(rval >= 0 && rval < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }
        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if (lvalInt != lval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, right);
            return n;
        }
        switch(n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                // JavaScript handles zero shifts on signed numbers differently than
                // Java as an Java int can not represent the unsigned 32-bit number
                // where JavaScript can so use a long here.
                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }
        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();
        return newNumber;
    }
    return n;
}",8.143832928992703
252,True,Closure,143,Medium,847,895,0.5625,1.9631093544137022,1.125,1.6666666666666667,0.4,0.5168453292496171,0.5700351150994935,0.6428571428571429,0.0,0.638045979840086,"/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */
@VisibleForTesting
static void createDefineReplacements(List<String> definitions, CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            if (assignment.length == 1) {
                options.setDefineToBooleanLiteral(defName, true);
                continue;
            } else {
                String defValue = assignment[1];
                if (defValue.equals(""true"")) {
                    options.setDefineToBooleanLiteral(defName, true);
                    continue;
                } else if (defValue.equals(""false"")) {
                    options.setDefineToBooleanLiteral(defName, false);
                    continue;
                } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\''))) {
                    // If the value starts and ends with a single quote,
                    // we assume that it's a string.
                    String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                    if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                        continue;
                    }
                } else {
                    try {
                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));
                        continue;
                    } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                    }
                }
            }
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}",8.08505958812671
321,True,Closure,163,High,96,196,1.0208333333333333,0.75098814229249,1.125,0.6666666666666666,0.8666666666666667,-0.052833078101071934,0.6777214202106909,2.4285714285714284,0.0,0.5822675784029352,"/**
 * Move methods deeper in the module graph when possible.
 */
private void moveMethods(Collection<NameInfo> allNameInfo) {
    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();
    for (NameInfo nameInfo : allNameInfo) {
        if (!nameInfo.isReferenced()) {
            // deepestCommonModuleRef is null.
            continue;
        }
        if (nameInfo.readsClosureVariables()) {
            continue;
        }
        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();
        if (deepestCommonModuleRef == null) {
            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));
            continue;
        }
        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();
        while (declarations.hasNext()) {
            Symbol symbol = declarations.next();
            if (!(symbol instanceof Property)) {
                continue;
            }
            Property prop = (Property) symbol;
            // We should only move a property across modules if:
            // 1) We can move it deeper in the module graph, and
            // 2) it's a function, and
            // 3) it is not a get or a set, and
            // 4) the class is available in the global scope.
            // 
            // #1 should be obvious. #2 is more subtle. It's possible
            // to copy off of a prototype, as in the code:
            // for (var k in Foo.prototype) {
            // doSomethingWith(Foo.prototype[k]);
            // }
            // This is a common way to implement pseudo-multiple inheritance in JS.
            // 
            // So if we move a prototype method into a deeper module, we must
            // replace it with a stub function so that it preserves its original
            // behavior.
            Node value = prop.getValue();
            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {
                Node valueParent = value.getParent();
                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {
                    // of a GET instead of the function itself.
                    continue;
                }
                Node proto = prop.getPrototype();
                int stubId = idGenerator.newId();
                // example: JSCompiler_stubMethod(id);
                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);
                stubCall.putBooleanProp(Node.FREE_CALL, true);
                // stub out the method in the original module
                // A.prototype.b = JSCompiler_stubMethod(id);
                valueParent.replaceChild(value, stubCall);
                // unstub the function body in the deeper module
                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);
                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);
                unstubCall.putBooleanProp(Node.FREE_CALL, true);
                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);
                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));
                compiler.reportCodeChange();
            }
        }
    }
    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {
        // Declare stub functions in the top-most module.
        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);
        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());
    }
}",8.065882158043138
350,True,Closure,171,Medium,719,773,0.7291666666666666,0.956521739130435,0.75,0.6666666666666666,1.0,0.6071975497702911,0.4319157237612171,1.3571428571428572,0.0,1.4556619913612598,"private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
    JSType type = n.getJSType();
    Preconditions.checkNotNull(type);
    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
        scope = traverse(name.getFirstChild(), scope);
    }
    // Object literals can be reflected on other types.
    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.
    // Ignore these types of literals.
    ObjectType objectType = ObjectType.cast(type);
    if (objectType == null) {
        return scope;
    }
    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;
    if (objectType.hasReferenceName() && !hasLendsName) {
        return scope;
    }
    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
        String memberName = NodeUtil.getObjectLitKeyName(name);
        if (memberName != null) {
            JSType rawValueType = name.getFirstChild().getJSType();
            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);
            if (valueType == null) {
                valueType = unknownType;
            }
            objectType.defineInferredProperty(memberName, valueType, name);
            // Do normal flow inference if this is a direct property assignment.
            if (qObjName != null && name.isStringKey()) {
                String qKeyName = qObjName + ""."" + memberName;
                Var var = syntacticScope.getVar(qKeyName);
                JSType oldType = var == null ? null : var.getType();
                if (var != null && var.isTypeInferred()) {
                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));
                }
                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);
            }
        } else {
            n.setJSType(unknownType);
        }
    }
    return scope;
}",7.954273194499394
138,True,Closure,61,Medium,926,976,0.4375,0.6877470355731224,0.875,1.0,1.7333333333333334,0.501531393568147,0.38041357783847063,1.5,0.0,0.7250689312420893,"/**
 * Returns true if calls to this function have side effects.
 *
 * @param callNode The call node to inspected.
 * @param compiler A compiler object to provide program state changing
 *     context information. Can be null.
 */
static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
        throw new IllegalStateException(""Expected CALL node, got "" + Token.name(callNode.getType()));
    }
    if (callNode.isNoSideEffectsCall()) {
        return false;
    }
    Node nameNode = callNode.getFirstChild();
    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
        String name = nameNode.getString();
        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }
    } else if (nameNode.getType() == Token.GETPROP) {
        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {
            return false;
        }
        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {
            return false;
        }
        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                return false;
            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                Node param = nameNode.getNext();
                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))
                    return false;
            }
        }
    }
    return true;
}",7.840594271555163
1,True,Chart,2,Low,740,785,0.8958333333333334,1.3148880105401846,0.75,0.6666666666666666,0.8666666666666667,0.8721286370597242,0.6730394069449864,0.2857142857142857,0.0,1.2844321852460931,"/**
 * Iterates over the items in an {@link XYDataset} to find
 * the range of x-values.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the x-interval or just the
 *          x-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 */
public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {
    if (dataset == null) {
        throw new IllegalArgumentException(""Null 'dataset' argument."");
    }
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    double lvalue;
    double uvalue;
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = intervalXYData.getStartXValue(series, item);
                uvalue = intervalXYData.getEndXValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = dataset.getXValue(series, item);
                uvalue = lvalue;
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    }
    if (minimum > maximum) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}",7.609369192171941
202,True,Closure,108,Medium,522,589,1.0208333333333333,0.41897233201581024,1.125,0.6666666666666666,1.0666666666666667,0.3529862174578868,0.8025751072961372,1.0714285714285714,0.0,0.7726815082380459,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
    // Validate the top-level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
            // Note, to support the transitive case, it's important we don't
            // clone aliasedNode here.  For example,
            // var g = goog; var d = g.dom; d.createElement('DIV');
            // The node in aliasedNode (which is ""g"") will be replaced in the
            // changes pass above with ""goog"".  If we cloned here, we'd end up
            // with <code>g.dom.createElement('DIV')</code>.
            aliasUsages.add(new AliasedNode(aliasVar, n));
        }
        // When we inject declarations, we duplicate jsdoc. Make sure
        // we only process that jsdoc once.
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}",7.297810403103117
92,True,Closure,29,High,155,240,0.8541666666666666,0.9354413702239791,1.0,1.0,1.0,0.42496171516079634,0.7900897385875928,0.7142857142857143,0.0,0.5479351655794237,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        // 
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // isn't a perfect algorithm, but it should catch most cases.
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}",7.266880370504173
172,True,Closure,85,High,130,192,0.8958333333333334,1.0671936758893283,1.0,0.6666666666666666,0.9333333333333333,0.08499234303215936,0.7378072571205607,1.4285714285714286,0.0,0.41473122432799403,"/**
 * Tries to remove n if an unconditional branch node (break, continue or
 * return) if the target of n is the same as the the follow of n. That is, if
 * we remove n, the control flow remains the same. Also if n targets to
 * another unconditional branch, this function will recursively try to remove
 * the target branch as well. The reason why we want to cascade this removal
 * is because we only run this pass once. If we have code such as
 *
 * break -> break -> break
 *
 * where all 3 break's are useless. The order of removal matters. When we
 * first look at the first break, we see that it branches to the 2nd break.
 * However, if we remove the last break, the 2nd break becomes useless and
 * finally the first break becomes useless as well.
 *
 * @return The target of this jump. If the target is also useless jump,
 *     the target of that useless jump recursively.
 */
@SuppressWarnings(""fallthrough"")
private Node tryRemoveUnconditionalBranching(Node n) {
    // If n is null the target is the end of the function, nothing to do.
    if (n == null) {
        return n;
    }
    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);
    if (gNode == null) {
        return n;
    }
    if (n.getParent() == null) {
        List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();
        if (outEdges.size() == 1) {
            return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
        }
    }
    switch(n.getType()) {
        case Token.BLOCK:
            if (n.hasChildren()) {
                Node first = n.getFirstChild();
                return tryRemoveUnconditionalBranching(first);
            } else {
                return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
            }
        case Token.RETURN:
            if (n.hasChildren()) {
                break;
            }
        case Token.BREAK:
        case Token.CONTINUE:
            // We are looking for a control flow changing statement that always
            // branches to the same node. If removing it the control flow still
            // branches to that same node. It is safe to remove it.
            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();
            if (outEdges.size() == 1 && // If there is a next node, there is no chance this jump is useless.
            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
                Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
                Node nextCfgNode = outEdges.get(0).getDestination().getValue();
                if (nextCfgNode == fallThrough) {
                    removeDeadExprStatementSafely(n);
                    return fallThrough;
                }
            }
    }
    return n;
}",7.229129262274804
184,True,Closure,95,Medium,872,945,0.7708333333333334,0.5191040843214758,0.375,0.3333333333333333,0.6,0.4785604900459418,0.31252438548575856,2.0714285714285716,0.0,1.7100693645700376,"/**
 * Defines a typed variable. The defining node will be annotated with the
 * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is
 * inferred.
 *
 * Slots may be any variable or any qualified name in the global scope.
 *
 * @param n the defining NAME or GETPROP node.
 * @param parent the {@code n}'s parent.
 * @param type the variable's type. It may be {@code null} if
 *     {@code inferred} is {@code true}.
 */
void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);
    // Only allow declarations of NAMEs and qualfied names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(!variableName.isEmpty());
    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = scope;
    // declared in closest scope?
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);
        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */
                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",7.170853562518452
111,True,Closure,41,Medium,421,494,1.2708333333333333,0.05533596837944663,0.875,0.3333333333333333,0.9333333333333333,0.4188361408882083,0.800234100663285,1.2142857142857142,0.0,1.2467979204538282,"/**
 * Infer the parameter types from the list of argument names and
 * the doc info.
 */
FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {
    if (argsParent == null) {
        if (info == null) {
            return this;
        } else {
            return inferParameterTypes(info);
        }
    }
    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
        oldParameterType = parametersNode.getFirstChild();
    }
    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;
    boolean isVarArgs = false;
    for (Node arg : argsParent.children()) {
        String argumentName = arg.getString();
        allJsDocParams.remove(argumentName);
        // type from JSDocInfo
        JSType parameterType = null;
        boolean isOptionalParam = isOptionalParameter(arg, info);
        isVarArgs = isVarArgsParameter(arg, info);
        if (info != null && info.hasParameterType(argumentName)) {
            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);
        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {
            parameterType = oldParameterType.getJSType();
            isOptionalParam = oldParameterType.isOptionalArg();
            isVarArgs = oldParameterType.isVarArgs();
        } else {
            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
        }
        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
            if (foundTemplateType) {
                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
            }
            foundTemplateType = true;
        }
        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);
        if (oldParameterType != null) {
            oldParameterType = oldParameterType.getNext();
        }
    }
    if (templateTypeName != null && !foundTemplateType) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    for (String inexistentName : allJsDocParams) {
        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }
    parametersNode = builder.build();
    return this;
}",7.147989844670482
406,True,Compress,14,High,56,112,0.9375,-0.18708827404479578,1.25,0.0,0.6666666666666666,2.017611026033691,0.8252048380803738,-0.5,0.0,2.1345617021549774,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}",7.144455958890912
166,True,Closure,80,High,2864,2927,0.8958333333333334,0.050065876152832776,2.125,0.3333333333333333,1.2,-0.2457886676875957,0.8712446351931326,1.7142857142857142,0.0,0.12672970072553014,"/**
 * @param locals A predicate to apply to unknown local values.
 * @return Whether the node is known to be a value that is not a reference
 *     outside the expression scope.
 */
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch(value.getType()) {
        case Token.ASSIGN:
            // value is immutable.
            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // There is no information about the locality of object properties.
            return locals.apply(value);
        case Token.CALL:
            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
        case Token.NEW:
            return newHasLocalResult(value) || locals.apply(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // Literals objects with non-literal children are allowed.
            return true;
        case Token.IN:
            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
            return true;
        default:
            // x -= g (x is now an local number)
            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(""Unexpected expression node"" + value + ""\n parent:"" + value.getParent());
    }
}",7.0707039253362804
116,True,Closure,45,High,704,749,0.5208333333333334,1.5783926218708828,0.375,1.3333333333333333,0.8,0.7098009188361409,0.44674209910261375,0.5,0.0,0.7369603060900232,"/**
 * Look at all the property assigns to all variables.
 * These may or may not count as references. For example,
 *
 * <code>
 * var x = {};
 * x.foo = 3; // not a reference.
 * var y = foo();
 * y.foo = 3; // is a reference.
 * </code>
 *
 * Interpreting assignments could mark a variable as referenced that
 * wasn't referenced before, in order to keep it alive. Because we find
 * references by lazily traversing subtrees, marking a variable as
 * referenced could trigger new traversals of new subtrees, which could
 * find new references.
 *
 * Therefore, this interpretation needs to be run to a fixed point.
 */
private void interpretAssigns() {
    boolean changes = false;
    do {
        changes = false;
        // we traverse it.
        for (int current = 0; current < maybeUnreferenced.size(); current++) {
            Var var = maybeUnreferenced.get(current);
            if (referenced.contains(var)) {
                maybeUnreferenced.remove(current);
                current--;
            } else {
                boolean assignedToUnknownValue = false;
                boolean hasPropertyAssign = false;
                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {
                    Node value = var.getInitialValue();
                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);
                } else {
                    // This was initialized to a function arg or a catch param
                    // or a for...in variable.
                    assignedToUnknownValue = true;
                }
                for (Assign assign : assignsByVar.get(var)) {
                    if (assign.isPropertyAssign) {
                        hasPropertyAssign = true;
                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {
                        assignedToUnknownValue = true;
                    }
                }
                if (assignedToUnknownValue && hasPropertyAssign) {
                    changes = markReferencedVar(var) || changes;
                    maybeUnreferenced.remove(current);
                    current--;
                }
            }
        }
    } while (changes);
}",7.0010626125663284
568,True,Lang,48,Low,367,409,0.6875,-0.5665349143610015,1.0,2.6666666666666665,0.6666666666666666,0.7511485451761103,0.8665626219274282,0.5,0.0,0.3631320302109826,"// -------------------------------------------------------------------------
/**
 * <p>Test if two <code>Object</code>s are equal using their
 * <code>equals</code> method.</p>
 *
 * @param lhs  the left hand object
 * @param rhs  the right hand object
 * @return EqualsBuilder - used to chain calls.
 */
public EqualsBuilder append(Object lhs, Object rhs) {
    if (isEquals == false) {
        return this;
    }
    if (lhs == rhs) {
        return this;
    }
    if (lhs == null || rhs == null) {
        this.setEquals(false);
        return this;
    }
    Class lhsClass = lhs.getClass();
    if (!lhsClass.isArray()) {
        // The simple case, not an array, just test the element
        isEquals = lhs.equals(rhs);
    } else if (lhs.getClass() != rhs.getClass()) {
        // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]
        this.setEquals(false);
    } else // This handles multi dimensional arrays of the same depth
    if (lhs instanceof long[]) {
        append((long[]) lhs, (long[]) rhs);
    } else if (lhs instanceof int[]) {
        append((int[]) lhs, (int[]) rhs);
    } else if (lhs instanceof short[]) {
        append((short[]) lhs, (short[]) rhs);
    } else if (lhs instanceof char[]) {
        append((char[]) lhs, (char[]) rhs);
    } else if (lhs instanceof byte[]) {
        append((byte[]) lhs, (byte[]) rhs);
    } else if (lhs instanceof double[]) {
        append((double[]) lhs, (double[]) rhs);
    } else if (lhs instanceof float[]) {
        append((float[]) lhs, (float[]) rhs);
    } else if (lhs instanceof boolean[]) {
        append((boolean[]) lhs, (boolean[]) rhs);
    } else {
        // Not an array of primitives
        append((Object[]) lhs, (Object[]) rhs);
    }
    return this;
}",6.935141616286852
212,True,Closure,117,Medium,724,777,0.6041666666666666,0.75098814229249,0.625,0.6666666666666666,1.3333333333333333,0.5719754977029097,0.5239953179867347,1.1428571428571428,0.0,0.707072447083168,"/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */
String getReadableJSTypeName(Node n, boolean dereference) {
    // the property was originally defined.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}",6.926055214589112
174,True,Closure,86,Critical,2424,2489,0.8958333333333334,0.050065876152832776,2.125,0.3333333333333333,1.2,-0.2503828483920367,0.8884120171673814,1.5714285714285714,0.0,0.10342842652737405,"/**
 * @param locals A predicate to apply to unknown local values.
 * @return Whether the node is known to be a value that is not a reference
 *     outside the expression scope.
 */
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch(value.getType()) {
        case Token.ASSIGN:
            // value is immutable.
            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // There is no information about the locality of object properties.
            return locals.apply(value);
        case Token.CALL:
            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
        case Token.NEW:
            // the constructor (similar to callHasLocalResult)
            return true;
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // Literals objects with non-literal children are allowed.
            return true;
        case Token.IN:
            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
            return true;
        default:
            // x -= g (x is now an local number)
            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(""Unexpected expression node"" + value + ""\n parent:"" + value.getParent());
    }
}",6.91711870955079
512,True,Lang,10,High,303,343,0.8125,0.9196310935441371,2.125,1.0,1.0666666666666667,-0.10949464012251146,1.0686695278969953,-0.07142857142857142,0.0,-0.008622691191245245,"// Support for strategies
// -----------------------------------------------------------------------
/**
 * Escape constant fields into regular expression
 * @param regex The destination regex
 * @param value The source field
 * @param unquote If true, replace two success quotes ('') with single quote (')
 * @return The <code>StringBuilder</code>
 */
private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        switch(c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        return regex;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}",6.802921385365471
370,True,Codec,8,High,138,182,0.3125,1.3306982872200266,0.875,1.6666666666666667,0.6666666666666666,1.0329249617151608,0.41786968396410384,-0.21428571428571427,0.0,0.696768871432133,"/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */
public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}",6.784809423379044
181,True,Closure,91,Medium,82,146,0.4791666666666667,0.924901185770751,0.5,0.6666666666666666,1.8666666666666667,0.4356814701378254,0.3211080764728841,0.7857142857142857,0.0,0.7818744804076923,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys
        pType == Token.STRING || pType == Token.NUMBER)) {
            return false;
        }
    // Don't traverse functions that are getting lent to a prototype.
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}",6.761779498503438
333,True,Closure,168,Medium,1987,2038,0.6458333333333334,0.4664031620553359,0.625,0.6666666666666666,1.4,0.12940275650842262,0.48341786968396366,1.8571428571428572,0.0,0.478273150679362,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (t.inGlobalScope()) {
        return;
    }
    if (n.isReturn() && n.getFirstChild() != null) {
        data.get(t.getScopeRoot()).recordNonEmptyReturn();
    }
    if (t.getScopeDepth() <= 2) {
        // no reason to do this extra computation for them.
        return;
    }
    if (n.isName() && NodeUtil.isLValue(n) && // in the inner scope, not the scope where the name appears.
    !NodeUtil.isBleedingFunctionName(n)) {
        String name = n.getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordAssignedName(name);
            }
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
            }
        }
    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {
        String name = NodeUtil.getRootOfQualifiedName(n).getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());
            }
        }
    }
}",6.752139796069941
140,True,Closure,64,Medium,1393,1452,0.6041666666666666,0.735177865612648,0.25,0.3333333333333333,0.5333333333333333,0.7373660030627872,0.28365197034724865,1.7142857142857142,0.0,1.5193408707430882,"/**
 * Writes out js code from a root node. If printing input delimiters, this
 * method will attach a comment to the start of the text indicating which
 * input the output derived from. If there were any preserve annotations
 * within the root's source, they will also be printed in a block comment
 * at the beginning of the output.
 */
public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
    runInCompilerThread(new Callable<Void>() {

        public Void call() throws Exception {
            if (options.printInputDelimiter) {
                if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
                    // Make sure that the label starts on a new line
                    cb.append(""\n"");
                }
                Preconditions.checkState(root.getType() == Token.SCRIPT);
                String delimiter = options.inputDelimiter;
                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
                Preconditions.checkState(sourceName != null);
                Preconditions.checkState(!sourceName.isEmpty());
                delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
                cb.append(delimiter).append(""\n"");
            }
            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
                cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
            }
            // root node's mappings are offset by the given string builder buffer.
            if (options.sourceMapOutputPath != null) {
                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
            }
            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
            // for the first input file
            String code = toSource(root, sourceMap);
            if (!code.isEmpty()) {
                cb.append(code);
                // In order to avoid parse ambiguity when files are concatenated
                // together, all files should end in a semi-colon. Do a quick
                // heuristic check if there's an obvious semi-colon already there.
                int length = code.length();
                char lastChar = code.charAt(length - 1);
                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
                boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
                if (!hasSemiColon) {
                    cb.append("";"");
                }
            }
            return null;
        }
    });
}",6.710655757384819
575,True,Lang,54,High,94,127,0.5208333333333334,0.13965744400527016,1.0,0.3333333333333333,0.9333333333333333,1.3637059724349159,0.4326960593055005,0.21428571428571427,0.0,1.6876390260499645,"// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a Locale.</p>
 *
 * <p>This method takes the string format of a locale and creates the
 * locale object from it.</p>
 *
 * <pre>
 *   LocaleUtils.toLocale(""en"")         = new Locale(""en"", """")
 *   LocaleUtils.toLocale(""en_GB"")      = new Locale(""en"", ""GB"")
 *   LocaleUtils.toLocale(""en_GB_xxx"")  = new Locale(""en"", ""GB"", ""xxx"")   (#)
 * </pre>
 *
 * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.
 * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.
 * Thus, the result from getVariant() may vary depending on your JDK.</p>
 *
 * <p>This method validates the input strictly.
 * The language code must be lowercase.
 * The country code must be uppercase.
 * The separator must be an underscore.
 * The length must be correct.
 * </p>
 *
 * @param str  the locale String to convert, null returns null
 * @return a Locale, null if null input
 * @throws IllegalArgumentException if the string is an invalid format
 */
public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len != 2 && len != 5 && len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str, """");
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = str.charAt(3);
        char ch4 = str.charAt(4);
        if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 5) {
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
    }
}",6.625484216081365
731,True,Time,24,Medium,331,378,0.8958333333333334,0.07114624505928843,0.75,0.3333333333333333,0.8,1.0099540581929556,0.6363636363636366,0.5,0.0,1.5896106147158175,"/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */
public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}",6.586241220998365
139,True,Closure,62,Medium,66,111,0.5208333333333334,0.9934123847167324,0.375,0.6666666666666666,0.7333333333333333,0.8537519142419602,0.3546625048770962,0.9285714285714286,0.0,1.1425595451447477,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);
    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
        b.append(error.sourceName);
        if (error.lineNumber > 0) {
            b.append(':');
            b.append(error.lineNumber);
        }
        b.append("": "");
    }
    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");
    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
        b.append(sourceExcerpt);
        b.append('\n');
        int charno = error.getCharno();
        // at the end of the line
        if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
            for (int i = 0; i < charno; i++) {
                char c = sourceExcerpt.charAt(i);
                if (Character.isWhitespace(c)) {
                    b.append(c);
                } else {
                    b.append(' ');
                }
            }
            b.append(""^\n"");
        }
    }
    return b.toString();
}",6.568791110885298
260,True,Closure,147,Medium,84,142,0.4375,0.956521739130435,0.5,0.6666666666666666,1.7333333333333334,0.42189892802450224,0.3195474053843152,0.7857142857142857,0.0,0.67158877284735,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}",6.492771131100888
422,True,Compress,24,Critical,102,153,0.6458333333333334,-0.26086956521739135,0.875,0.0,0.4666666666666667,2.3851454823889737,0.5793991416309,-0.5,0.0,2.2918800762229212,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    trailer = buffer[end - 1];
    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}",6.4830551350254035
344,True,Closure,169,Medium,153,213,0.6041666666666666,0.7140974967061926,0.5,0.6666666666666666,1.0666666666666667,0.0758039816232772,0.352321498244244,1.8571428571428572,0.0,0.5845080443856214,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",6.421373878102193
628,True,Math,33,High,327,367,0.4791666666666667,0.08695652173913046,0.5,0.3333333333333333,0.8,1.371362940275651,0.33827545844713297,0.8571428571428571,0.0,1.6198365765166216,"/**
 * Removes the phase 1 objective function, positive cost non-artificial variables,
 * and the non-basic artificial variables from this tableau.
 */
protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }
    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);
    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }
    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }
    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }
    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",6.386074354121393
408,True,Compress,16,Low,197,258,1.1041666666666667,0.11857707509881428,1.25,1.0,0.7333333333333333,0.19984686064318538,0.9547405384315246,0.5714285714285714,0.0,0.4432046153171265,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = in.read(signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            return new ZipArchiveInputStream(in);
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            return new JarArchiveInputStream(in);
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            return new CpioArchiveInputStream(in);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = in.read(dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = in.read(tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in);
        }
        // COMPRESS-117 - improve auto-recognition
        if (signatureLength >= 512) {
            try {
                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                // COMPRESS-191 - verify the header checksum
                tais.getNextEntry();
                return new TarArchiveInputStream(in);
            } catch (Exception e) {
            // NOPMD
            // can generate IllegalArgumentException as well
            // as IOException
            // autodetection, simply not a TAR
            // ignored
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}",6.375297660919222
506,True,Lang,5,High,88,128,0.8125,-0.6877470355731227,1.625,-0.3333333333333333,1.0,1.0972434915773353,0.7502926258291074,0.6428571428571429,0.0,1.4629033828468472,"// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a Locale.</p>
 *
 * <p>This method takes the string format of a locale and creates the
 * locale object from it.</p>
 *
 * <pre>
 *   LocaleUtils.toLocale(""en"")         = new Locale(""en"", """")
 *   LocaleUtils.toLocale(""en_GB"")      = new Locale(""en"", ""GB"")
 *   LocaleUtils.toLocale(""en_GB_xxx"")  = new Locale(""en"", ""GB"", ""xxx"")   (#)
 * </pre>
 *
 * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.
 * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.
 * Thus, the result from getVariant() may vary depending on your JDK.</p>
 *
 * <p>This method validates the input strictly.
 * The language code must be lowercase.
 * The country code must be uppercase.
 * The separator must be an underscore.
 * The length must be correct.
 * </p>
 *
 * @param str  the locale String to convert, null returns null
 * @return a Locale, null if null input
 * @throws IllegalArgumentException if the string is an invalid format
 */
public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",6.369716274203976
324,True,Closure,165,Medium,148,207,0.5625,0.7457180500658762,0.5,0.6666666666666666,1.0666666666666667,0.1033690658499234,0.33047210300429075,1.7857142857142858,0.0,0.5859760096808675,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",6.3470828476485766
404,True,Compress,12,High,172,238,1.1041666666666667,-0.018445322793148956,0.875,0.3333333333333333,0.7333333333333333,0.7572741194486982,0.8930940304330859,0.7142857142857143,0.0,0.9506605308855834,"/**
 * Get the next entry in this tar archive. This will skip
 * over any remaining data in the current entry, if there
 * is one, and place the input stream at the header of the
 * next entry, and read the header and instantiate a new
 * TarEntry from the header bytes and return that entry.
 * If there are no more entries in the archive, null will
 * be returned to indicate that the end of the archive has
 * been reached.
 *
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */
public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }
    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;
        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip current tar entry"");
            }
            numToSkip -= skipped;
        }
        readBuf = null;
    }
    byte[] headerBuf = getRecord();
    if (hasHitEOF) {
        currEntry = null;
        return null;
    }
    currEntry = new TarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();
    if (currEntry.isGNULongNameEntry()) {
        // read in the name
        StringBuffer longName = new StringBuffer();
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length = 0;
        while ((length = read(buf)) >= 0) {
            longName.append(new String(buf, 0, length));
        }
        getNextEntry();
        if (currEntry == null) {
            // Malformed tar file - long entry name not followed by entry
            return null;
        }
        // remove trailing null terminator
        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }
    if (currEntry.isPaxHeader()) {
        // Process Pax headers
        paxHeaders();
    }
    if (currEntry.isGNUSparse()) {
        // Process sparse files
        readGNUSparse();
    }
    // If the size of the next element in the archive has changed
    // due to a new size being reported in the posix header
    // information, we update entrySize here so that it contains
    // the correct value.
    entrySize = currEntry.getSize();
    return currEntry;
}",6.342702405593267
361,True,Codec,1,High,50,140,1.8125,-1.3254281949934126,-0.5,-0.3333333333333333,-0.4,0.18453292496171517,0.5177526336324614,3.642857142857143,0.0,2.723014635785185,"/**
 * Find the caverphone value of a String.
 *
 * @param txt String to find the caverphone code for
 * @return A caverphone code corresponding to the String supplied
 */
public String caverphone(String txt) {
    if (txt == null || txt.length() == 0) {
        return ""1111111111"";
    }
    // 1. Convert to lowercase
    txt = txt.toLowerCase();
    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");
    // 2.5. Remove final e
    // 2.0 only
    txt = txt.replaceAll(""e$"", """");
    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    // 2.0 only
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    // 2.0 only - note the spec says ^enough here again, c+p error I assume
    txt = txt.replaceAll(""^trough"", ""trou2f"");
    txt = txt.replaceAll(""^gn"", ""2n"");
    txt = txt.replaceAll(""^mb"", ""m2"");
    // 4. Handle replacements
    txt = txt.replaceAll(""cq"", ""2q"");
    txt = txt.replaceAll(""ci"", ""si"");
    txt = txt.replaceAll(""ce"", ""se"");
    txt = txt.replaceAll(""cy"", ""sy"");
    txt = txt.replaceAll(""tch"", ""2ch"");
    txt = txt.replaceAll(""c"", ""k"");
    txt = txt.replaceAll(""q"", ""k"");
    txt = txt.replaceAll(""x"", ""k"");
    txt = txt.replaceAll(""v"", ""f"");
    txt = txt.replaceAll(""dg"", ""2g"");
    txt = txt.replaceAll(""tio"", ""sio"");
    txt = txt.replaceAll(""tia"", ""sia"");
    txt = txt.replaceAll(""d"", ""t"");
    txt = txt.replaceAll(""ph"", ""fh"");
    txt = txt.replaceAll(""b"", ""p"");
    txt = txt.replaceAll(""sh"", ""s2"");
    txt = txt.replaceAll(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    // 2.0 only
    txt = txt.replaceAll(""j"", ""y"");
    // 2.0 only
    txt = txt.replaceAll(""^y3"", ""Y3"");
    // 2.0 only
    txt = txt.replaceAll(""^y"", ""A"");
    // 2.0 only
    txt = txt.replaceAll(""y"", ""3"");
    txt = txt.replaceAll(""3gh3"", ""3kh3"");
    txt = txt.replaceAll(""gh"", ""22"");
    txt = txt.replaceAll(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replaceAll(""w3"", ""W3"");
    // txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
    txt = txt.replaceAll(""wh3"", ""Wh3"");
    // 2.0 only
    txt = txt.replaceAll(""w$"", ""3"");
    // txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
    txt = txt.replaceAll(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replaceAll(""h"", ""2"");
    txt = txt.replaceAll(""r3"", ""R3"");
    // 2.0 only
    txt = txt.replaceAll(""r$"", ""3"");
    // txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
    txt = txt.replaceAll(""r"", ""2"");
    txt = txt.replaceAll(""l3"", ""L3"");
    // 2.0 only
    txt = txt.replaceAll(""l$"", ""3"");
    // txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
    txt = txt.replaceAll(""l"", ""2"");
    // txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
    // txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
    // txt = txt.replaceAll(""y"", ""2"");      // 1.0 only
    // 5. Handle removals
    txt = txt.replaceAll(""2"", """");
    // 2.0 only
    txt = txt.replaceAll(""3$"", ""A"");
    txt = txt.replaceAll(""3"", """");
    // 6. put ten 1s on the end
    // 1.0 only has 6 1s
    txt = txt + ""111111"" + ""1111"";
    // 1.0 truncates to 6
    return txt.substring(0, 10);
}",6.321895808909758
372,True,Codec,10,High,50,142,1.8125,-1.3254281949934126,-0.5,-0.3333333333333333,-0.4,0.164624808575804,0.5107296137339047,3.642857142857143,0.0,2.707812849404094,"/**
 * Encodes the given String into a Caverphone value.
 *
 * @param txt String the source string
 * @return A caverphone code for the given String
 */
public String caverphone(String txt) {
    if (txt == null || txt.length() == 0) {
        return ""1111111111"";
    }
    // 1. Convert to lowercase
    txt = txt.toLowerCase(java.util.Locale.ENGLISH);
    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");
    // 2.5. Remove final e
    // 2.0 only
    txt = txt.replaceAll(""e$"", """");
    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    // 2.0 only
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    // 2.0 only - note the spec says ^enough here again, c+p error I assume
    txt = txt.replaceAll(""^trough"", ""trou2f"");
    txt = txt.replaceAll(""^gn"", ""2n"");
    // End
    txt = txt.replaceAll(""^mb"", ""m2"");
    // 4. Handle replacements
    txt = txt.replaceAll(""cq"", ""2q"");
    txt = txt.replaceAll(""ci"", ""si"");
    txt = txt.replaceAll(""ce"", ""se"");
    txt = txt.replaceAll(""cy"", ""sy"");
    txt = txt.replaceAll(""tch"", ""2ch"");
    txt = txt.replaceAll(""c"", ""k"");
    txt = txt.replaceAll(""q"", ""k"");
    txt = txt.replaceAll(""x"", ""k"");
    txt = txt.replaceAll(""v"", ""f"");
    txt = txt.replaceAll(""dg"", ""2g"");
    txt = txt.replaceAll(""tio"", ""sio"");
    txt = txt.replaceAll(""tia"", ""sia"");
    txt = txt.replaceAll(""d"", ""t"");
    txt = txt.replaceAll(""ph"", ""fh"");
    txt = txt.replaceAll(""b"", ""p"");
    txt = txt.replaceAll(""sh"", ""s2"");
    txt = txt.replaceAll(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    // 2.0 only
    txt = txt.replaceAll(""j"", ""y"");
    // 2.0 only
    txt = txt.replaceAll(""^y3"", ""Y3"");
    // 2.0 only
    txt = txt.replaceAll(""^y"", ""A"");
    // 2.0 only
    txt = txt.replaceAll(""y"", ""3"");
    txt = txt.replaceAll(""3gh3"", ""3kh3"");
    txt = txt.replaceAll(""gh"", ""22"");
    txt = txt.replaceAll(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replaceAll(""w3"", ""W3"");
    // txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
    txt = txt.replaceAll(""wh3"", ""Wh3"");
    // 2.0 only
    txt = txt.replaceAll(""w$"", ""3"");
    // txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
    txt = txt.replaceAll(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replaceAll(""h"", ""2"");
    txt = txt.replaceAll(""r3"", ""R3"");
    // 2.0 only
    txt = txt.replaceAll(""r$"", ""3"");
    // txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
    txt = txt.replaceAll(""r"", ""2"");
    txt = txt.replaceAll(""l3"", ""L3"");
    // 2.0 only
    txt = txt.replaceAll(""l$"", ""3"");
    // txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
    txt = txt.replaceAll(""l"", ""2"");
    // txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
    // txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
    // txt = txt.replaceAll(""y"", ""2"");      // 1.0 only
    // 5. Handle removals
    txt = txt.replaceAll(""2"", """");
    // 2.0 only
    txt = txt.replaceAll(""3$"", ""A"");
    txt = txt.replaceAll(""3"", """");
    // 6. put ten 1s on the end
    // 1.0 only has 6 1s
    txt = txt + ""111111"" + ""1111"";
    // 1.0 truncates to 6
    return txt.substring(0, 10);
}",6.2797628862442
35,True,Cli,22,High,94,159,0.6041666666666666,0.7299077733860342,0.5,1.0,0.7333333333333333,0.42189892802450224,0.5177526336324614,1.1428571428571428,0.0,0.5592701687411129,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            int pos = token.indexOf('=');
            // --foo
            String opt = pos == -1 ? token : token.substring(0, pos);
            if (!options.hasOption(opt)) {
                processNonOptionToken(token);
            } else {
                tokens.add(opt);
                if (pos != -1) {
                    tokens.add(token.substring(pos + 1));
                }
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2 || options.hasOption(token)) {
                processOptionToken(token, stopAtNonOption);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}",6.209186646641253
204,True,Closure,110,Medium,352,422,0.3958333333333333,0.35046113306982873,0.375,1.3333333333333333,0.6,0.2963246554364472,0.14241123683183682,1.8571428571428572,0.0,0.8574746931128676,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
        // Bleeding functions already get a BAD_PARAMETERS error, so just
        // do nothing.
        } else if (parent.getType() == Token.LP) {
        // Parameters of the scope function also get a BAD_PARAMETERS
        // error.
        } else if (isVar) {
            Node grandparent = parent.getParent();
            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;
            Node varNode = parent;
            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));
            compiler.ensureLibraryInjected(""base"");
            // Make sure we copy over all the jsdoc and debug info.
            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);
                grandparent.addChildBefore(newDecl, varNode);
            }
            // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));
            recordAlias(v);
        } else {
            // Do not other kinds of local symbols, like catch params.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}",6.207981242260504
211,True,Closure,116,Medium,689,749,0.5625,0.7826086956521741,0.625,0.6666666666666666,1.1333333333333333,0.5781010719754976,0.5286773312524391,0.7142857142857143,0.0,0.613604143685128,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter check if a mutable argument use more than one.
        if (fnParam != null) {
            if (cArg != null) {
                // parameter reference will be in a loop.
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            // Move to the next name.
            fnParam = fnParam.getNext();
        }
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}",6.204776956850953
359,True,Closure,175,Medium,689,737,0.5625,0.7826086956521741,0.625,0.6666666666666666,1.1333333333333333,0.5781010719754976,0.5286773312524391,0.7142857142857143,0.0,0.613604143685128,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        if (fnParam != null) {
            if (cArg != null) {
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            fnParam = fnParam.getNext();
        }
        // Limit the inlining
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}",6.204776956850953
682,True,Math,76,High,233,277,0.4375,0.7562582345191039,0.125,0.6666666666666666,0.13333333333333333,1.5245022970903523,0.152555598907529,0.07142857142857142,0.0,2.301584482365693,"/**
 * {@inheritDoc}
 */
public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
            cachedV = transformer.getV().multiply(e);
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[n][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < n; ++i) {
                wData[i] = new double[p];
            }
            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
        }
    }
    // return the cached matrix
    return cachedV;
}",6.1688291843112495
572,True,Lang,51,High,649,700,0.6458333333333334,1.3148880105401846,0.5,0.3333333333333333,0.13333333333333333,0.510719754977029,0.35310183378852955,1.1428571428571428,0.0,1.2291844768019757,"// String to boolean methods
// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a boolean (optimised for performance).</p>
 *
 * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>
 * (case insensitive) will return <code>true</code>. Otherwise,
 * <code>false</code> is returned.</p>
 *
 * <p>This method performs 4 times faster (JDK1.4) than
 * <code>Boolean.valueOf(String)</code>. However, this method accepts
 * 'on' and 'yes' as true values.
 *
 * <pre>
 *   BooleanUtils.toBoolean(null)    = false
 *   BooleanUtils.toBoolean(""true"")  = true
 *   BooleanUtils.toBoolean(""TRUE"")  = true
 *   BooleanUtils.toBoolean(""tRUe"")  = true
 *   BooleanUtils.toBoolean(""on"")    = true
 *   BooleanUtils.toBoolean(""yes"")   = true
 *   BooleanUtils.toBoolean(""false"") = false
 *   BooleanUtils.toBoolean(""x gti"") = false
 * </pre>
 *
 * @param str  the String to check
 * @return the boolean value of the string, <code>false</code> if no match
 */
public static boolean toBoolean(String str) {
    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
    if (str == ""true"") {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch(str.length()) {
        case 2:
            {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');
            }
        case 3:
            {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
                }
            }
        case 4:
            {
                char ch = str.charAt(0);
                if (ch == 't') {
                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
    }
    return false;
}",6.163251218964862
301,True,Closure,158,Medium,193,257,0.9375,-0.2819499341238472,0.625,0.6666666666666666,0.9333333333333333,0.10796324655436448,0.4865392118610992,1.5714285714285714,0.0,1.0030857229675585,"/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineOrTweakReplacements(config.define, options, false);
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);
    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
        options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
    if (config.languageIn.length() > 0) {
        if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") || config.languageIn.equals(""ES5_STRICT"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT5"") || config.languageIn.equals(""ES5"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT3"") || config.languageIn.equals(""ES3"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
        } else {
            throw new FlagUsageException(""Unknown language `"" + config.languageIn + ""' specified."");
        }
    }
    options.acceptConstKeyword = config.acceptConstKeyword;
}",6.049566818687746
109,True,Closure,40,Medium,595,642,0.8541666666666666,0.5243741765480897,0.875,1.0,1.0,-0.19525267993874423,0.6449473273507599,1.1428571428571428,0.0,0.20060088142114454,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // Record global variable and function declarations
    if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
            NameInformation ns = createNameInformation(t, n, parent);
            Preconditions.checkNotNull(ns);
            recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null) {
                JsName nameInfo = getName(nameNode.getString(), true);
                recordSet(nameInfo.name, nameNode);
            }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null) {
                recordSet(ns.name, n);
            }
        }
    }
    // Record assignments and call sites
    if (n.isAssign()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else {
                recordSet(ns.name, nameNode);
            }
        }
    } else if (n.isCall()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null && ns.onlyAffectsClassDef) {
            JsName name = getName(ns.name, false);
            if (name != null) {
                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
            }
        }
    }
}",6.046693514905059
681,True,Math,76,High,153,198,0.4375,0.7562582345191039,0.125,0.6666666666666666,0.13333333333333333,1.4571209800918836,0.14943425673039348,0.07142857142857142,0.0,2.2386695441069007,"/**
 * {@inheritDoc}
 */
public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
    // return the cached matrix
    return cachedU;
}",6.035411586876853
240,True,Closure,137,Medium,284,344,0.6041666666666666,1.4571805006587615,0.25,1.0,0.9333333333333333,-0.052833078101071934,0.3905579399141628,1.1428571428571428,0.0,0.3046145681646261,"/**
 * Rename vars for the current scope, and merge any referenced
 * names into the parent scope reference set.
 */
@Override
public void visit(NodeTraversal t, Node node, Node parent) {
    if (node.getType() == Token.NAME) {
        String oldName = node.getString();
        if (containsSeparator(oldName)) {
            Scope scope = t.getScope();
            Var var = t.getScope().getVar(oldName);
            if (var == null || var.isGlobal()) {
                return;
            }
            if (nameMap.containsKey(var)) {
                node.setString(nameMap.get(var));
            } else {
                int index = indexOfSeparator(oldName);
                String newName = getOrginalNameInternal(oldName, index);
                String suffix = getNameSuffix(oldName, index);
                // Merge any names that were referenced but not declared in the current
                // scope.
                // If there isn't anything left in the stack we will be going into the
                // global scope: don't try to build a set of referenced names for the
                // global scope.
                boolean recurseScopes = false;
                if (!suffix.matches(""\\d+"")) {
                    recurseScopes = true;
                }
                // Check if the new name is valid and if it would cause conflicts.
                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {
                    newName = oldName;
                } else {
                    var.scope.declare(newName, var.nameNode, null, null);
                    // Adding a reference to the new name to prevent either the parent
                    // scopes or the current scope renaming another var to this new name.
                    Node parentNode = var.getParentNode();
                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {
                        var.getNameNode().setString(newName);
                    }
                    node.setString(newName);
                    compiler.reportCodeChange();
                }
                nameMap.put(var, newName);
            }
        // Add all referenced names to the set so it is possible to check for
        // conflicts.
        // Store only references to candidate names in the node map.
        }
    }
}",6.029877073493622
430,True,Compress,32,Low,481,518,0.22916666666666666,0.007905138339921014,0.75,3.0,0.7333333333333333,-0.33001531393568145,0.22668747561451438,1.4285714285714286,0.0,-0.06593753443887242,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
    /*
         * The following headers are defined for Pax.
         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields
         * mtime
         * comment
         * gid, gname
         * linkpath
         * size
         * uid,uname
         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those
         */
    for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        if (""path"".equals(key)) {
            currEntry.setName(val);
        } else if (""linkpath"".equals(key)) {
            currEntry.setLinkName(val);
        } else if (""gid"".equals(key)) {
            currEntry.setGroupId(Integer.parseInt(val));
        } else if (""gname"".equals(key)) {
            currEntry.setGroupName(val);
        } else if (""uid"".equals(key)) {
            currEntry.setUserId(Integer.parseInt(val));
        } else if (""uname"".equals(key)) {
            currEntry.setUserName(val);
        } else if (""size"".equals(key)) {
            currEntry.setSize(Long.parseLong(val));
        } else if (""mtime"".equals(key)) {
            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
        } else if (""SCHILY.devminor"".equals(key)) {
            currEntry.setDevMinor(Integer.parseInt(val));
        } else if (""SCHILY.devmajor"".equals(key)) {
            currEntry.setDevMajor(Integer.parseInt(val));
        }
    }
}",5.97971119415131
533,True,Lang,30,Low,1443,1468,0.10416666666666667,1.857707509881423,0.125,1.0,0.8,1.3192955589586521,0.06749902458057036,-0.2857142857142857,0.0,0.8779898290975974,"// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // missing low surrogate, fine, like String.indexOf(String)
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}",5.865944303470624
627,True,Math,32,High,129,181,0.8541666666666666,0.6139657444005271,0.125,0.6666666666666666,-0.26666666666666666,1.143185298621746,0.5427233710495502,0.5714285714285714,0.0,1.611824824234695,"/**
 * {@inheritDoc}
 */
@Override
protected void computeGeometricalProperties() {
    final Vector2D[][] v = getVertices();
    if (v.length == 0) {
        final BSPTree<Euclidean2D> tree = getTree(false);
        if ((Boolean) tree.getAttribute()) {
            // the instance covers the whole space
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(0);
            setBarycenter(new Vector2D(0, 0));
        }
    } else if (v[0][0] == null) {
        // there is at least one open-loop: the polygon is infinite
        setSize(Double.POSITIVE_INFINITY);
        setBarycenter(Vector2D.NaN);
    } else {
        // all loops are closed, we compute some integrals around the shape
        double sum = 0;
        double sumX = 0;
        double sumY = 0;
        for (Vector2D[] loop : v) {
            double x1 = loop[loop.length - 1].getX();
            double y1 = loop[loop.length - 1].getY();
            for (final Vector2D point : loop) {
                final double x0 = x1;
                final double y0 = y1;
                x1 = point.getX();
                y1 = point.getY();
                final double factor = x0 * y1 - y0 * x1;
                sum += factor;
                sumX += factor * (x0 + x1);
                sumY += factor * (y0 + y1);
            }
        }
        if (sum < 0) {
            // the polygon as a finite outside surrounded by an infinite inside
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(sum / 2);
            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
        }
    }
}",5.862294476401756
409,True,Compress,17,High,102,151,0.6458333333333334,-0.2661396574440052,0.875,0.0,0.4,2.166156202143951,0.6215372610222399,-0.5,0.0,1.8666237975149444,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NULs or spaces
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}",5.809010936570463
50,True,Cli,32,Critical,902,943,-0.020833333333333332,-0.5981554677206851,0.125,0.0,0.6666666666666666,3.342266462480857,-0.17128365197034676,-0.14285714285714285,0.0,2.5436318445754296,"/**
 * Finds the next text wrap position after <code>startPos</code> for the
 * text in <code>text</code> with the column width <code>width</code>.
 * The wrap point is the last position before startPos+width having a
 * whitespace character (space, \n, \r). If there is no whitespace character
 * before startPos+width, it will return startPos+width.
 *
 * @param text The text being searched for the wrap position
 * @param width width of the wrapped text
 * @param startPos position from which to start the lookup whitespace
 * character
 * @return postion on which the text must be wrapped or -1 if the wrap
 * position is at the end of the text
 */
protected int findWrapPos(String text, int width, int startPos) {
    int pos;
    // the line ends before the max wrap pos or a new line char found
    if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) {
        return pos + 1;
    } else if (startPos + width >= text.length()) {
        return -1;
    }
    // look for the last whitespace character before startPos+width
    pos = startPos + width;
    char c;
    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        --pos;
    }
    // if we found it - just return
    if (pos > startPos) {
        return pos;
    }
    // if we didn't find one, simply chop at startPos+width
    pos = startPos + width;
    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        ++pos;
    }
    return pos == text.length() ? -1 : pos;
}",5.7444353778414445
283,True,Closure,153,Medium,118,173,0.8125,0.3768115942028985,0.625,0.3333333333333333,0.4666666666666667,0.35145482388973964,0.5973468591494344,1.4285714285714286,0.0,0.7376728898266368,"/**
 * Scans and gather variables declarations under a Node
 */
private void scanVars(Node n, Node parent) {
    switch(n.getType()) {
        case Token.VAR:
            // Declare all variables. e.g. var x = 1, y, z;
            for (Node child = n.getFirstChild(); child != null; ) {
                Node next = child.getNext();
                Preconditions.checkState(child.getType() == Token.NAME);
                String name = child.getString();
                declareVar(name, child, n, parent, null, n);
                child = next;
            }
            return;
        case Token.FUNCTION:
            if (NodeUtil.isFunctionExpression(n)) {
                return;
            }
            String fnName = n.getFirstChild().getString();
            if (fnName.isEmpty()) {
                // This is invalid, but allow it so the checks can catch it.
                return;
            }
            declareVar(fnName, n.getFirstChild(), n, parent, null, n);
            // should not examine function's children
            return;
        case Token.CATCH:
            Preconditions.checkState(n.getChildCount() == 2);
            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);
            // the first child is the catch var and the third child
            // is the code block
            final Node var = n.getFirstChild();
            final Node block = var.getNext();
            declareVar(var.getString(), var, n, parent, null, n);
            scanVars(block, n);
            // only one child to scan
            return;
        case Token.SCRIPT:
            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
            break;
    }
    // we only need to traverse children in a couple special cases.
    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {
        for (Node child = n.getFirstChild(); child != null; ) {
            Node next = child.getNext();
            scanVars(child, n);
            child = next;
        }
    }
}",5.729357595640138
590,True,Math,3,High,814,872,0.8541666666666666,-0.45586297760210814,0.125,0.0,0.06666666666666667,1.8307810107197546,0.39992196644557165,-0.5714285714285714,0.0,3.4668407824725804,"/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */
public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    // Revert to scalar multiplication.
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}",5.716085543940561
522,True,Lang,19,Low,36,83,0.6458333333333334,0.2714097496706193,0.25,0.3333333333333333,0.5333333333333333,1.0819295558958653,0.3858759266484584,0.5714285714285714,0.0,1.6172109301357658,"/**
 * {@inheritDoc}
 */
@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",5.69035473377928
386,True,Compress,2,High,59,117,1.0625,0.12384716732542814,1.0,0.3333333333333333,0.26666666666666666,0.6362940275650842,0.840811548966056,0.42857142857142855,0.0,0.9768763367632224,"/**
 * Returns the next AR entry in this stream.
 *
 * @return the next AR entry.
 * @throws IOException
 *             if the entry could not be read
 */
public ArArchiveEntry getNextArEntry() throws IOException {
    if (offset == 0) {
        final byte[] expected = ArArchiveEntry.HEADER.getBytes();
        final byte[] realized = new byte[expected.length];
        final int read = read(realized);
        if (read != expected.length) {
            throw new IOException(""failed to read header"");
        }
        for (int i = 0; i < expected.length; i++) {
            if (expected[i] != realized[i]) {
                throw new IOException(""invalid header "" + new String(realized));
            }
        }
    }
    if (input.available() == 0) {
        return null;
    }
    if (offset % 2 != 0) {
        read();
    }
    final byte[] name = new byte[16];
    final byte[] lastmodified = new byte[12];
    final byte[] userid = new byte[6];
    final byte[] groupid = new byte[6];
    final byte[] filemode = new byte[8];
    final byte[] length = new byte[10];
    read(name);
    read(lastmodified);
    read(userid);
    read(groupid);
    read(filemode);
    read(length);
    {
        final byte[] expected = ArArchiveEntry.TRAILER.getBytes();
        final byte[] realized = new byte[expected.length];
        final int read = read(realized);
        if (read != expected.length) {
            throw new IOException(""failed to read entry header"");
        }
        for (int i = 0; i < expected.length; i++) {
            if (expected[i] != realized[i]) {
                throw new IOException(""invalid entry header. not read the content?"");
            }
        }
    }
    return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));
}",5.66890050919122
352,True,Closure,172,Medium,1661,1709,0.2708333333333333,0.8932806324110674,0.5,1.0,1.3333333333333333,0.3131699846860643,0.18689036285602892,0.6428571428571429,0.0,0.49800936630334897,"/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
    // Prototypes of constructors and interfaces are always declared.
    if (qName != null && qName.endsWith("".prototype"")) {
        return false;
    }
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            // Functions assigned in conditional blocks are inferred.
            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}",5.638374155780319
448,True,Compress,47,High,420,461,0.3541666666666667,-0.5138339920948617,0.875,0.3333333333333333,1.1333333333333333,1.0941807044410414,0.24697619976589877,0.6428571428571429,0.0,1.4620495662975714,"@Override
public int read(final byte[] buffer, final int offset, final int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
    }
    int read;
    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
        read = readStored(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
        read = readDeflated(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
        read = current.in.read(buffer, offset, length);
    } else {
        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
    }
    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }
    return read;
}",5.628062954600127
32,True,Cli,20,High,97,159,0.5208333333333334,0.6192358366271409,0.375,1.3333333333333333,0.4666666666666667,0.08805513016845332,0.46547015216543147,1.3571428571428572,0.0,0.23724437663367315,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            if (token.indexOf('=') != -1) {
                tokens.add(token.substring(0, token.indexOf('=')));
                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
            } else {
                tokens.add(token);
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2) {
                processOptionToken(token, stopAtNonOption);
            } else if (options.hasOption(token)) {
                tokens.add(token);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            process(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}",5.462981686070889
113,True,Closure,43,Medium,497,547,0.6041666666666666,0.5243741765480897,1.375,0.3333333333333333,0.8,-0.03445635528330775,0.6925477955520876,1.0,0.0,0.13530852414920613,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    inputId = t.getInputId();
    attachLiteralTypes(t, n);
    switch(n.getType()) {
        case Token.CALL:
            checkForClassDefiningCalls(t, n, parent);
            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
            break;
        case Token.FUNCTION:
            if (t.getInput() == null || !t.getInput().isExtern()) {
                nonExternFunctions.add(n);
            }
            // Hoisted functions are handled during pre-traversal.
            if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
                defineFunctionLiteral(n, parent);
            }
            break;
        case Token.ASSIGN:
            // Handle initialization of properties.
            Node firstChild = n.getFirstChild();
            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());
            }
            break;
        case Token.CATCH:
            defineCatch(n, parent);
            break;
        case Token.VAR:
            defineVar(n, parent);
            break;
        case Token.GETPROP:
            // Handle stubbed properties.
            if (parent.isExprResult() && n.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
            }
            break;
    }
// Analyze any @lends object literals in this statement.
}",5.430274140966076
28,True,Cli,18,High,97,159,0.5208333333333334,0.6192358366271409,0.375,1.3333333333333333,0.4666666666666667,0.05895865237366,0.46703082325399814,1.3571428571428572,0.0,0.21412713307019812,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle SPECIAL TOKEN
        if (token.startsWith(""--"")) {
            if (token.indexOf('=') != -1) {
                tokens.add(token.substring(0, token.indexOf('=')));
                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
            } else {
                tokens.add(token);
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            processSingleHyphen(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2) {
                processOptionToken(token, stopAtNonOption);
            } else if (options.hasOption(token)) {
                tokens.add(token);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            process(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}",5.412328635801188
182,True,Closure,92,Medium,747,809,1.0625,0.6455862977602106,0.25,0.3333333333333333,0.4,0.00995405819295565,0.6777214202106909,1.5714285714285714,0.0,0.45803192075555277,"/**
 * Replace the provide statement.
 *
 * If we're providing a name with no definition, then create one.
 * If we're providing a name with a duplicate definition, then make sure
 * that definition becomes a declaration.
 */
void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }
    // provided symbol.
    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();
        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            Node nameNode = assignNode.getFirstChild();
            if (nameNode.getType() == Token.NAME) {
                // Need to convert this assign to a var declaration.
                Node valueNode = nameNode.getNext();
                assignNode.removeChild(nameNode);
                assignNode.removeChild(valueNode);
                nameNode.addChildToFront(valueNode);
                Node varNode = new Node(Token.VAR, nameNode);
                varNode.copyInformationFrom(candidateDefinition);
                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                compiler.reportCodeChange();
                replacementNode = varNode;
            }
        }
    } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            // In this case, the name was implicitly provided by two independent
            // modules. We need to move this code up to a common module.
            int indexOfDot = namespace.indexOf('.');
            if (indexOfDot == -1) {
                // Any old place is fine.
                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);
            } else {
                // Add it after the parent namespace.
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                Preconditions.checkNotNull(parentName);
                Preconditions.checkNotNull(parentName.replacementNode);
                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}",5.408555601681315
424,True,Compress,27,High,102,150,0.5208333333333334,-0.22397891963109345,0.875,0.0,0.4,2.0574272588055127,0.5294576667967225,-0.5,0.0,1.7064679278471524,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}",5.365207267151627
463,True,JxPath,1,High,87,135,0.8125,0.27667984189723316,0.875,1.0,0.8,0.04364471669218991,0.6433866562621932,0.5,0.0,0.4038070802576858,"public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    } else if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
    } else if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    } else if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",5.355018295109302
0,True,Chart,1,Medium,1790,1822,0.4375,1.225296442687747,0.5,0.6666666666666666,0.4,0.8905053598774886,0.5044869293796336,0.14285714285714285,0.0,0.5765476494901177,"/**
 * Returns a (possibly empty) collection of legend items for the series
 * that this renderer is responsible for drawing.
 *
 * @return The legend item collection (never <code>null</code>).
 *
 * @see #getLegendItem(int, int)
 */
public LegendItemCollection getLegendItems() {
    LegendItemCollection result = new LegendItemCollection();
    if (this.plot == null) {
        return result;
    }
    int index = this.plot.getIndexOf(this);
    CategoryDataset dataset = this.plot.getDataset(index);
    if (dataset != null) {
        return result;
    }
    int seriesCount = dataset.getRowCount();
    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
        for (int i = 0; i < seriesCount; i++) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    } else {
        for (int i = seriesCount - 1; i >= 0; i--) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    }
    return result;
}",5.343860190958796
229,True,Closure,134,Medium,195,249,0.8958333333333334,0.2819499341238472,0.25,0.3333333333333333,0.13333333333333333,0.2840735068912711,0.4241123683183772,1.5,0.0,1.2190627918945207,"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}",5.321698601228016
160,True,Closure,76,Medium,338,382,0.3958333333333333,1.2779973649538867,0.625,1.0,0.6666666666666666,0.051301684532924954,0.41162699960983273,0.7142857142857143,0.0,0.17699788257775564,"/**
 * Give an expression and a variable. It returns READ, if the first
 * reference of that variable is a read. It returns KILL, if the first
 * reference of that variable is an assignment. It returns MAY_LIVE otherwise.
 */
private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
            // The expression to which the assignment is made is evaluated before
            // the RHS is evaluated (normal left to right evaluation) but the KILL
            // occurs after the RHS is evaluated.
            Node rhs = n.getNext();
            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
            if (state == VariableLiveness.READ) {
                return state;
            }
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }
    switch(n.getType()) {
        // Conditionals
        case Token.OR:
        case Token.AND:
        // may not.
        case Token.HOOK:
            return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
        default:
            // Expressions are evaluated left-right, depth first.
            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
                if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {
                    // Not a FUNCTION
                    VariableLiveness state = isVariableReadBeforeKill(child, variable);
                    if (state != VariableLiveness.MAYBE_LIVE) {
                        return state;
                    }
                }
            }
    }
    return VariableLiveness.MAYBE_LIVE;
}",5.319709645960114
494,True,JxPath,16,Low,117,167,0.9791666666666666,0.2872200263504611,0.875,0.3333333333333333,0.8,0.09418070444104137,0.7136168552477574,0.6428571428571429,0.0,0.5505308534848662,"/**
 * Test a Node.
 * @param node to test
 * @param test to execute
 * @return true if node passes test
 */
public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",5.275905582381269
159,True,Closure,76,Medium,290,324,0.0625,2.779973649538867,0.5,1.6666666666666667,0.26666666666666666,-0.07733537519142418,0.21342177136168441,-0.14285714285714285,0.0,-0.06750821450696373,"/**
 * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as
 * the root, this function returns true if there exists a read of that
 * variable before a write to that variable that is on the right side of n.
 *
 * For example, suppose the node is x = 1:
 *
 * y = 1, x = 1; // false, there is no reads at all.
 * y = 1, x = 1, print(x) // true, there is a read right of n.
 * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but
 *                               // it is after a write.
 *
 * @param n The current node we should look at.
 * @param exprRoot The node
 */
private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) {
    while (n != exprRoot) {
        VariableLiveness state = VariableLiveness.MAYBE_LIVE;
        switch(n.getParent().getType()) {
            case Token.OR:
            case Token.AND:
            case Token.HOOK:
            default:
                for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {
                    if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
                        state = isVariableReadBeforeKill(sibling, variable);
                        // If we see a READ or KILL there is no need to continue.
                        if (state == VariableLiveness.READ) {
                            return true;
                        } else if (state == VariableLiveness.KILL) {
                            return false;
                        }
                    }
                }
        }
        n = n.getParent();
    }
    return false;
}",5.201528021678355
637,True,Math,41,High,501,532,0.22916666666666666,0.7404479578392623,0.125,0.6666666666666666,0.26666666666666666,1.947166921898928,0.1338275458447135,-0.5714285714285714,0.0,1.6076456169145554,"/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}",5.145159471068888
458,True,Csv,11,High,359,394,0.3958333333333333,0.940711462450593,0.375,0.6666666666666666,0.6666666666666666,0.7450229709035221,0.32344908310573633,0.21428571428571427,0.0,0.7819943143093451,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 * @throws IOException if there is a problem reading the header or skipping the first record
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }
        // build the name to index mappings
        if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean containsHeader = hdrMap.containsKey(header);
                final boolean emptyHeader = header.trim().isEmpty();
                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header + ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}",5.109630211721577
608,True,Math,16,High,383,437,0.6041666666666666,-0.924901185770751,-0.125,-0.3333333333333333,-0.3333333333333333,2.767993874425727,0.29379633242294084,-0.42857142857142855,0.0,3.5089431398836117,"/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */
public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20) {
        // Avoid overflow (MATH-905).
        return 0.5 * exp(x);
    }
    if (x < -20) {
        // Avoid overflow (MATH-905).
        return 0.5 * exp(-x);
    }
    final double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * HEX_40000000;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * HEX_40000000;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}",5.0297607323901
486,True,JxPath,12,High,87,136,0.9791666666666666,0.2872200263504611,0.875,0.3333333333333333,0.8,0.05436447166921905,0.7401482637534129,0.5,0.0,0.45331988055127886,"public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",5.022552642324372
351,True,Closure,171,Medium,1661,1706,0.14583333333333334,0.9723320158102766,0.375,1.0,1.1333333333333333,0.29173047473200614,0.062036675770580384,0.5714285714285714,0.0,0.4120135626297979,"/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
    // Prototype sets are always declared.
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            // Functions assigned in conditional blocks are inferred.
            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}",4.963707967037899
367,True,Codec,6,High,138,180,0.14583333333333334,0.6297760210803691,0.75,1.3333333333333333,0.5333333333333333,0.9471669218989279,0.26102223956301207,-0.21428571428571427,0.0,0.535964614760755,"/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */
public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        if (!base64.hasData()) {
            byte[] buf = new byte[doEncode ? 4096 : 8192];
            int c = in.read(buf);
            // when possible.
            if (c > 0 && b.length == len) {
                base64.setInitialBuffer(b, offset, len);
            }
            if (doEncode) {
                base64.encode(buf, 0, c);
            } else {
                base64.decode(buf, 0, c);
            }
        }
        return base64.readResults(b, offset, len);
    }
}",4.92214408301735
22,True,Cli,12,High,52,110,0.5208333333333334,1.098814229249012,0.375,1.3333333333333333,0.6,-0.20750382848392035,0.4615684744440104,0.7142857142857143,0.0,0.025485033066667245,"/**
 * <p>This flatten method does so using the following rules:
 * <ol>
 *  <li>If an {@link Option} exists for the first character of
 *  the <code>arguments</code> entry <b>AND</b> an {@link Option}
 *  does not exist for the whole <code>argument</code> then
 *  add the first character as an option to the processed tokens
 *  list e.g. ""-D"" and add the rest of the entry to the also.</li>
 *  <li>Otherwise just add the token to the processed tokens list.
 *  </li>
 * </ol>
 * </p>
 *
 * @param options The Options to parse the arguments by.
 * @param arguments The arguments that have to be flattened.
 * @param stopAtNonOption specifies whether to stop
 * flattening when a non option has been encountered
 * @return a String array of the flattened arguments
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    List tokens = new ArrayList();
    boolean eatTheRest = false;
    for (int i = 0; i < arguments.length; i++) {
        String arg = arguments[i];
        if (""--"".equals(arg)) {
            eatTheRest = true;
            tokens.add(""--"");
        } else if (""-"".equals(arg)) {
            tokens.add(""-"");
        } else if (arg.startsWith(""-"")) {
            String opt = Util.stripLeadingHyphens(arg);
            if (options.hasOption(opt)) {
                tokens.add(arg);
            } else {
                if (options.hasOption(arg.substring(0, 2))) {
                    // the format is --foo=value or -foo=value
                    // the format is a special properties option (-Dproperty=value)
                    // -D
                    tokens.add(arg.substring(0, 2));
                    // property=value
                    tokens.add(arg.substring(2));
                } else {
                    eatTheRest = stopAtNonOption;
                    tokens.add(arg);
                }
            }
        } else {
            tokens.add(arg);
        }
        if (eatTheRest) {
            for (i++; i < arguments.length; i++) {
                tokens.add(arguments[i]);
            }
        }
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}",4.9218162892281505
403,True,Compress,11,High,197,254,1.0208333333333333,-0.18181818181818193,1.125,1.0,0.6666666666666666,-0.24732006125574268,0.8962153726102214,0.5714285714285714,0.0,0.042931565212646336,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = in.read(signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            return new ZipArchiveInputStream(in);
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            return new JarArchiveInputStream(in);
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            return new CpioArchiveInputStream(in);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = in.read(dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = in.read(tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in);
        }
        // COMPRESS-117 - improve auto-recognition
        try {
            TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
            tais.getNextEntry();
            return new TarArchiveInputStream(in);
        } catch (Exception e) {
        // NOPMD
        // can generate IllegalArgumentException as well as IOException
        // autodetection, simply not a TAR
        // ignored
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}",4.893937266177515
464,True,JxPath,1,High,343,395,0.7708333333333334,0.30303030303030315,0.875,1.0,0.7333333333333333,-0.023736600306278752,0.6706984003121342,0.2857142857142857,0.0,0.24803798734682395,"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    } else if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
    } else if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return node instanceof Element;
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
        }
        return false;
    } else if (test instanceof ProcessingInstructionTest) {
        if (node instanceof ProcessingInstruction) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",4.862911042763935
429,True,Compress,31,High,101,148,0.5208333333333334,-0.144927536231884,0.875,0.0,0.4,1.8016845329249618,0.5567694108466634,-0.5714285714285714,0.0,1.3961837182105805,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        if (currentByte == 0) {
            break;
        }
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}",4.834114887655083
141,True,Closure,64,Medium,1397,1450,0.4375,-0.31357048748353106,0.25,0.0,0.5333333333333333,0.712863705972435,0.16348029652750676,1.6428571428571428,0.0,1.3630817427701107,"public Void call() throws Exception {
    if (options.printInputDelimiter) {
        if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
            // Make sure that the label starts on a new line
            cb.append(""\n"");
        }
        Preconditions.checkState(root.getType() == Token.SCRIPT);
        String delimiter = options.inputDelimiter;
        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
        Preconditions.checkState(sourceName != null);
        Preconditions.checkState(!sourceName.isEmpty());
        delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
        cb.append(delimiter).append(""\n"");
    }
    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
        cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
    }
    // root node's mappings are offset by the given string builder buffer.
    if (options.sourceMapOutputPath != null) {
        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
    }
    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
    // for the first input file
    String code = toSource(root, sourceMap);
    if (!code.isEmpty()) {
        cb.append(code);
        // In order to avoid parse ambiguity when files are concatenated
        // together, all files should end in a semi-colon. Do a quick
        // heuristic check if there's an obvious semi-colon already there.
        int length = code.length();
        char lastChar = code.charAt(length - 1);
        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
        boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
        if (!hasSemiColon) {
            cb.append("";"");
        }
    }
    return null;
}",4.789545733976998
717,True,Math,101,High,320,389,0.8541666666666666,0.007905138339921014,0.5,0.0,0.06666666666666667,0.6730474732006126,0.6769410846664053,1.1428571428571428,0.0,0.8568926427334114,"/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Complex} object.
 */
public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch(c) {
        case 0:
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {
        // set index back to initial, error index should be the start index
        // character examined.
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);
    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}",4.778476815130826
137,True,Closure,60,Medium,120,163,0.4791666666666667,0.2924901185770752,1.375,0.6666666666666666,0.8,-0.0007656967840734906,0.668357393679282,0.35714285714285715,0.0,0.06874935134551005,"/**
 * Gets the boolean value of a node that represents a literal. This method
 * effectively emulates the <code>Boolean()</code> JavaScript cast function
 * except it return UNKNOWN for known values with side-effects, use
 * getExpressionBooleanValue if you don't care about side-effects.
 */
static TernaryValue getPureBooleanValue(Node n) {
    switch(n.getType()) {
        case Token.STRING:
            return TernaryValue.forBoolean(n.getString().length() > 0);
        case Token.NUMBER:
            return TernaryValue.forBoolean(n.getDouble() != 0);
        case Token.NOT:
            return getPureBooleanValue(n.getLastChild()).not();
        case Token.NULL:
        case Token.FALSE:
            return TernaryValue.FALSE;
        case Token.VOID:
            return TernaryValue.FALSE;
        case Token.NAME:
            String name = n.getString();
            if (""undefined"".equals(name) || ""NaN"".equals(name)) {
                // undefined to something other than the value undefined.
                return TernaryValue.FALSE;
            } else if (""Infinity"".equals(name)) {
                return TernaryValue.TRUE;
            }
            break;
        case Token.TRUE:
        case Token.REGEXP:
            return TernaryValue.TRUE;
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            if (!mayHaveSideEffects(n)) {
                return TernaryValue.TRUE;
            }
            break;
    }
    return TernaryValue.UNKNOWN;
}",4.706807357293984
110,True,Closure,41,Medium,242,296,0.4791666666666667,1.040843214756258,0.125,0.6666666666666666,0.26666666666666666,0.3024502297090353,0.2859929769801009,0.9285714285714286,0.0,0.6056715673739365,"/**
 * Infer the parameter and return types of a function from
 * the parameter and return types of the function it is overriding.
 *
 * @param oldType The function being overridden. Does nothing if this is null.
 * @param paramsParent The LP node of the function that we're assigning to.
 *     If null, that just means we're not initializing this to a function
 *     literal.
 */
FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
        return this;
    }
    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();
    if (paramsParent == null) {
        // Not a function literal.
        parametersNode = oldType.getParametersNode();
        if (parametersNode == null) {
            parametersNode = new FunctionParamBuilder(typeRegistry).build();
        }
    } else {
        // We're overriding with a function literal. Apply type information
        // to each parameter of the literal.
        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);
        Iterator<Node> oldParams = oldType.getParameters().iterator();
        boolean warnedAboutArgList = false;
        boolean oldParamsListHitOptArgs = false;
        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {
            if (oldParams.hasNext()) {
                Node oldParam = oldParams.next();
                Node newParam = paramBuilder.newParameterFromNode(oldParam);
                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();
                // arguments.
                if (currentParam.getNext() != null && newParam.isVarArgs()) {
                    newParam.setVarArgs(false);
                    newParam.setOptionalArg(true);
                }
            } else {
                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));
            }
        }
        // Clone any remaining params that aren't in the function literal.
        parametersNode = paramBuilder.build();
    }
    return this;
}",4.701029417390759
401,True,Compress,9,High,266,331,0.6041666666666666,0.2661396574440052,0.25,0.0,0.0,1.5842266462480856,0.4615684744440104,-0.14285714285714285,0.0,1.5784981602286263,"/**
 * Writes bytes to the current tar archive entry. This method
 * is aware of the current entry and will throw an exception if
 * you attempt to write bytes past the length specified for the
 * current entry. The method is also (painfully) aware of the
 * record buffering required by TarBuffer, and manages buffers
 * that are not a multiple of recordsize in length, including
 * assembling records from small buffers.
 *
 * @param wBuf The buffer to write to the archive.
 * @param wOffset The offset in the buffer from which to get bytes.
 * @param numToWrite The number of bytes to write.
 * @throws IOException on error
 */
@Override
public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
    if ((currBytes + numToWrite) > currSize) {
        throw new IOException(""request to write '"" + numToWrite + ""' bytes exceeds size in header of '"" + currSize + ""' bytes for entry '"" + currName + ""'"");
    // 
    // We have to deal with assembly!!!
    // The programmer can be writing little 32 byte chunks for all
    // we know, and we must assemble complete records for writing.
    // REVIEW Maybe this should be in TarBuffer? Could that help to
    // eliminate some of the buffer copying.
    // 
    }
    if (assemLen > 0) {
        if ((assemLen + numToWrite) >= recordBuf.length) {
            int aLen = recordBuf.length - assemLen;
            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);
            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);
            buffer.writeRecord(recordBuf);
            currBytes += recordBuf.length;
            wOffset += aLen;
            numToWrite -= aLen;
            assemLen = 0;
        } else {
            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);
            wOffset += numToWrite;
            assemLen += numToWrite;
            numToWrite = 0;
        }
    }
    // 
    while (numToWrite > 0) {
        if (numToWrite < recordBuf.length) {
            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);
            assemLen += numToWrite;
            break;
        }
        buffer.writeRecord(wBuf, wOffset);
        int num = recordBuf.length;
        currBytes += num;
        numToWrite -= num;
        wOffset += num;
    }
    count(numToWrite);
}",4.6017424621742515
23,True,Cli,13,High,139,189,0.5208333333333334,0.5191040843214758,0.5,1.0,0.6,0.031393568147013794,0.49746390948107694,0.6428571428571429,0.0,0.17853860417043385,"public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {
    // count of arguments processed for this option.
    int argumentCount = 0;
    while (arguments.hasNext() && (argumentCount < maximum)) {
        final String allValuesQuoted = (String) arguments.next();
        final String allValues = stripBoundaryQuotes(allValuesQuoted);
        // should we ignore things that look like options?
        if (allValuesQuoted.equals(consumeRemaining)) {
            while (arguments.hasNext() && (argumentCount < maximum)) {
                ++argumentCount;
                commandLine.addValue(option, arguments.next());
            }
        } else // does it look like an option?
        if (commandLine.looksLikeOption(allValuesQuoted)) {
            arguments.previous();
            break;
        } else // should we split the string up?
        if (subsequentSplit) {
            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));
            arguments.remove();
            while (values.hasMoreTokens() && (argumentCount < maximum)) {
                ++argumentCount;
                final String token = values.nextToken();
                commandLine.addValue(option, token);
                arguments.add(token);
            }
            if (values.hasMoreTokens()) {
                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());
            }
        } else // it must be a value as it is
        {
            ++argumentCount;
            commandLine.addValue(option, allValues);
        }
    }
}",4.490190642310477
603,True,Math,10,Low,1382,1420,0.14583333333333334,-0.19235836627140987,-0.125,0.0,-0.26666666666666666,2.2825421133231236,-0.10729613733905581,0.21428571428571427,0.0,2.5151413344574896,"/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */
public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    // x^2
    multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
    // y^2
    multiply(y, yOffset, y, yOffset, tmp2, 0);
    // x^2 + y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);
    // r = sqrt(x^2 + y^2)
    rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        // r + x
        add(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r + x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r + x))
        atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
            // 2 * atan(y / (r + x))
            result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        // r - x
        subtract(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r - x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r - x))
        atan(tmp1, 0, tmp2, 0);
        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))
        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
            // +/-pi - 2 * atan(y / (r - x))
            result[resultOffset + i] = -2 * tmp2[i];
        }
    }
// fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
}",4.466481325122528
495,True,JxPath,16,Low,358,407,0.8541666666666666,0.29776021080368903,0.75,0.3333333333333333,0.7333333333333333,0.02220520673813177,0.6636753804135777,0.42857142857142855,0.0,0.3683512246061799,"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return (node instanceof Element) || (node instanceof Document);
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
        String testPI = ((ProcessingInstructionTest) test).getTarget();
        String nodePI = ((ProcessingInstruction) node).getTarget();
        return testPI.equals(nodePI);
    }
    return false;
}",4.45139678446634
188,True,Closure,99,Medium,84,136,0.3125,0.4400527009222661,0.375,0.3333333333333333,1.4666666666666666,0.31623277182235837,0.22356613343737883,0.5,0.16666666666666669,0.4795891837064413,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                return false;
            }
            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
                return false;
            }
        }
    }
    return true;
}",4.446940789888444
695,True,Math,85,High,165,208,0.22916666666666666,-0.5507246376811594,0.5,-0.3333333333333333,0.6666666666666666,1.9609494640122511,0.11431915723761246,-0.14285714285714285,0.0,2.0014390767653834,"/**
 * This method attempts to find two values a and b satisfying <ul>
 * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>
 * <li> <code> f(a) * f(b) <= 0 </code> </li>
 * </ul>
 * If f is continuous on <code>[a,b],</code> this means that <code>a</code>
 * and <code>b</code> bracket a root of f.
 * <p>
 * The algorithm starts by setting
 * <code>a := initial -1; b := initial +1,</code> examines the value of the
 * function at <code>a</code> and <code>b</code> and keeps moving
 * the endpoints out by one unit each time through a loop that terminates
 * when one of the following happens: <ul>
 * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>
 * <li> <code> a = lower </code> and <code> b = upper</code>
 * -- ConvergenceException </li>
 * <li> <code> maximumIterations</code> iterations elapse
 * -- ConvergenceException </li></ul></p>
 *
 * @param function the function
 * @param initial initial midpoint of interval being expanded to
 * bracket a root
 * @param lowerBound lower bound (a is never lower than this value)
 * @param upperBound upper bound (b never is greater than this
 * value)
 * @param maximumIterations maximum number of iterations to perform
 * @return a two element array holding {a, b}.
 * @throws ConvergenceException if the algorithm fails to find a and b
 * satisfying the desired conditions
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if function is null, maximumIterations
 * is not positive, or initial is not between lowerBound and upperBound
 */
public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException {
    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"", lowerBound, initial, upperBound);
    }
    double a = initial;
    double b = initial;
    double fa;
    double fb;
    int numIterations = 0;
    do {
        a = Math.max(a - 1.0, lowerBound);
        b = Math.min(b + 1.0, upperBound);
        fa = function.value(a);
        fb = function.value(b);
        numIterations++;
    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));
    if (fa * fb >= 0.0) {
        throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + ""final b value={6}, f(a)={7}, f(b)={8}"", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb);
    }
    return new double[] { a, b };
}",4.445625917476944
225,True,Closure,130,Medium,161,197,0.020833333333333332,1.4466403162055337,0.375,1.0,0.9333333333333333,0.27794793261868306,-0.10729613733905581,0.0,0.0,0.4141641531862444,"/**
 * For each qualified name N in the global scope, we check if:
 * (a) No ancestor of N is ever aliased or assigned an unknown value type.
 *     (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased).
 * (b) N has exactly one write, and it lives in the global scope.
 * (c) N is aliased in a local scope.
 *
 * If (a) is true, then GlobalNamespace must know all the writes to N.
 * If (a) and (b) are true, then N cannot change during the execution of
 *    a local scope.
 * If (a) and (b) and (c) are true, then the alias can be inlined if the
 *    alias obeys the usual rules for how we decide whether a variable is
 *    inlineable.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();
        // Don't attempt to inline a getter or setter property as a variable.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }
        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                    }
                }
            }
        }
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}",4.360622931338073
104,True,Closure,36,Medium,519,580,0.22916666666666666,0.22924901185770755,0.25,0.3333333333333333,1.2666666666666666,0.30704441041347624,0.16894264533749453,1.1428571428571428,0.0,0.37400053711266634,"/**
 * @return true if the provided reference and declaration can be safely
 *         inlined according to our criteria
 */
private boolean canInline(Reference declaration, Reference initialization, Reference reference) {
    if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {
        return false;
    }
    // ASSIGN expressions parents do.
    if (declaration != initialization && !initialization.getGrandparent().isExprResult()) {
        return false;
    }
    // scope boundaries
    if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
    }
    // Do not inline into a call node. This would change
    // the context in which it was being called. For example,
    // var a = b.c;
    // a();
    // should not be inlined, because it calls a in the context of b
    // rather than the context of the window.
    // var a = b.c;
    // f(a)
    // is ok.
    Node value = initialization.getAssignedValue();
    Preconditions.checkState(value != null);
    if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
    }
    if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
            CodingConvention convention = compiler.getCodingConvention();
            // Bug 2388531: Don't inline subclass definitions into class defining
            // calls as this confused class removing logic.
            SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);
            if (relationship != null) {
                return false;
            }
        // issue 668: Don't inline singleton getter methods
        // calls as this confused class removing logic.
        }
    }
    return canMoveAggressively(value) || canMoveModerately(initialization, reference);
}",4.301260414245154
582,True,Lang,61,High,1760,1787,0.22916666666666666,0.06587615283267458,0.5,0.3333333333333333,0.4666666666666667,1.7465543644716692,0.31408505657432745,-0.35714285714285715,0.0,0.9842611009525727,"/**
 * Searches the string builder to find the first reference to the specified
 * string starting searching from the given index.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the first index of the string, or -1 if not found
 */
public int indexOf(String str, int startIndex) {
    startIndex = (startIndex < 0 ? 0 : startIndex);
    if (str == null || startIndex >= size) {
        return -1;
    }
    int strLen = str.length();
    if (strLen == 1) {
        return indexOf(str.charAt(0), startIndex);
    }
    if (strLen == 0) {
        return startIndex;
    }
    if (strLen > size) {
        return -1;
    }
    char[] thisBuf = buffer;
    int len = thisBuf.length - strLen;
    outer: for (int i = startIndex; i < len; i++) {
        for (int j = 0; j < strLen; j++) {
            if (str.charAt(j) != thisBuf[i + j]) {
                continue outer;
            }
        }
        return i;
    }
    return -1;
}",4.282800484355053
407,True,Compress,15,High,648,688,0.3125,-0.20289855072463758,0.375,0.0,0.5333333333333333,0.6546707503828483,0.1923527116660167,1.5714285714285714,0.0,0.8361977558962026,"/* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    String myName = getName();
    String otherName = other.getName();
    if (myName == null) {
        if (otherName != null) {
            return false;
        }
    } else if (!myName.equals(otherName)) {
        return false;
    }
    String myComment = getComment();
    String otherComment = other.getComment();
    if (myComment == null) {
        if (otherComment != null) {
            return false;
        }
    } else if (!myComment.equals(otherComment)) {
        return false;
    }
    return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb);
}",4.2725845719823345
298,True,Closure,157,Medium,313,343,0.14583333333333334,1.4677206851119895,0.625,1.0,0.3333333333333333,-0.06508422664624805,0.2781896215372609,0.5,0.16666666666666669,-0.022671076268928662,"public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.GETPROP:
        case Token.GETELEM:
            Node dest = n.getFirstChild().getNext();
            if (dest.getType() == Token.STRING) {
                String s = dest.getString();
                if (s.equals(""prototype"")) {
                    processPrototypeParent(parent, t.getInput());
                } else {
                    markPropertyAccessCandidate(dest, t.getInput());
                }
            }
            break;
        case Token.OBJECTLIT:
            if (!prototypeObjLits.contains(n)) {
                // only the property names.
                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
                    if (child.getType() != Token.NUMBER) {
                        markObjLitPropertyCandidate(child, t.getInput());
                    }
                }
            }
            break;
    }
}",4.26232167040074
