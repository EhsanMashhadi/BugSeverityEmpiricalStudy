,ProjectName,ProjectVersion,IssueTracker,URL,Priority,ClassName,StartLine,EndLine,SourceCode
0,Chart,1,sourceforge,https://sourceforge.net/p/jfreechart/bugs/983,Medium,source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java,1790,1822,"/**
 * Returns a (possibly empty) collection of legend items for the series
 * that this renderer is responsible for drawing.
 *
 * @return The legend item collection (never <code>null</code>).
 *
 * @see #getLegendItem(int, int)
 */
public LegendItemCollection getLegendItems() {
    LegendItemCollection result = new LegendItemCollection();
    if (this.plot == null) {
        return result;
    }
    int index = this.plot.getIndexOf(this);
    CategoryDataset dataset = this.plot.getDataset(index);
    if (dataset == null) {
        return result;
    }
    int seriesCount = dataset.getRowCount();
    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
        for (int i = 0; i < seriesCount; i++) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    } else {
        for (int i = seriesCount - 1; i >= 0; i--) {
            if (isSeriesVisibleInLegend(i)) {
                LegendItem item = getLegendItem(index, i);
                if (item != null) {
                    result.add(item);
                }
            }
        }
    }
    return result;
}"
1,Chart,2,sourceforge,https://sourceforge.net/p/jfreechart/bugs/959,Low,source/org/jfree/data/general/DatasetUtilities.java,740,792,"/**
 * Iterates over the items in an {@link XYDataset} to find
 * the range of x-values.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the x-interval or just the
 *          x-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 */
public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {
    if (dataset == null) {
        throw new IllegalArgumentException(""Null 'dataset' argument."");
    }
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    double lvalue;
    double uvalue;
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double value = intervalXYData.getXValue(series, item);
                lvalue = intervalXYData.getStartXValue(series, item);
                uvalue = intervalXYData.getEndXValue(series, item);
                if (!Double.isNaN(value)) {
                    minimum = Math.min(minimum, value);
                    maximum = Math.max(maximum, value);
                }
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    minimum = Math.min(minimum, uvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = dataset.getXValue(series, item);
                uvalue = lvalue;
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    }
    if (minimum > maximum) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}"
2,Chart,2,sourceforge,https://sourceforge.net/p/jfreechart/bugs/959,Low,source/org/jfree/data/general/DatasetUtilities.java,1236,1303,"/**
 * Iterates over the data items of the xy dataset to find
 * the range bounds.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the y-interval or just the
 *          y-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 *
 * @since 1.0.10
 */
public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    // handle three cases by dataset type
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        // handle special case of IntervalXYDataset
        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double value = ixyd.getYValue(series, item);
                double lvalue = ixyd.getStartYValue(series, item);
                double uvalue = ixyd.getEndYValue(series, item);
                if (!Double.isNaN(value)) {
                    minimum = Math.min(minimum, value);
                    maximum = Math.max(maximum, value);
                }
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    minimum = Math.min(minimum, uvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else if (includeInterval && dataset instanceof OHLCDataset) {
        // handle special case of OHLCDataset
        OHLCDataset ohlc = (OHLCDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ohlc.getLowValue(series, item);
                double uvalue = ohlc.getHighValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        // standard case - plain XYDataset
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double value = dataset.getYValue(series, item);
                if (!Double.isNaN(value)) {
                    minimum = Math.min(minimum, value);
                    maximum = Math.max(maximum, value);
                }
            }
        }
    }
    if (minimum == Double.POSITIVE_INFINITY) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}"
3,Chart,5,sourceforge,https://sourceforge.net/p/jfreechart/bugs/862,Low,source/org/jfree/data/xy/XYSeries.java,540,580,"/**
 * Adds or updates an item in the series and sends a
 * {@link SeriesChangeEvent} to all registered listeners.
 *
 * @param x  the x-value (<code>null</code> not permitted).
 * @param y  the y-value (<code>null</code> permitted).
 *
 * @return A copy of the overwritten data item, or <code>null</code> if no
 *         item was overwritten.
 */
public XYDataItem addOrUpdate(Number x, Number y) {
    if (x == null) {
        throw new IllegalArgumentException(""Null 'x' argument."");
    }
    if (this.allowDuplicateXValues) {
        add(x, y);
        return null;
    }
    // if we get to here, we know that duplicate X values are not permitted
    XYDataItem overwritten = null;
    int index = indexOf(x);
    if (index >= 0) {
        XYDataItem existing = (XYDataItem) this.data.get(index);
        try {
            overwritten = (XYDataItem) existing.clone();
        } catch (CloneNotSupportedException e) {
            throw new SeriesException(""Couldn't clone XYDataItem!"");
        }
        existing.setY(y);
    } else {
        // append the value to the list...
        if (this.autoSort) {
            this.data.add(-index - 1, new XYDataItem(x, y));
        } else {
            this.data.add(new XYDataItem(x, y));
        }
        // check if this addition will exceed the maximum item count...
        if (getItemCount() > this.maximumItemCount) {
            this.data.remove(0);
        }
    }
    fireSeriesChanged();
    return overwritten;
}"
4,Chart,9,sourceforge,https://sourceforge.net/p/jfreechart/bugs/818,Medium,source/org/jfree/data/time/TimeSeries.java,918,956,"/**
 * Creates a new timeseries by copying a subset of the data in this time
 * series.
 *
 * @param start  the first time period to copy (<code>null</code> not
 *         permitted).
 * @param end  the last time period to copy (<code>null</code> not
 *         permitted).
 *
 * @return A time series containing a copy of this time series from start
 *         until end.
 *
 * @throws CloneNotSupportedException if there is a cloning problem.
 */
public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {
    if (start == null) {
        throw new IllegalArgumentException(""Null 'start' argument."");
    }
    if (end == null) {
        throw new IllegalArgumentException(""Null 'end' argument."");
    }
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(""Requires start on or before end."");
    }
    boolean emptyRange = false;
    int startIndex = getIndex(start);
    if (startIndex < 0) {
        startIndex = -(startIndex + 1);
        if (startIndex == this.data.size()) {
            // start is after last data item
            emptyRange = true;
        }
    }
    int endIndex = getIndex(end);
    if (endIndex < 0) {
        // end period is not in original series
        // this is first item AFTER end period
        endIndex = -(endIndex + 1);
        // so this is last item BEFORE end
        endIndex = endIndex - 1;
    }
    if ((endIndex < 0) || (endIndex < startIndex)) {
        emptyRange = true;
    }
    if (emptyRange) {
        TimeSeries copy = (TimeSeries) super.clone();
        copy.data = new java.util.ArrayList();
        return copy;
    } else {
        return createCopy(startIndex, endIndex);
    }
}"
5,Chart,11,sourceforge,https://sourceforge.net/p/jfreechart/bugs/868,Medium,source/org/jfree/chart/util/ShapeUtilities.java,264,296,"/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */
public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p2.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}"
6,Chart,16,sourceforge,https://sourceforge.net/p/jfreechart/bugs/834,Medium,source/org/jfree/data/category/DefaultIntervalCategoryDataset.java,334,351,"/**
 * Sets the categories for the dataset.
 *
 * @param categoryKeys  an array of objects representing the categories in
 *                      the dataset.
 *
 * @see #getRowKeys()
 * @see #setSeriesKeys(Comparable[])
 */
public void setCategoryKeys(Comparable[] categoryKeys) {
    if (categoryKeys == null) {
        throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
    }
    if (categoryKeys.length != getCategoryCount()) {
        throw new IllegalArgumentException(""The number of categories does not match the data."");
    }
    for (int i = 0; i < categoryKeys.length; i++) {
        if (categoryKeys[i] == null) {
            throw new IllegalArgumentException(""DefaultIntervalCategoryDataset.setCategoryKeys(): "" + ""null category not permitted."");
        }
    }
    this.categoryKeys = categoryKeys;
    fireDatasetChanged();
}"
7,Chart,17,sourceforge,https://sourceforge.net/p/jfreechart/bugs/803,Medium,source/org/jfree/data/time/TimeSeries.java,856,860,"/**
 * Returns a clone of the time series.
 * <P>
 * Notes:
 * <ul>
 *   <li>no need to clone the domain and range descriptions, since String
 *     object is immutable;</li>
 *   <li>we pass over to the more general method clone(start, end).</li>
 * </ul>
 *
 * @return A clone of the time series.
 *
 * @throws CloneNotSupportedException not thrown by this class, but
 *         subclasses may differ.
 */
public Object clone() throws CloneNotSupportedException {
    TimeSeries clone = (TimeSeries) super.clone();
    clone.data = (List) ObjectUtilities.deepClone(this.data);
    return clone;
}"
8,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,65,68,"/**
 * Query to see if an option has been set.
 *
 * @param opt Short name of the option
 * @return true if set, false if not
 */
public boolean hasOption(String opt) {
    return options.contains(resolveOption(opt));
}"
9,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,87,100,"/**
 * Return the <code>Object</code> type of this <code>Option</code>.
 *
 * @param opt the name of the option
 * @return the type of this <code>Option</code>
 */
public Object getOptionObject(String opt) {
    String res = getOptionValue(opt);
    Option option = resolveOption(opt);
    if (option == null) {
        return null;
    }
    Object type = option.getType();
    return (res == null) ? null : TypeHandler.createValue(res, type);
}"
10,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,146,156,"/**
 * Retrieves the array of values, if any, of an option.
 *
 * @param opt string name of the option
 * @return Values of the argument if option is set, and has an argument,
 * otherwise null.
 */
public String[] getOptionValues(String opt) {
    Option key = resolveOption(opt);
    if (options.contains(key)) {
        return key.getValues();
    }
    return null;
}"
11,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,163,180,"/**
 * <p>Retrieves the option object given the long or short option as a String</p>
 * @param opt short or long name of the option
 * @return Canonicalized option
 */
private Option resolveOption(String opt) {
    opt = Util.stripLeadingHyphens(opt);
    for (Iterator it = options.iterator(); it.hasNext(); ) {
        Option option = (Option) it.next();
        if (opt.equals(option.getOpt())) {
            return option;
        }
        if (opt.equals(option.getLongOpt())) {
            return option;
        }
    }
    return null;
}"
12,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,286,289,"/**
 * Add an option to the command line.  The values of
 * the option are stored.
 *
 * @param opt the processed option
 */
void addOption(Option opt) {
    options.add(opt);
}"
13,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,297,300,"/**
 * Returns an iterator over the Option members of CommandLine.
 *
 * @return an <code>Iterator</code> over the processed {@link Option}
 * members of this {@link CommandLine}
 */
public Iterator iterator() {
    return options.iterator();
}"
14,Cli,1,jira,https://issues.apache.org/jira/browse/CLI-13,High,src/java/org/apache/commons/cli/CommandLine.java,307,316,"/**
 * Returns an array of the processed {@link Option}s.
 *
 * @return an array of the processed {@link Option}s.
 */
public Option[] getOptions() {
    Collection processed = options;
    // reinitialise array
    Option[] optionsArray = new Option[processed.size()];
    // return the array
    return (Option[]) processed.toArray(optionsArray);
}"
15,Cli,2,jira,https://issues.apache.org/jira/browse/CLI-51,Critical,src/java/org/apache/commons/cli/PosixParser.java,278,309,"/**
 * <p>Breaks <code>token</code> into its constituent parts
 * using the following algorithm.
 * <ul>
 *  <li>ignore the first character (""<b>-</b>"")</li>
 *  <li>foreach remaining character check if an {@link Option}
 *  exists with that id.</li>
 *  <li>if an {@link Option} does exist then add that character
 *  prepended with ""<b>-</b>"" to the list of processed tokens.</li>
 *  <li>if the {@link Option} can have an argument value and there
 *  are remaining characters in the token then add the remaining
 *  characters as a token to the list of processed tokens.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token
 *  ""<b>--</b>"" followed by the remaining characters and also
 *  the remaining tokens directly to the processed tokens list.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that
 *  character prepended with ""<b>-</b>"".</li>
 * </ul>
 * </p>
 *
 * @param token The current token to be <b>burst</b>
 * @param stopAtNonOption Specifies whether to stop processing
 * at the first non-Option encountered.
 */
protected void burstToken(String token, boolean stopAtNonOption) {
    int tokenLength = token.length();
    for (int i = 1; i < tokenLength; i++) {
        String ch = String.valueOf(token.charAt(i));
        boolean hasOption = options.hasOption(ch);
        if (hasOption) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);
            if (currentOption.hasArg() && (token.length() != (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            process(token.substring(i));
        } else {
            tokens.add(token);
            break;
        }
    }
}"
16,Cli,3,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/TypeHandler.java,157,179,"/**
 * <p>Create a number from a String. If a . is present, it creates a
 *    Double, otherwise a Long. </p>
 *
 * @param str the value
 * @return the number represented by <code>str</code>, if <code>str</code>
 * is not a number, null is returned.
 */
public static Number createNumber(String str) {
    try {
        if (str != null) {
            if (str.indexOf('.') != -1) {
                return Double.valueOf(str);
            } else {
                return Long.valueOf(str);
            }
        }
    } catch (NumberFormatException nfe) {
        System.err.println(nfe.getMessage());
    }
    return null;
}"
17,Cli,4,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/Parser.java,290,311,"/**
 * <p>Throws a {@link MissingOptionException} if all of the
 * required options are no present.</p>
 *
 * @throws MissingOptionException if any of the required Options
 * are not present.
 */
private void checkRequiredOptions() throws MissingOptionException {
    // processsed
    if (requiredOptions.size() > 0) {
        Iterator iter = requiredOptions.iterator();
        StringBuffer buff = new StringBuffer(""Missing required option"");
        buff.append(requiredOptions.size() == 1 ? """" : ""s"");
        buff.append("": "");
        // loop through the required options
        while (iter.hasNext()) {
            buff.append(iter.next());
        }
        throw new MissingOptionException(buff.toString());
    }
}"
18,Cli,5,jira,https://issues.apache.org/jira/browse/CLI-133,Low,src/java/org/apache/commons/cli/Util.java,34,49,"/**
 * <p>Remove the hyphens from the begining of <code>str</code> and
 * return the new String.</p>
 *
 * @param str The string from which the hyphens should be removed.
 *
 * @return the new String.
 */
static String stripLeadingHyphens(String str) {
    if (str == null) {
        return null;
    }
    if (str.startsWith(""--"")) {
        return str.substring(2, str.length());
    } else if (str.startsWith(""-"")) {
        return str.substring(1, str.length());
    }
    return str;
}"
19,Cli,8,jira,https://issues.apache.org/jira/browse/CLI-151,High,src/java/org/apache/commons/cli/HelpFormatter.java,792,823,"/**
 * <p>Render the specified text and return the rendered Options
 * in a StringBuffer.</p>
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 *
 * @return the StringBuffer with the rendered Options contents.
 */
protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    // all following lines must be padded with nextLineTabStop space
    // characters
    final String padding = createPadding(nextLineTabStop);
    while (true) {
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, 0);
        if (pos == -1) {
            sb.append(text);
            return sb;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}"
20,Cli,9,jira,https://issues.apache.org/jira/browse/CLI-149,High,src/java/org/apache/commons/cli/Parser.java,303,325,"/**
 * <p>Throws a {@link MissingOptionException} if all of the
 * required options are no present.</p>
 *
 * @throws MissingOptionException if any of the required Options
 * are not present.
 */
protected void checkRequiredOptions() throws MissingOptionException {
    // processsed
    if (getRequiredOptions().size() > 0) {
        Iterator iter = getRequiredOptions().iterator();
        StringBuffer buff = new StringBuffer(""Missing required option"");
        buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
        buff.append("": "");
        // loop through the required options
        while (iter.hasNext()) {
            buff.append(iter.next());
            buff.append("", "");
        }
        throw new MissingOptionException(buff.substring(0, buff.length() - 2));
    }
}"
21,Cli,10,jira,https://issues.apache.org/jira/browse/CLI-156,Low,src/java/org/apache/commons/cli/Parser.java,45,48,"protected void setOptions(final Options options) {
    this.options = options;
    this.requiredOptions = new ArrayList(options.getRequiredOptions());
}"
22,Cli,11,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/HelpFormatter.java,613,642,"/**
 * Appends the usage clause for an Option to a StringBuffer.
 *
 * @param buff the StringBuffer to append to
 * @param option the Option to append
 * @param required whether the Option is required or not
 */
private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {
    if (!required) {
        buff.append(""["");
    }
    if (option.getOpt() != null) {
        buff.append(""-"").append(option.getOpt());
    } else {
        buff.append(""--"").append(option.getLongOpt());
    }
    // if the Option has a value
    if (option.hasArg() && option.hasArgName()) {
        buff.append("" <"").append(option.getArgName()).append("">"");
    }
    // if the Option is not a required option
    if (!required) {
        buff.append(""]"");
    }
}"
23,Cli,12,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/GnuParser.java,52,115,"/**
 * <p>This flatten method does so using the following rules:
 * <ol>
 *  <li>If an {@link Option} exists for the first character of
 *  the <code>arguments</code> entry <b>AND</b> an {@link Option}
 *  does not exist for the whole <code>argument</code> then
 *  add the first character as an option to the processed tokens
 *  list e.g. ""-D"" and add the rest of the entry to the also.</li>
 *  <li>Otherwise just add the token to the processed tokens list.
 *  </li>
 * </ol>
 * </p>
 *
 * @param options The Options to parse the arguments by.
 * @param arguments The arguments that have to be flattened.
 * @param stopAtNonOption specifies whether to stop
 * flattening when a non option has been encountered
 * @return a String array of the flattened arguments
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    List tokens = new ArrayList();
    boolean eatTheRest = false;
    for (int i = 0; i < arguments.length; i++) {
        String arg = arguments[i];
        if (""--"".equals(arg)) {
            eatTheRest = true;
            tokens.add(""--"");
        } else if (""-"".equals(arg)) {
            tokens.add(""-"");
        } else if (arg.startsWith(""-"")) {
            String opt = Util.stripLeadingHyphens(arg);
            if (options.hasOption(opt)) {
                tokens.add(arg);
            } else {
                if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) {
                    // the format is --foo=value or -foo=value
                    // --foo
                    tokens.add(arg.substring(0, arg.indexOf('=')));
                    // value
                    tokens.add(arg.substring(arg.indexOf('=') + 1));
                } else if (options.hasOption(arg.substring(0, 2))) {
                    // the format is a special properties option (-Dproperty=value)
                    // -D
                    tokens.add(arg.substring(0, 2));
                    // property=value
                    tokens.add(arg.substring(2));
                } else {
                    eatTheRest = stopAtNonOption;
                    tokens.add(arg);
                }
            }
        } else {
            tokens.add(arg);
        }
        if (eatTheRest) {
            for (i++; i < arguments.length; i++) {
                tokens.add(arguments[i]);
            }
        }
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}"
24,Cli,13,jira,https://issues.apache.org/jira/browse/CLI-61,High,src/java/org/apache/commons/cli2/WriteableCommandLine.java,47,47,"/**
 * Retrieves the Argument values specified on the command line for the
 * specified Option, this doesn't return any values supplied
 * programmatically as defaults.
 *
 * @param option the Option associated with the values
 * @return a list of values or an empty List if none are found
 */
List getUndefaultedValues(final Option option);"
25,Cli,13,jira,https://issues.apache.org/jira/browse/CLI-61,High,src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,132,142,"public List getUndefaultedValues(Option option) {
    // First grab the command line values
    List valueList = (List) values.get(option);
    // Finally use an empty list
    if (valueList == null) {
        valueList = Collections.EMPTY_LIST;
    }
    return valueList;
}"
26,Cli,13,jira,https://issues.apache.org/jira/browse/CLI-61,High,src/java/org/apache/commons/cli2/option/ArgumentImpl.java,139,189,"public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {
    // count of arguments processed for this option.
    int argumentCount = commandLine.getUndefaultedValues(option).size();
    while (arguments.hasNext() && (argumentCount < maximum)) {
        final String allValuesQuoted = (String) arguments.next();
        final String allValues = stripBoundaryQuotes(allValuesQuoted);
        // should we ignore things that look like options?
        if (allValuesQuoted.equals(consumeRemaining)) {
            while (arguments.hasNext() && (argumentCount < maximum)) {
                ++argumentCount;
                commandLine.addValue(option, arguments.next());
            }
        } else // does it look like an option?
        if (commandLine.looksLikeOption(allValuesQuoted)) {
            arguments.previous();
            break;
        } else // should we split the string up?
        if (subsequentSplit) {
            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));
            arguments.remove();
            while (values.hasMoreTokens() && (argumentCount < maximum)) {
                ++argumentCount;
                final String token = values.nextToken();
                commandLine.addValue(option, token);
                arguments.add(token);
            }
            if (values.hasMoreTokens()) {
                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());
            }
        } else // it must be a value as it is
        {
            ++argumentCount;
            commandLine.addValue(option, allValues);
        }
    }
}"
27,Cli,14,jira,https://issues.apache.org/jira/browse/CLI-144,High,src/java/org/apache/commons/cli2/option/GroupImpl.java,237,282,"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            validate = true;
        }
        if (validate) {
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}"
28,Cli,15,jira,https://issues.apache.org/jira/browse/CLI-158,High,src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,111,139,"public List getValues(final Option option, List defaultValues) {
    // initialize the return list
    List valueList = (List) values.get(option);
    // grab the correct default values
    if (defaultValues == null || defaultValues.isEmpty()) {
        defaultValues = (List) this.defaultValues.get(option);
    }
    // augment the list with the default values
    if (defaultValues != null && !defaultValues.isEmpty()) {
        if (valueList == null || valueList.isEmpty()) {
            valueList = defaultValues;
        } else {
            // the list.
            if (defaultValues.size() > valueList.size()) {
                // copy the list first
                valueList = new ArrayList(valueList);
                for (int i = valueList.size(); i < defaultValues.size(); i++) {
                    valueList.add(defaultValues.get(i));
                }
            }
        }
    }
    return valueList == null ? Collections.EMPTY_LIST : valueList;
}"
29,Cli,16,jira,https://issues.apache.org/jira/browse/CLI-123,Low,src/java/org/apache/commons/cli2/Option.java,206,206,"/**
 * Returns the parent of this option. Options can be organized in a
 * hierarchical manner if they are added to groups. This method can be used
 * for obtaining the parent option of this option. The result may be
 * <b>null</b> if this option does not have a parent.
 *
 * @return the parent of this option
 */
Option getParent();"
30,Cli,16,jira,https://issues.apache.org/jira/browse/CLI-123,Low,src/java/org/apache/commons/cli2/Option.java,217,217,"/**
 * Sets the parent of this option. This method is called when the option is
 * added to a group. Storing the parent of an option makes it possible to
 * keep track of hierarchical relations between options. For instance, if an
 * option is identified while parsing a command line, the group this option
 * belongs to can also be added to the command line.
 *
 * @param parent the parent option
 */
void setParent(Option parent);"
31,Cli,16,jira,https://issues.apache.org/jira/browse/CLI-123,Low,src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,65,79,"public void addOption(Option option) {
    options.add(option);
    nameToOption.put(option.getPreferredName(), option);
    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {
        nameToOption.put(i.next(), option);
    }
    // ensure that all parent options are also added
    Option parent = option.getParent();
    while (parent != null && !options.contains(parent)) {
        options.add(parent);
        parent = parent.getParent();
    }
}"
32,Cli,16,jira,https://issues.apache.org/jira/browse/CLI-123,Low,src/java/org/apache/commons/cli2/option/OptionImpl.java,129,131,"public Option getParent() {
    return parent;
}"
33,Cli,16,jira,https://issues.apache.org/jira/browse/CLI-123,Low,src/java/org/apache/commons/cli2/option/OptionImpl.java,133,135,"public void setParent(Option parent) {
    this.parent = parent;
}"
34,Cli,17,jira,https://issues.apache.org/jira/browse/CLI-163,High,src/java/org/apache/commons/cli/PosixParser.java,282,311,"/**
 * <p>Breaks <code>token</code> into its constituent parts
 * using the following algorithm.
 * <ul>
 *  <li>ignore the first character (""<b>-</b>"")</li>
 *  <li>foreach remaining character check if an {@link Option}
 *  exists with that id.</li>
 *  <li>if an {@link Option} does exist then add that character
 *  prepended with ""<b>-</b>"" to the list of processed tokens.</li>
 *  <li>if the {@link Option} can have an argument value and there
 *  are remaining characters in the token then add the remaining
 *  characters as a token to the list of processed tokens.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token
 *  ""<b>--</b>"" followed by the remaining characters and also
 *  the remaining tokens directly to the processed tokens list.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that
 *  character prepended with ""<b>-</b>"".</li>
 * </ul>
 * </p>
 *
 * @param token The current token to be <b>burst</b>
 * @param stopAtNonOption Specifies whether to stop processing
 * at the first non-Option encountered.
 */
protected void burstToken(String token, boolean stopAtNonOption) {
    for (int i = 1; i < token.length(); i++) {
        String ch = String.valueOf(token.charAt(i));
        if (options.hasOption(ch)) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);
            if (currentOption.hasArg() && (token.length() != (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            process(token.substring(i));
            break;
        } else {
            tokens.add(token);
            break;
        }
    }
}"
35,Cli,18,jira,https://issues.apache.org/jira/browse/CLI-164,High,src/java/org/apache/commons/cli/PosixParser.java,97,159,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle SPECIAL TOKEN
        if (token.startsWith(""--"")) {
            if (token.indexOf('=') != -1) {
                tokens.add(token.substring(0, token.indexOf('=')));
                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
            } else {
                tokens.add(token);
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2) {
                processOptionToken(token, stopAtNonOption);
            } else if (options.hasOption(token)) {
                tokens.add(token);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            process(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}"
36,Cli,18,jira,https://issues.apache.org/jira/browse/CLI-164,High,src/java/org/apache/commons/cli/PosixParser.java,227,239,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * set the current option and add the token to the processed
 * list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then ignore the current token and add the remaining tokens
 * to the processed tokens list directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (options.hasOption(token)) {
        currentOption = options.getOption(token);
        tokens.add(token);
    } else if (stopAtNonOption) {
        eatTheRest = true;
        tokens.add(token);
    }
}"
37,Cli,19,jira,https://issues.apache.org/jira/browse/CLI-164,High,src/java/org/apache/commons/cli/PosixParser.java,227,239,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * set the current option and add the token to the processed
 * list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then ignore the current token and add the remaining tokens
 * to the processed tokens list directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (options.hasOption(token)) {
        currentOption = options.getOption(token);
    } else if (stopAtNonOption) {
        eatTheRest = true;
    }
    tokens.add(token);
}"
38,Cli,20,jira,https://issues.apache.org/jira/browse/CLI-165,High,src/java/org/apache/commons/cli/PosixParser.java,97,164,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            int pos = token.indexOf('=');
            // --foo
            String opt = pos == -1 ? token : token.substring(0, pos);
            if (!options.hasOption(opt) && stopAtNonOption) {
                process(token);
            } else {
                tokens.add(opt);
                if (pos != -1) {
                    tokens.add(token.substring(pos + 1));
                }
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2) {
                processOptionToken(token, stopAtNonOption);
            } else if (options.hasOption(token)) {
                tokens.add(token);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            process(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}"
39,Cli,21,jira,https://issues.apache.org/jira/browse/CLI-150,High,src/java/org/apache/commons/cli2/WriteableCommandLine.java,102,102,"/**
 * Returns the option that is currently processed.
 *
 * @return the current option
 */
Option getCurrentOption();"
40,Cli,21,jira,https://issues.apache.org/jira/browse/CLI-150,High,src/java/org/apache/commons/cli2/WriteableCommandLine.java,111,111,"/**
 * Sets the current option. This method is called by concrete option
 * implementations during command line processing. It enables the command
 * line to keep track about the option that is currently processed.
 *
 * @param currentOption the new current option
 */
void setCurrentOption(Option currentOption);"
41,Cli,21,jira,https://issues.apache.org/jira/browse/CLI-150,High,src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,68,70,"public Option getCurrentOption() {
    return currentOption;
}"
42,Cli,21,jira,https://issues.apache.org/jira/browse/CLI-150,High,src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,72,74,"public void setCurrentOption(Option currentOption) {
    this.currentOption = currentOption;
}"
43,Cli,21,jira,https://issues.apache.org/jira/browse/CLI-150,High,src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,241,272,"/**
 * Tests whether the passed in trigger looks like an option. This
 * implementation first checks whether the passed in string starts with a
 * prefix that indicates an option. If this is the case, it is also checked
 * whether an option of this name is known for the current option. (This can
 * lead to reentrant invocations of this method, so care has to be taken
 * about this.)
 *
 * @param trigger the command line element to test
 * @return a flag whether this element seems to be an option
 */
public boolean looksLikeOption(final String trigger) {
    if (checkForOption != null) {
        // this is a reentrant call
        return !checkForOption.equals(trigger);
    }
    checkForOption = trigger;
    try {
        for (final Iterator i = prefixes.iterator(); i.hasNext(); ) {
            final String prefix = (String) i.next();
            if (trigger.startsWith(prefix)) {
                if (getCurrentOption().canProcess(this, trigger) || getCurrentOption().findOption(trigger) != null) {
                    return true;
                }
            }
        }
        return false;
    } finally {
        checkForOption = null;
    }
}"
44,Cli,21,jira,https://issues.apache.org/jira/browse/CLI-150,High,src/java/org/apache/commons/cli2/option/GroupImpl.java,511,520,"/**
 * Helper method for testing whether an element of the command line looks
 * like an option. This method queries the command line, but sets the
 * current option first.
 *
 * @param commandLine the command line
 * @param trigger the trigger to be checked
 * @return a flag whether this element looks like an option
 */
private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) {
    Option oldOption = commandLine.getCurrentOption();
    try {
        commandLine.setCurrentOption(this);
        return commandLine.looksLikeOption(trigger);
    } finally {
        commandLine.setCurrentOption(oldOption);
    }
}"
45,Cli,22,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/PosixParser.java,95,157,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            int pos = token.indexOf('=');
            // --foo
            String opt = pos == -1 ? token : token.substring(0, pos);
            if (!options.hasOption(opt)) {
                processNonOptionToken(token, stopAtNonOption);
            } else {
                currentOption = options.getOption(opt);
                tokens.add(opt);
                if (pos != -1) {
                    tokens.add(token.substring(pos + 1));
                }
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2 || options.hasOption(token)) {
                processOptionToken(token, stopAtNonOption);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else {
            processNonOptionToken(token, stopAtNonOption);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}"
46,Cli,22,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/PosixParser.java,182,191,"/**
 * Add the special token ""<b>--</b>"" and the current <code>value</code>
 * to the processed tokens list. Then add all the remaining
 * <code>argument</code> values to the processed tokens list.
 *
 * @param value The current token
 */
private void processNonOptionToken(String value, boolean stopAtNonOption) {
    if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {
        eatTheRest = true;
        tokens.add(""--"");
    }
    tokens.add(value);
}"
47,Cli,22,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/PosixParser.java,205,218,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    if (options.hasOption(token)) {
        currentOption = options.getOption(token);
    }
    tokens.add(token);
}"
48,Cli,22,jira,https://issues.apache.org/jira/browse/CLI-1,High,src/java/org/apache/commons/cli/PosixParser.java,246,275,"/**
 * Breaks <code>token</code> into its constituent parts
 * using the following algorithm.
 *
 * <ul>
 *  <li>ignore the first character (""<b>-</b>"")</li>
 *  <li>foreach remaining character check if an {@link Option}
 *  exists with that id.</li>
 *  <li>if an {@link Option} does exist then add that character
 *  prepended with ""<b>-</b>"" to the list of processed tokens.</li>
 *  <li>if the {@link Option} can have an argument value and there
 *  are remaining characters in the token then add the remaining
 *  characters as a token to the list of processed tokens.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token
 *  ""<b>--</b>"" followed by the remaining characters and also
 *  the remaining tokens directly to the processed tokens list.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that
 *  character prepended with ""<b>-</b>"".</li>
 * </ul>
 *
 * @param token The current token to be <b>burst</b>
 * @param stopAtNonOption Specifies whether to stop processing
 * at the first non-Option encountered.
 */
protected void burstToken(String token, boolean stopAtNonOption) {
    for (int i = 1; i < token.length(); i++) {
        String ch = String.valueOf(token.charAt(i));
        if (options.hasOption(ch)) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);
            if (currentOption.hasArg() && (token.length() != (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token.substring(i), true);
            break;
        } else {
            tokens.add(token);
            break;
        }
    }
}"
49,Cli,23,jira,https://issues.apache.org/jira/browse/CLI-162,High,src/java/org/apache/commons/cli/HelpFormatter.java,805,842,"/**
 * Render the specified text and return the rendered Options
 * in a StringBuffer.
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 *
 * @return the StringBuffer with the rendered Options contents.
 */
protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    // all following lines must be padded with nextLineTabStop space
    // characters
    final String padding = createPadding(nextLineTabStop);
    while (true) {
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, 0);
        if (pos == -1) {
            sb.append(text);
            return sb;
        }
        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {
            sb.append(text);
            return sb;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}"
50,Cli,24,jira,https://issues.apache.org/jira/browse/CLI-162,High,src/java/org/apache/commons/cli/HelpFormatter.java,809,851,"/**
 * Render the specified text and return the rendered Options
 * in a StringBuffer.
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 *
 * @return the StringBuffer with the rendered Options contents.
 */
protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    if (nextLineTabStop >= width) {
        // stops infinite loop happening
        nextLineTabStop = width - 1;
    }
    // all following lines must be padded with nextLineTabStop space
    // characters
    final String padding = createPadding(nextLineTabStop);
    while (true) {
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, 0);
        if (pos == -1) {
            sb.append(text);
            return sb;
        }
        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {
            pos = width;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}"
51,Cli,25,jira,https://issues.apache.org/jira/browse/CLI-162,High,src/java/org/apache/commons/cli/HelpFormatter.java,809,851,"/**
 * Render the specified text and return the rendered Options
 * in a StringBuffer.
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 *
 * @return the StringBuffer with the rendered Options contents.
 */
protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    if (nextLineTabStop >= width) {
        // stops infinite loop happening
        nextLineTabStop = 1;
    }
    // all following lines must be padded with nextLineTabStop space
    // characters
    final String padding = createPadding(nextLineTabStop);
    while (true) {
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, 0);
        if (pos == -1) {
            sb.append(text);
            return sb;
        }
        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {
            pos = width;
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}"
52,Cli,26,jira,https://issues.apache.org/jira/browse/CLI-177,Low,src/java/org/apache/commons/cli/OptionBuilder.java,346,368,"/**
 * Create an Option using the current settings and with
 * the specified Option <code>char</code>.
 *
 * @param opt the <code>java.lang.String</code> representation
 * of the Option
 * @return the Option instance
 * @throws IllegalArgumentException if <code>opt</code> is not
 * a valid character.  See Option.
 */
public static Option create(String opt) throws IllegalArgumentException {
    Option option = null;
    try {
        // create the option
        option = new Option(opt, description);
        // set the option properties
        option.setLongOpt(longopt);
        option.setRequired(required);
        option.setOptionalArg(optionalArg);
        option.setArgs(numberOfArgs);
        option.setType(type);
        option.setValueSeparator(valuesep);
        option.setArgName(argName);
    } finally {
        // reset the OptionBuilder properties
        OptionBuilder.reset();
    }
    // return the Option instance
    return option;
}"
53,Cli,27,jira,https://issues.apache.org/jira/browse/CLI-182,High,src/java/org/apache/commons/cli/OptionGroup.java,86,106,"/**
 * Set the selected option of this group to <code>name</code>.
 *
 * @param option the option that is selected
 * @throws AlreadySelectedException if an option from this group has
 * already been selected.
 */
public void setSelected(Option option) throws AlreadySelectedException {
    if (option == null) {
        // reset the option previously selected
        selected = null;
        return;
    }
    // selected member variable
    if (selected == null || selected.equals(option.getKey())) {
        selected = option.getKey();
    } else {
        throw new AlreadySelectedException(this, option);
    }
}"
54,Cli,28,jira,https://issues.apache.org/jira/browse/CLI-201,Low,src/java/org/apache/commons/cli/Parser.java,252,296,"/**
 * Sets the values of Options using the values in <code>properties</code>.
 *
 * @param properties The value properties to be processed.
 */
protected void processProperties(Properties properties) {
    if (properties == null) {
        return;
    }
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();
        if (!cmd.hasOption(option)) {
            Option opt = getOptions().getOption(option);
            // get the value from the properties instance
            String value = properties.getProperty(option);
            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    try {
                        opt.addValueForProcessing(value);
                    } catch (RuntimeException exp) {
                    // if we cannot add the value don't worry about it
                    }
                }
            } else if (!(""yes"".equalsIgnoreCase(value) || ""true"".equalsIgnoreCase(value) || ""1"".equalsIgnoreCase(value))) {
                // option to the CommandLine
                continue;
            }
            cmd.addOption(opt);
        }
    }
}"
55,Cli,29,jira,https://issues.apache.org/jira/browse/CLI-185,High,src/java/org/apache/commons/cli/Util.java,63,72,"/**
 * Remove the leading and trailing quotes from <code>str</code>.
 * E.g. if str is '""one two""', then 'one two' is returned.
 *
 * @param str The string from which the leading and trailing quotes
 * should be removed.
 *
 * @return The string without the leading and trailing quotes.
 */
static String stripLeadingAndTrailingQuotes(String str) {
    int length = str.length();
    if (length > 1 && str.startsWith(""\"""") && str.endsWith(""\"""") && str.substring(1, length - 1).indexOf('""') == -1) {
        str = str.substring(1, length - 1);
    }
    return str;
}"
56,Cli,30,jira,https://issues.apache.org/jira/browse/CLI-203,Low,src/main/java/org/apache/commons/cli/DefaultParser.java,139,184,"/**
 * Sets the values of Options using the values in <code>properties</code>.
 *
 * @param properties The value properties to be processed.
 */
private void handleProperties(Properties properties) throws ParseException {
    if (properties == null) {
        return;
    }
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();
        Option opt = options.getOption(option);
        if (opt == null) {
            throw new UnrecognizedOptionException(""Default option wasn't defined"", option);
        }
        // if the option is part of a group, check if another option of the group has been selected
        OptionGroup group = options.getOptionGroup(opt);
        boolean selected = group != null && group.getSelected() != null;
        if (!cmd.hasOption(option) && !selected) {
            // get the value from the properties
            String value = properties.getProperty(option);
            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    opt.addValueForProcessing(value);
                }
            } else if (!(""yes"".equalsIgnoreCase(value) || ""true"".equalsIgnoreCase(value) || ""1"".equalsIgnoreCase(value))) {
                // if the value is not yes, true or 1 then don't add the option to the CommandLine
                continue;
            }
            handleOption(opt);
            currentOption = null;
        }
    }
}"
57,Cli,30,jira,https://issues.apache.org/jira/browse/CLI-203,Low,src/main/java/org/apache/commons/cli/Parser.java,252,305,"/**
 * Sets the values of Options using the values in <code>properties</code>.
 *
 * @param properties The value properties to be processed.
 */
protected void processProperties(Properties properties) throws ParseException {
    if (properties == null) {
        return;
    }
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();
        Option opt = options.getOption(option);
        if (opt == null) {
            throw new UnrecognizedOptionException(""Default option wasn't defined"", option);
        }
        // if the option is part of a group, check if another option of the group has been selected
        OptionGroup group = options.getOptionGroup(opt);
        boolean selected = group != null && group.getSelected() != null;
        if (!cmd.hasOption(option) && !selected) {
            // get the value from the properties instance
            String value = properties.getProperty(option);
            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    try {
                        opt.addValueForProcessing(value);
                    } catch (RuntimeException exp) {
                    // if we cannot add the value don't worry about it
                    }
                }
            } else if (!(""yes"".equalsIgnoreCase(value) || ""true"".equalsIgnoreCase(value) || ""1"".equalsIgnoreCase(value))) {
                // option to the CommandLine
                continue;
            }
            cmd.addOption(opt);
            updateRequiredOptions(opt);
        }
    }
}"
58,Cli,31,jira,https://issues.apache.org/jira/browse/CLI-205,Low,src/main/java/org/apache/commons/cli/HelpFormatter.java,636,664,"/**
 * Appends the usage clause for an Option to a StringBuffer.
 *
 * @param buff the StringBuffer to append to
 * @param option the Option to append
 * @param required whether the Option is required or not
 */
private void appendOption(final StringBuffer buff, final Option option, final boolean required) {
    if (!required) {
        buff.append(""["");
    }
    if (option.getOpt() != null) {
        buff.append(""-"").append(option.getOpt());
    } else {
        buff.append(""--"").append(option.getLongOpt());
    }
    // if the Option has a value and a non blank argname
    if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0)) {
        buff.append(option.getOpt() == null ? longOptSeparator : "" "");
        buff.append(""<"").append(option.getArgName() != null ? option.getArgName() : getArgName()).append("">"");
    }
    // if the Option is not a required option
    if (!required) {
        buff.append(""]"");
    }
}"
59,Cli,31,jira,https://issues.apache.org/jira/browse/CLI-205,Low,src/main/java/org/apache/commons/cli/OptionBuilder.java,77,87,"/**
 * Resets the member variables to their default values.
 */
private static void reset() {
    description = null;
    argName = null;
    longopt = null;
    type = null;
    required = false;
    numberOfArgs = Option.UNINITIALIZED;
    optionalArg = false;
    valuesep = (char) 0;
}"
60,Cli,32,jira,https://issues.apache.org/jira/browse/CLI-193,Critical,src/main/java/org/apache/commons/cli/HelpFormatter.java,902,939,"/**
 * Finds the next text wrap position after <code>startPos</code> for the
 * text in <code>text</code> with the column width <code>width</code>.
 * The wrap point is the last position before startPos+width having a
 * whitespace character (space, \n, \r). If there is no whitespace character
 * before startPos+width, it will return startPos+width.
 *
 * @param text The text being searched for the wrap position
 * @param width width of the wrapped text
 * @param startPos position from which to start the lookup whitespace
 * character
 * @return postion on which the text must be wrapped or -1 if the wrap
 * position is at the end of the text
 */
protected int findWrapPos(String text, int width, int startPos) {
    int pos;
    // the line ends before the max wrap pos or a new line char found
    if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) {
        return pos + 1;
    } else if (startPos + width >= text.length()) {
        return -1;
    }
    // look for the last whitespace character before startPos+width
    pos = startPos + width;
    char c;
    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        --pos;
    }
    // if we found it - just return
    if (pos > startPos) {
        return pos;
    }
    // if we didn't find one, simply chop at startPos+width
    pos = startPos + width;
    return pos == text.length() ? -1 : pos;
}"
61,Cli,33,jira,https://issues.apache.org/jira/browse/CLI-207,High,src/main/java/org/apache/commons/cli/HelpFormatter.java,726,732,"/**
 * Print the specified text to the specified PrintWriter.
 *
 * @param pw The printWriter to write the help to
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be written to the PrintWriter
 */
public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {
    StringBuffer sb = new StringBuffer(text.length());
    renderWrappedTextBlock(sb, width, nextLineTabStop, text);
    pw.println(sb.toString());
}"
62,Cli,33,jira,https://issues.apache.org/jira/browse/CLI-207,High,src/main/java/org/apache/commons/cli/HelpFormatter.java,900,918,"/**
 * Render the specified text width a maximum width. This method differs
 * from renderWrappedText by not removing leading spaces after a new line.
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 */
private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) {
    try {
        BufferedReader in = new BufferedReader(new StringReader(text));
        String line;
        boolean firstLine = true;
        while ((line = in.readLine()) != null) {
            if (!firstLine) {
                sb.append(getNewLine());
            } else {
                firstLine = false;
            }
            renderWrappedText(sb, width, nextLineTabStop, line);
        }
    } catch (IOException e) {
    // cannot happen
    }
    return sb;
}"
63,Cli,34,jira,https://issues.apache.org/jira/browse/CLI-215,Low,src/main/java/org/apache/commons/cli/OptionBuilder.java,79,89,"/**
 * Resets the member variables to their default values.
 */
private static void reset() {
    description = null;
    argName = null;
    longopt = null;
    type = String.class;
    required = false;
    numberOfArgs = Option.UNINITIALIZED;
    optionalArg = false;
    valuesep = (char) 0;
}"
64,Cli,35,jira,https://issues.apache.org/jira/browse/CLI-252,High,src/main/java/org/apache/commons/cli/Options.java,233,253,"/**
 * Returns the options with a long name starting with the name specified.
 *
 * @param opt the partial name of the option
 * @return the options matching the partial name specified, or an empty list if none matches
 * @since 1.3
 */
public List<String> getMatchingOptions(String opt) {
    opt = Util.stripLeadingHyphens(opt);
    List<String> matchingOpts = new ArrayList<String>();
    // for a perfect match return the single option only
    if (longOpts.keySet().contains(opt)) {
        return Collections.singletonList(opt);
    }
    for (String longOpt : longOpts.keySet()) {
        if (longOpt.startsWith(opt)) {
            matchingOpts.add(longOpt);
        }
    }
    return matchingOpts;
}"
65,Cli,37,jira,https://issues.apache.org/jira/browse/CLI-265,High,src/main/java/org/apache/commons/cli/DefaultParser.java,299,311,"/**
 * Tells if the token looks like a short option.
 *
 * @param token
 */
private boolean isShortOption(String token) {
    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
    if (!token.startsWith(""-"") || token.length() == 1) {
        return false;
    }
    // remove leading ""-"" and ""=value""
    int pos = token.indexOf(""="");
    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);
    return options.hasShortOption(optName);
}"
66,Cli,38,jira,https://issues.apache.org/jira/browse/CLI-265,High,src/main/java/org/apache/commons/cli/DefaultParser.java,299,316,"/**
 * Tells if the token looks like a short option.
 *
 * @param token
 */
private boolean isShortOption(String token) {
    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
    if (!token.startsWith(""-"") || token.length() == 1) {
        return false;
    }
    // remove leading ""-"" and ""=value""
    int pos = token.indexOf(""="");
    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);
    if (options.hasShortOption(optName)) {
        return true;
    }
    // check for several concatenated short options
    return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));
}"
67,Cli,39,jira,https://issues.apache.org/jira/browse/CLI-274,Low,src/main/java/org/apache/commons/cli/TypeHandler.java,64,106,"/**
 * Returns the <code>Object</code> of type <code>clazz</code>
 * with the value of <code>str</code>.
 *
 * @param str the command line value
 * @param clazz the type of argument
 * @return The instance of <code>clazz</code> initialised with
 * the value of <code>str</code>.
 * @throws ParseException if the value creation for the given class failed
 */
public static Object createValue(final String str, final Class<?> clazz) throws ParseException {
    if (PatternOptionBuilder.STRING_VALUE == clazz) {
        return str;
    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {
        return createObject(str);
    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {
        return createNumber(str);
    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {
        return createDate(str);
    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {
        return createClass(str);
    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {
        return createFile(str);
    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {
        return openFile(str);
    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {
        return createFiles(str);
    } else if (PatternOptionBuilder.URL_VALUE == clazz) {
        return createURL(str);
    } else {
        return null;
    }
}"
68,Cli,39,jira,https://issues.apache.org/jira/browse/CLI-274,Low,src/main/java/org/apache/commons/cli/TypeHandler.java,234,244,"/**
 * Returns the opened FileInputStream represented by <code>str</code>.
 *
 * @param str the file location
 * @return The file input stream represented by <code>str</code>.
 * @throws ParseException if the file is not exist or not readable
 */
public static FileInputStream openFile(String str) throws ParseException {
    try {
        return new FileInputStream(str);
    } catch (FileNotFoundException e) {
        throw new ParseException(""Unable to find file: "" + str);
    }
}"
69,Cli,40,jira,https://issues.apache.org/jira/browse/CLI-282,Low,src/main/java/org/apache/commons/cli/TypeHandler.java,62,105,"/**
 * Returns the <code>Object</code> of type <code>clazz</code>
 * with the value of <code>str</code>.
 *
 * @param str the command line value
 * @param clazz the type of argument
 * @return The instance of <code>clazz</code> initialised with
 * the value of <code>str</code>.
 * @throws ParseException if the value creation for the given class failed
 */
// returned value will have type T because it is fixed by clazz
@SuppressWarnings(""unchecked"")
public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException {
    if (PatternOptionBuilder.STRING_VALUE == clazz) {
        return (T) str;
    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {
        return (T) createObject(str);
    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {
        return (T) createNumber(str);
    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {
        return (T) createDate(str);
    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {
        return (T) createClass(str);
    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {
        return (T) createFile(str);
    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {
        return (T) openFile(str);
    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {
        return (T) createFiles(str);
    } else if (PatternOptionBuilder.URL_VALUE == clazz) {
        return (T) createURL(str);
    } else {
        throw new ParseException(""Unable to handle the class: "" + clazz);
    }
}"
70,Closure,1,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-253.json,Medium,src/com/google/javascript/jscomp/RemoveUnusedVars.java,369,409,"/**
 * Removes unreferenced arguments from a function declaration and when
 * possible the function's callSites.
 *
 * @param fnScope The scope inside the function
 */
private void removeUnreferencedFunctionArgs(Scope fnScope) {
    // See http://code.google.com/p/closure-compiler/issues/detail?id=253
    if (!removeGlobals) {
        return;
    }
    Node function = fnScope.getRootNode();
    Preconditions.checkState(function.isFunction());
    if (NodeUtil.isGetOrSetKey(function.getParent())) {
        // The parameters object literal setters can not be removed.
        return;
    }
    Node argList = getFunctionArgList(function);
    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);
    if (!modifyCallers) {
        // Strip unreferenced args off the end of the function declaration.
        Node lastArg;
        while ((lastArg = argList.getLastChild()) != null) {
            Var var = fnScope.getVar(lastArg.getString());
            if (!referenced.contains(var)) {
                argList.removeChild(lastArg);
                compiler.reportCodeChange();
            } else {
                break;
            }
        }
    } else {
        callSiteOptimizer.optimize(fnScope, referenced);
    }
}"
71,Closure,2,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-884.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,1566,1596,"/**
 * Check whether there's any property conflict for for a particular super
 * interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that have
 * been visited
 * @param currentProperties The property names in the super interface
 * that have been visited
 * @param interfaceType The super interface that is being visited
 */
private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {
    ObjectType implicitProto = interfaceType.getImplicitPrototype();
    Set<String> currentPropertyNames;
    if (implicitProto == null) {
        // This can be the case if interfaceType is proxy to a non-existent
        // object (which is a bad type annotation, but shouldn't crash).
        currentPropertyNames = ImmutableSet.of();
    } else {
        currentPropertyNames = implicitProto.getOwnPropertyNames();
    }
    for (String name : currentPropertyNames) {
        ObjectType oType = properties.get(name);
        if (oType != null) {
            if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
                compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString()));
            }
        }
        currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
        checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType);
    }
}"
72,Closure,3,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-864.json,High,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,124,170,"@Override
public void enterScope(NodeTraversal t) {
    if (t.inGlobalScope()) {
        // Don't even brother. All global variables are likely escaped.
        return;
    }
    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {
        return;
    }
    // Compute the forward reaching definition.
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
    // Process the body of the function.
    Preconditions.checkState(t.getScopeRoot().isFunction());
    cfa.process(null, t.getScopeRoot().getLastChild());
    cfg = cfa.getCfg();
    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
    reachingDef.analyze();
    candidates = Lists.newLinkedList();
    // Using the forward reaching definition search to find all the inline
    // candidates
    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());
    // Compute the backward reaching use. The CFG can be reused.
    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
    reachingUses.analyze();
    for (Candidate c : candidates) {
        if (c.canInline(t.getScope())) {
            c.inlineVariable();
            // so that we can back off appropriately.
            if (!c.defMetadata.depends.isEmpty()) {
                inlinedNewDependencies.add(t.getScope().getVar(c.varName));
            }
        }
    }
}"
73,Closure,3,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-864.json,High,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,280,417,"private boolean canInline(final Scope scope) {
    // Cannot inline a parameter.
    if (getDefCfgNode().isFunction()) {
        return false;
    }
    // so we just back off for now.
    for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
            return false;
        }
    }
    getDefinition(getDefCfgNode(), null);
    getNumUseInUseCfgNode(useCfgNode, null);
    // Definition was not found.
    if (def == null) {
        return false;
    }
    // TODO(user): Certain cases we can still inline.
    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
    }
    // x = readProp(b), modifyProp(b); print(x);
    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
    }
    // x = readProp(b); modifyProp(b), print(x);
    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
    }
    // side-effect analysis tool.
    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
    }
    // correctly inlining twice increases code size.
    if (numUseWithinUseCfgNode != 1) {
        return false;
    }
    // Make sure that the name is not within a loop
    if (NodeUtil.isWithinLoop(use)) {
        return false;
    }
    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());
    if (uses.size() != 1) {
        return false;
    }
    // need to be special cased.
    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            switch(input.getType()) {
                case Token.GETELEM:
                case Token.GETPROP:
                case Token.ARRAYLIT:
                case Token.OBJECTLIT:
                case Token.REGEXP:
                case Token.NEW:
                    return true;
                case Token.NAME:
                    Var var = scope.getOwnSlot(input.getString());
                    if (var != null && var.getParentNode().isCatch()) {
                        return true;
                    }
            }
            return false;
        }
    }, new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            // Recurse if the node is not a function.
            return !input.isFunction();
        }
    })) {
        return false;
    }
    // they are just next to each other.
    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
        // Similar side effect check as above but this time the side effect is
        // else where along the path.
        // x = readProp(b); while(modifyProp(b)) {}; print(x);
        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);
        if (pathCheck.somePathsSatisfyPredicate()) {
            return false;
        }
    }
    return true;
}"
74,Closure,3,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-864.json,High,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,365,383,"@Override
public boolean apply(Node input) {
    switch(input.getType()) {
        case Token.GETELEM:
        case Token.GETPROP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
        case Token.REGEXP:
        case Token.NEW:
            return true;
        case Token.NAME:
            Var var = scope.getOwnSlot(input.getString());
            if (var != null && var.getParentNode().isCatch()) {
                return true;
            }
    }
    return false;
}"
75,Closure,4,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-873.json,Medium,src/com/google/javascript/rhino/jstype/NamedType.java,183,212,"/**
 * Resolve the referenced type within the enclosing scope.
 */
@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectInheritanceCycle()) {
        handleTypeCycle(t);
    }
    if (resolved) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }
    resolveViaProperties(t, enclosing);
    if (detectInheritanceCycle()) {
        handleTypeCycle(t);
    }
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}"
76,Closure,5,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-851.json,High,src/com/google/javascript/jscomp/InlineObjectLiterals.java,155,256,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically, we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        // 
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target may be using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // a variable, so deleted properties should not be inlined.
            if (gramps.isDelProp()) {
                return false;
            }
            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            // 
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}"
77,Closure,6,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-635.json,Medium,src/com/google/javascript/jscomp/TypeValidator.java,362,385,"/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        // Do not type-check interface methods, because we expect that
        // they will have dummy implementations that do not match the type
        // annotations.
        JSType ownerType = getJSType(owner);
        if (ownerType.isFunctionPrototypeType()) {
            FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
            if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                return true;
            }
        }
        mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        return false;
    }
    return true;
}"
78,Closure,6,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-635.json,Medium,src/com/google/javascript/jscomp/TypeValidator.java,398,405,"/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        mismatch(t, n, msg, rightType, leftType);
        return false;
    }
    return true;
}"
79,Closure,7,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-841.json,Medium,src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,609,622,"@Override
public JSType caseObjectType(ObjectType type) {
    if (value.equals(""function"")) {
        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        if (resultEqualsValue) {
            // Objects are restricted to ""Function"", subtypes are left
            return ctorType.getGreatestSubtype(type);
        } else {
            // Only filter out subtypes of ""function""
            return type.isSubtype(ctorType) ? null : type;
        }
    }
    return matchesExpectation(""object"") ? type : null;
}"
80,Closure,8,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-820.json,Medium,src/com/google/javascript/jscomp/CollapseVariableDeclarations.java,190,206,"private boolean canBeRedeclared(Node n, Scope s) {
    if (!NodeUtil.isExprAssign(n)) {
        return false;
    }
    Node assign = n.getFirstChild();
    Node lhs = assign.getFirstChild();
    if (!lhs.isName()) {
        return false;
    }
    Var var = s.getVar(lhs.getString());
    return var != null && var.getScope() == s && !isNamedParameter(var) && !blacklistedVars.contains(var);
}"
81,Closure,8,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-820.json,Medium,src/com/google/javascript/jscomp/CollapseVariableDeclarations.java,209,211,"private boolean isNamedParameter(Var v) {
    return v.getParentNode().isParamList();
}"
82,Closure,9,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-824.json,Medium,src/com/google/javascript/jscomp/ProcessCommonJSModules.java,116,126,"private String normalizeSourceName(String filename) {
    // The DOS command shell will normalize ""/"" to ""\"", so we have to
    // wrestle it back.
    filename = filename.replace(""\\"", ""/"");
    if (filename.indexOf(filenamePrefix) == 0) {
        filename = filename.substring(filenamePrefix.length());
    }
    return filename;
}"
83,Closure,9,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-824.json,Medium,src/com/google/javascript/jscomp/ProcessCommonJSModules.java,180,205,"/**
 * Emit goog.provide and add suffix to all global vars to avoid conflicts
 * with other modules.
 */
private void visitScript(NodeTraversal t, Node script) {
    Preconditions.checkArgument(scriptNodeCount == 1, ""ProcessCommonJSModules supports only one invocation per "" + ""CompilerInput / script node"");
    String moduleName = guessCJSModuleName(script.getSourceFileName());
    script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()).copyInformationFromForTree(script));
    if (reportDependencies) {
        CompilerInput ci = t.getInput();
        ci.addProvide(moduleName);
        JSModule m = new JSModule(moduleName);
        m.addAndOverrideModule(ci);
        module = m;
    }
    script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(""goog""), IR.string(""provide"")), IR.string(moduleName))).copyInformationFromForTree(script));
    emitOptionalModuleExportsOverride(script, moduleName);
    // Rename vars to not conflict in global scope.
    NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName));
    compiler.reportCodeChange();
}"
84,Closure,10,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-821.json,High,src/com/google/javascript/jscomp/NodeUtil.java,1415,1421,"static boolean mayBeString(Node n, boolean recurse) {
    if (recurse) {
        return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);
    } else {
        return mayBeStringHelper(n);
    }
}"
85,Closure,11,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-810.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,1303,1319,"/**
 * Visits a GETPROP node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of <code>n</code>
 */
private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else if (validator.expectNotNullOrUndefined(t, n, childType, ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
        checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
}"
86,Closure,12,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-794.json,High,src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,159,167,"private boolean hasExceptionHandler(Node cfgNode) {
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);
    for (DiGraphEdge<Node, Branch> edge : branchEdges) {
        if (edge.getValue() == Branch.ON_EX) {
            return true;
        }
    }
    return false;
}"
87,Closure,13,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-787.json,Medium,src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,113,138,"private void traverse(Node node) {
    // and revisit immediately.
    if (!shouldVisit(node)) {
        return;
    }
    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            Node next = c.getNext();
            traverse(c);
            c = next;
        }
        visit(node);
        visits++;
        Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));
    exitNode(node);
}"
88,Closure,14,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-779.json,Medium,src/com/google/javascript/jscomp/ControlFlowAnalysis.java,692,789,"/**
 * Computes the follow() node of a given node and its parent. There is a side
 * effect when calling this function. If this function computed an edge that
 * exists a FINALLY, it'll attempt to connect the fromNode to the outer
 * FINALLY according to the finallyMap.
 *
 * @param fromNode The original source node since {@code node} is changed
 *        during recursion.
 * @param node The node that follow() should compute.
 */
private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }
    // If we are just before a IF/WHILE/DO/FOR:
    switch(parent.getType()) {
        // The follow() of any of the path from IF would be what follows IF.
        case Token.IF:
            return computeFollowNode(fromNode, parent, cfa);
        case Token.CASE:
        case Token.DEFAULT_CASE:
            // case, without having to go to the case condition.
            if (parent.getNext() != null) {
                if (parent.getNext().isCase()) {
                    return parent.getNext().getFirstChild().getNext();
                } else if (parent.getNext().isDefaultCase()) {
                    return parent.getNext().getFirstChild();
                } else {
                    Preconditions.checkState(false, ""Not reachable"");
                }
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
            break;
        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                return parent.getFirstChild().getNext().getNext();
            }
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
            // If we are coming out of the TRY block...
            if (parent.getFirstChild() == node) {
                if (NodeUtil.hasFinally(parent)) {
                    // and have FINALLY block.
                    return computeFallThrough(parent.getLastChild());
                } else {
                    // and have no FINALLY.
                    return computeFollowNode(fromNode, parent, cfa);
                }
            // CATCH block.
            } else if (NodeUtil.getCatchBlock(parent) == node) {
                if (NodeUtil.hasFinally(parent)) {
                    // and have FINALLY block.
                    return computeFallThrough(node.getNext());
                } else {
                    return computeFollowNode(fromNode, parent, cfa);
                }
            // If we are coming out of the FINALLY block...
            } else if (parent.getLastChild() == node) {
                if (cfa != null) {
                    for (Node finallyNode : cfa.finallyMap.get(parent)) {
                        cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);
                    }
                }
                return computeFollowNode(fromNode, parent, cfa);
            }
    }
    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();
    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
        nextSibling = nextSibling.getNext();
    }
    if (nextSibling != null) {
        return computeFallThrough(nextSibling);
    } else {
        // If there are no more siblings, control is transferred up the AST.
        return computeFollowNode(fromNode, parent, cfa);
    }
}"
89,Closure,15,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-773.json,Medium,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,83,112,"@Override
public boolean apply(Node n) {
    // where the function returns (possibly without an return statement)
    if (n == null) {
        return false;
    }
    // function.
    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {
        return true;
    }
    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {
        return true;
    }
    if (n.isDelProp()) {
        return true;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
            return true;
        }
    }
    return false;
}"
90,Closure,16,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-772.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,180,187,"@Override
public void applyAlias() {
    String typeName = typeReference.getString();
    String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
    Preconditions.checkState(typeName.startsWith(aliasName));
    typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));
}"
91,Closure,16,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-772.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,463,482,"private void fixTypeNode(Node typeNode) {
    if (typeNode.isString()) {
        String name = typeNode.getString();
        int endIndex = name.indexOf('.');
        if (endIndex == -1) {
            endIndex = name.length();
        }
        String baseName = name.substring(0, endIndex);
        Var aliasVar = aliases.get(baseName);
        if (aliasVar != null) {
            Node aliasedNode = aliasVar.getInitialValue();
            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));
        }
    }
    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {
        fixTypeNode(child);
    }
}"
92,Closure,17,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-688.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1267,1321,"/**
 * Look for a type declaration on a property assignment
 * (in an ASSIGN or an object literal key).
 *
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                JSType knownType = null;
                if (rValue != null) {
                    JSDocInfo rValueInfo = rValue.getJSDocInfo();
                    if (rValueInfo != null && rValueInfo.hasType()) {
                        // If rValue has a type-cast, we use the type in the type-cast.
                        return rValueInfo.getType().evaluate(scope, typeRegistry);
                    } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}"
93,Closure,18,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-768.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1240,1362,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        hoistExterns(externsRoot);
        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement()) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        hoistNoCompileFiles();
        if (staleInputs) {
            repartitionInputs();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}"
94,Closure,19,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-769.json,Medium,src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,157,180,"/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */
protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        case Token.THIS:
            // ""this"" references aren't currently modeled in the CFG.
            break;
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}"
95,Closure,20,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-759.json,Medium,src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,208,231,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
        // Fold String(a) to '' + (a) on immutable literals,
        // which allows further optimizations
        // 
        // We can't do this in the general case, because String(a) has
        // slightly different semantics than '' + (a). See
        // http://code.google.com/p/closure-compiler/issues/detail?id=759
        Node value = callTarget.getNext();
        if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) {
            Node addition = IR.add(IR.string("""").srcref(callTarget), value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}"
96,Closure,21,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-753.json,Medium,src/com/google/javascript/jscomp/CheckSideEffects.java,83,131,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // so we'll allow it.
    if (n.isEmpty() || n.isComma()) {
        return;
    }
    if (parent == null) {
        return;
    }
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult() || n.isBlock()) {
        return;
    }
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        // try to protect side-effect free statements as well.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}"
97,Closure,22,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-753.json,Medium,src/com/google/javascript/jscomp/CheckSideEffects.java,83,131,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // so we'll allow it.
    if (n.isEmpty() || n.isComma()) {
        return;
    }
    if (parent == null) {
        return;
    }
    // fix up the tree in more clever ways when these are removed.
    if (n.isExprResult() || n.isBlock()) {
        return;
    }
    // be attached to the name. This check should not complain about it.
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
    }
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        // try to protect side-effect free statements as well.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}"
98,Closure,23,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-747.json,Medium,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,1422,1478,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // ""[][0] += 1""
    if (isAssignmentTarget(n)) {
        return n;
    }
    if (!right.isNumber()) {
        // arrays, or strings to index into array methods.
        return n;
    }
    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
        error(INVALID_GETELEM_INDEX_ERROR, right);
        return n;
    }
    if (intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
    Node current = left.getFirstChild();
    Node elem = null;
    for (int i = 0; current != null; i++) {
        if (i != intIndex) {
            if (mayHaveSideEffects(current)) {
                return n;
            }
        } else {
            elem = current;
        }
        current = current.getNext();
    }
    if (elem == null) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
    if (elem.isEmpty()) {
        elem = NodeUtil.newUndefinedNode(elem);
    } else {
        left.removeChild(elem);
    }
    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}"
99,Closure,24,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-737.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,272,298,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) {
            String name = n.getString();
            Var aliasVar = scope.getVar(name);
            aliases.put(name, aliasVar);
            String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
            transformation.addAlias(name, qualifiedName);
        } else if (v.isBleedingFunction()) {
        // Bleeding functions already get a BAD_PARAMETERS error, so just
        // do nothing.
        } else if (parent.getType() == Token.LP) {
        // Parameters of the scope function also get a BAD_PARAMETERS
        // error.
        } else {
            // TODO(robbyw): Support using locals for private variables.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}"
100,Closure,25,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-729.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,1035,1061,"private FlowScope traverseNew(Node n, FlowScope scope) {
    scope = traverseChildren(n, scope);
    Node constructor = n.getFirstChild();
    JSType constructorType = constructor.getJSType();
    JSType type = null;
    if (constructorType != null) {
        constructorType = constructorType.restrictByNotNullOrUndefined();
        if (constructorType.isUnknownType()) {
            type = getNativeType(UNKNOWN_TYPE);
        } else {
            FunctionType ct = constructorType.toMaybeFunctionType();
            if (ct == null && constructorType instanceof FunctionType) {
                // If constructorType is a NoObjectType, then toMaybeFunctionType will
                // return null. But NoObjectType implements the FunctionType
                // interface, precisely because it can validly construct objects.
                ct = (FunctionType) constructorType;
            }
            if (ct != null && ct.isConstructor()) {
                type = ct.getInstanceType();
                backwardsInferenceFromCallSite(n, ct);
            }
        }
    }
    n.setJSType(type);
    return scope;
}"
101,Closure,26,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-732.json,Medium,src/com/google/javascript/jscomp/ProcessCommonJSModules.java,206,219,"/**
 * Emit <code>if (moduleName.module$exports) {
 *    moduleName = moduleName.module$export;
 * }</code> at end of file.
 */
private void emitOptionalModuleExportsOverride(Node script, String moduleName) {
    if (!modulesWithExports.contains(moduleName)) {
        return;
    }
    Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(""module$exports""));
    script.addChildToBack(IR.ifNode(moduleExportsProp, IR.block(IR.exprResult(IR.assign(IR.name(moduleName), moduleExportsProp.cloneTree())))).copyInformationFromForTree(script));
}"
102,Closure,26,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-732.json,Medium,src/com/google/javascript/jscomp/ProcessCommonJSModules.java,224,233,"/**
 * Rewrite module.exports to moduleName.module$exports.
 */
private void visitModuleExports(Node prop) {
    String moduleName = guessCJSModuleName(prop.getSourceFileName());
    Node module = prop.getChildAtIndex(0);
    module.putProp(Node.ORIGINALNAME_PROP, ""module"");
    module.setString(moduleName);
    Node exports = prop.getChildAtIndex(1);
    exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
    exports.setString(""module$exports"");
    modulesWithExports.add(moduleName);
}"
103,Closure,27,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-727.json,Medium,src/com/google/javascript/rhino/IR.java,111,113,"private static Node blockUnchecked(Node stmt) {
    return new Node(Token.BLOCK, stmt);
}"
104,Closure,27,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-727.json,Medium,src/com/google/javascript/rhino/IR.java,226,231,"public static Node tryFinally(Node tryBody, Node finallyBody) {
    Preconditions.checkState(tryBody.isBlock());
    Preconditions.checkState(finallyBody.isBlock());
    Node catchBody = block().copyInformationFrom(tryBody);
    return new Node(Token.TRY, tryBody, catchBody, finallyBody);
}"
105,Closure,27,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-727.json,Medium,src/com/google/javascript/rhino/IR.java,233,238,"public static Node tryCatch(Node tryBody, Node catchNode) {
    Preconditions.checkState(tryBody.isBlock());
    Preconditions.checkState(catchNode.isCatch());
    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);
    return new Node(Token.TRY, tryBody, catchBody);
}"
106,Closure,28,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-728.json,Medium,src/com/google/javascript/jscomp/InlineCostEstimator.java,102,105,"/**
 * Constants (true, false, null) are considered basically free,
 * because it's likely that they will get folded when we're done.
 */
@Override
void addConstant(String newcode) {
    add(""0"");
}"
107,Closure,29,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-724.json,High,src/com/google/javascript/jscomp/InlineObjectLiterals.java,155,250,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        // 
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            // 
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}"
108,Closure,30,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-698.json,Medium,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,155,158,"@Override
public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);
}"
109,Closure,30,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-698.json,Medium,src/com/google/javascript/jscomp/MustBeReachingVariableDef.java,392,407,"/**
 * Computes all the local variables that rValue reads from and store that
 * in the def's depends set.
 */
private void computeDependence(final Definition def, Node rValue) {
    NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName()) {
                Var dep = jsScope.getVar(n.getString());
                if (dep == null) {
                    def.unknownDependencies = true;
                } else {
                    def.depends.add(dep);
                }
            }
        }
    });
}"
110,Closure,30,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-698.json,Medium,src/com/google/javascript/jscomp/MustBeReachingVariableDef.java,395,405,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isName()) {
        Var dep = jsScope.getVar(n.getString());
        if (dep == null) {
            def.unknownDependencies = true;
        } else {
            def.depends.add(dep);
        }
    }
}"
111,Closure,30,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-698.json,Medium,src/com/google/javascript/jscomp/MustBeReachingVariableDef.java,430,445,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
    FlowState<MustDef> state = n.getAnnotation();
    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
    if (def.unknownDependencies) {
        return true;
    }
    for (Var s : def.depends) {
        if (s.scope != jsScope) {
            return true;
        }
    }
    return false;
}"
112,Closure,31,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-703.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1236,1386,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;
        // Check if the sources need to be re-ordered.
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }
            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);
                    input.getModule().remove(input);
                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }
        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}"
113,Closure,32,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-701.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,1328,1441,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.
    int lineStartChar = -1;
    do {
        switch(token) {
            case STAR:
                if (ignoreStar) {
                    // Mark the position after the star as the new start of the line.
                    lineStartChar = stream.getCharno() + 1;
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                lineStartChar = 0;
                token = next();
                continue;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                boolean isEOC = token == JsDocToken.EOC;
                if (!isEOC) {
                    if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
                        int numSpaces = stream.getCharno() - lineStartChar;
                        for (int i = 0; i < numSpaces; i++) {
                            builder.append(' ');
                        }
                        lineStartChar = -1;
                    } else if (builder.length() > 0) {
                        // All tokens must be separated by a space.
                        builder.append(' ');
                    }
                }
                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // in the block are ok.
                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}"
114,Closure,33,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-700.json,Medium,src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,554,583,"@Override
public void matchConstraint(ObjectType constraintObj) {
    // We only want to match contraints on anonymous types.
    if (hasReferenceName()) {
        return;
    }
    // properties on this object.
    if (constraintObj.isRecordType()) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
            JSType propType = constraintObj.getPropertyType(prop);
            if (!isPropertyTypeDeclared(prop)) {
                JSType typeToInfer = propType;
                if (!hasProperty(prop)) {
                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);
                }
                defineInferredProperty(prop, typeToInfer, null);
            }
        }
    }
}"
115,Closure,34,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-691.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,85,730,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, Context.OTHER, 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, Context.OTHER);
                cc.addOp("":"", true);
                addExpr(last, 1, Context.OTHER);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            add(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            add(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isString());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && // were unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}"
116,Closure,34,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-691.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,739,755,"/**
 * We could use addList recursively here, but sometimes we produce
 * very deeply nested operators and run out of stack space, so we
 * just unroll the recursion when possible.
 *
 * We assume nodes are left-recursive.
 */
private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
        firstNonOperator = firstNonOperator.getFirstChild();
    }
    addExpr(firstNonOperator, leftPrecedence, context);
    Node current = firstNonOperator;
    do {
        current = current.getParent();
        cc.addOp(opStr, true);
        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
    } while (current != n);
}"
117,Closure,34,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-691.json,Medium,src/com/google/javascript/jscomp/CodePrinter.java,331,342,"@Override
void appendOp(String op, boolean binOp) {
    if (binOp) {
        if (getLastChar() != ' ' && op.charAt(0) != ',') {
            append("" "");
        }
        append(op);
        append("" "");
    } else {
        append(op);
    }
}"
118,Closure,35,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-669.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,1113,1124,"/**
 * Suppose X is an object with inferred properties.
 * Suppose also that X is used in a way where it would only type-check
 * correctly if some of those properties are widened.
 * Then we should be polite and automatically widen X's properties for him.
 *
 * For a concrete example, consider:
 * param x {{prop: (number|undefined)}}
 * function f(x) {}
 * f({});
 *
 * If we give the anonymous object an inferred property of (number|undefined),
 * then this code will type-check appropriately.
 */
private void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) {
    if (type == null || constraint == null) {
        return;
    }
    ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null) {
        type.matchConstraint(constraintObj);
    }
}"
119,Closure,36,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-668.json,Medium,src/com/google/javascript/jscomp/InlineVariables.java,519,583,"/**
 * @return true if the provided reference and declaration can be safely
 *         inlined according to our criteria
 */
private boolean canInline(Reference declaration, Reference initialization, Reference reference) {
    if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {
        return false;
    }
    // ASSIGN expressions parents do.
    if (declaration != initialization && !initialization.getGrandparent().isExprResult()) {
        return false;
    }
    // scope boundaries
    if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
    }
    // Do not inline into a call node. This would change
    // the context in which it was being called. For example,
    // var a = b.c;
    // a();
    // should not be inlined, because it calls a in the context of b
    // rather than the context of the window.
    // var a = b.c;
    // f(a)
    // is ok.
    Node value = initialization.getAssignedValue();
    Preconditions.checkState(value != null);
    if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
    }
    if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
            CodingConvention convention = compiler.getCodingConvention();
            // Bug 2388531: Don't inline subclass definitions into class defining
            // calls as this confused class removing logic.
            SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);
            if (relationship != null) {
                return false;
            }
            // calls as this confused class removing logic.
            if (convention.getSingletonGetterClassName(callNode) != null) {
                return false;
            }
        }
    }
    return canMoveAggressively(value) || canMoveModerately(initialization, reference);
}"
120,Closure,37,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-663.json,Medium,src/com/google/javascript/jscomp/NodeTraversal.java,510,545,"/**
 * Traverses a function.
 */
private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());
    final Node fnName = n.getFirstChild();
    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);
    if (!isFunctionExpression) {
        // Functions declarations are in the scope containing the declaration.
        traverseBranch(fnName, n);
    }
    curNode = n;
    pushScope(n);
    if (isFunctionExpression) {
        // Function expression names are only accessible within the function
        // scope.
        traverseBranch(fnName, n);
    }
    final Node args = fnName.getNext();
    final Node body = args.getNext();
    // Args
    traverseBranch(args, n);
    // Body
    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);
    traverseBranch(body, n);
    popScope();
}"
121,Closure,37,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-663.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,609,677,"@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    Boolean isUnnamedFunction = false;
    if (name == null) {
        int functionType = functionNode.getFunctionType();
        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
            errorReporter.error(""unnamed function statement"", sourceName, functionNode.getLineno(), """", 0);
            // Return the bare minimum to put the AST in a valid state.
            return newNode(Token.EXPR_RESULT, Node.newNumber(0));
        }
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
        maybeSetLengthFrom(newName, name);
    }
    node.addChildToBack(newName);
    Node lp = newNode(Token.PARAM_LIST);
    // The left paren's complicated because it's not represented by an
    // AstNode, so there's nothing that has the actual line number that it
    // appeared on.  We know the paren has to appear on the same line as the
    // function name (or else a semicolon will be inserted.)  If there's no
    // function name, assume the paren was on the same line as the function.
    // TODO(bowdidge): Mark line number of paren correctly.
    Name fnName = functionNode.getFunctionName();
    if (fnName != null) {
        lp.setLineno(fnName.getLineno());
    } else {
        lp.setLineno(functionNode.getLineno());
    }
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);
    Node bodyNode = transform(functionNode.getBody());
    if (!bodyNode.isBlock()) {
        // When in ideMode Rhino tries to parse some constructs the compiler
        // doesn't support, repair it here. see Rhino's
        // Parser#parseFunctionBodyExpr.
        Preconditions.checkState(config.isIdeMode);
        bodyNode = IR.block();
    }
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    return node;
}"
122,Closure,38,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-657.json,Medium,src/com/google/javascript/jscomp/CodeConsumer.java,240,267,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);
    if ((x < 0 || negativeZero) && prev == '-') {
        add("" "");
    }
    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}"
123,Closure,39,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-643.json,Medium,src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,352,396,"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}"
124,Closure,40,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-284.json,Medium,src/com/google/javascript/jscomp/NameAnalyzer.java,595,640,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // Record global variable and function declarations
    if (t.inGlobalScope()) {
        if (NodeUtil.isVarDeclaration(n)) {
            NameInformation ns = createNameInformation(t, n, parent);
            Preconditions.checkNotNull(ns);
            recordSet(ns.name, n);
        } else if (NodeUtil.isFunctionDeclaration(n)) {
            Node nameNode = n.getFirstChild();
            NameInformation ns = createNameInformation(t, nameNode, n);
            if (ns != null) {
                JsName nameInfo = getName(nameNode.getString(), true);
                recordSet(nameInfo.name, nameNode);
            }
        } else if (NodeUtil.isObjectLitKey(n, parent)) {
            NameInformation ns = createNameInformation(t, n, parent);
            if (ns != null) {
                recordSet(ns.name, n);
            }
        }
    }
    // Record assignments and call sites
    if (n.isAssign()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null) {
            if (ns.isPrototype) {
                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);
            } else {
                recordSet(ns.name, nameNode);
            }
        }
    } else if (n.isCall()) {
        Node nameNode = n.getFirstChild();
        NameInformation ns = createNameInformation(t, nameNode, n);
        if (ns != null && ns.onlyAffectsClassDef) {
            JsName name = getName(ns.name, true);
            refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));
        }
    }
}"
125,Closure,41,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-368.json,Medium,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,242,299,"/**
 * Infer the parameter and return types of a function from
 * the parameter and return types of the function it is overriding.
 *
 * @param oldType The function being overridden. Does nothing if this is null.
 * @param paramsParent The LP node of the function that we're assigning to.
 *     If null, that just means we're not initializing this to a function
 *     literal.
 */
FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
        return this;
    }
    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();
    if (paramsParent == null) {
        // Not a function literal.
        parametersNode = oldType.getParametersNode();
        if (parametersNode == null) {
            parametersNode = new FunctionParamBuilder(typeRegistry).build();
        }
    } else {
        // We're overriding with a function literal. Apply type information
        // to each parameter of the literal.
        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);
        Iterator<Node> oldParams = oldType.getParameters().iterator();
        boolean warnedAboutArgList = false;
        boolean oldParamsListHitOptArgs = false;
        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {
            if (oldParams.hasNext()) {
                Node oldParam = oldParams.next();
                Node newParam = paramBuilder.newParameterFromNode(oldParam);
                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();
                // arguments.
                if (currentParam.getNext() != null && newParam.isVarArgs()) {
                    newParam.setVarArgs(false);
                    newParam.setOptionalArg(true);
                }
            } else {
                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));
            }
        }
        // Clone any remaining params that aren't in the function literal.
        while (oldParams.hasNext()) {
            paramBuilder.newParameterFromNode(oldParams.next());
        }
        parametersNode = paramBuilder.build();
    }
    return this;
}"
126,Closure,41,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-368.json,Medium,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,424,503,"/**
 * Infer the parameter types from the list of argument names and
 * the doc info.
 */
FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {
    if (argsParent == null) {
        if (info == null) {
            return this;
        } else {
            return inferParameterTypes(info);
        }
    }
    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
        oldParameterType = parametersNode.getFirstChild();
    }
    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;
    boolean isVarArgs = false;
    for (Node arg : argsParent.children()) {
        String argumentName = arg.getString();
        allJsDocParams.remove(argumentName);
        // type from JSDocInfo
        JSType parameterType = null;
        boolean isOptionalParam = isOptionalParameter(arg, info);
        isVarArgs = isVarArgsParameter(arg, info);
        if (info != null && info.hasParameterType(argumentName)) {
            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);
        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {
            parameterType = oldParameterType.getJSType();
            isOptionalParam = oldParameterType.isOptionalArg();
            isVarArgs = oldParameterType.isVarArgs();
        } else {
            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
        }
        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
            if (foundTemplateType) {
                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
            }
            foundTemplateType = true;
        }
        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);
        if (oldParameterType != null) {
            oldParameterType = oldParameterType.getNext();
        }
    }
    // Copy over any old parameters that aren't in the param list.
    if (!isVarArgs) {
        while (oldParameterType != null && !isVarArgs) {
            builder.newParameterFromNode(oldParameterType);
            oldParameterType = oldParameterType.getNext();
        }
    }
    if (templateTypeName != null && !foundTemplateType) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    for (String inexistentName : allJsDocParams) {
        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }
    parametersNode = builder.build();
    return this;
}"
127,Closure,42,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-644.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,566,582,"@Override
Node processForInLoop(ForInLoop loopNode) {
    if (loopNode.isForEach()) {
        errorReporter.error(""unsupported language extension: for each"", sourceName, loopNode.getLineno(), """", 0);
        // Return the bare minimum to put the AST in a valid state.
        return newNode(Token.EXPR_RESULT, Node.newNumber(0));
    }
    return newNode(Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));
}"
128,Closure,43,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-314.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,498,555,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    inputId = t.getInputId();
    attachLiteralTypes(t, n);
    switch(n.getType()) {
        case Token.CALL:
            checkForClassDefiningCalls(t, n, parent);
            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
            break;
        case Token.FUNCTION:
            if (t.getInput() == null || !t.getInput().isExtern()) {
                nonExternFunctions.add(n);
            }
            // Hoisted functions are handled during pre-traversal.
            if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
                defineFunctionLiteral(n, parent);
            }
            break;
        case Token.ASSIGN:
            // Handle initialization of properties.
            Node firstChild = n.getFirstChild();
            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());
            }
            break;
        case Token.CATCH:
            defineCatch(n, parent);
            break;
        case Token.VAR:
            defineVar(n, parent);
            break;
        case Token.GETPROP:
            // Handle stubbed properties.
            if (parent.isExprResult() && n.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
            }
            break;
    }
    // Analyze any @lends object literals in this statement.
    if (n.getParent() != null && NodeUtil.isStatement(n) && lentObjectLiterals != null) {
        for (Node objLit : lentObjectLiterals) {
            defineObjectLiteral(objLit);
        }
        lentObjectLiterals.clear();
    }
}"
129,Closure,43,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-314.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,557,603,"private void attachLiteralTypes(NodeTraversal t, Node n) {
    switch(n.getType()) {
        case Token.NULL:
            n.setJSType(getNativeType(NULL_TYPE));
            break;
        case Token.VOID:
            n.setJSType(getNativeType(VOID_TYPE));
            break;
        case Token.STRING:
            // Defer keys to the Token.OBJECTLIT case
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                n.setJSType(getNativeType(STRING_TYPE));
            }
            break;
        case Token.NUMBER:
            n.setJSType(getNativeType(NUMBER_TYPE));
            break;
        case Token.TRUE:
        case Token.FALSE:
            n.setJSType(getNativeType(BOOLEAN_TYPE));
            break;
        case Token.REGEXP:
            n.setJSType(getNativeType(REGEXP_TYPE));
            break;
        case Token.OBJECTLIT:
            JSDocInfo info = n.getJSDocInfo();
            if (info != null && info.getLendsName() != null) {
                if (lentObjectLiterals == null) {
                    lentObjectLiterals = Lists.newArrayList();
                }
                lentObjectLiterals.add(n);
            } else {
                defineObjectLiteral(n);
            }
            break;
    }
}"
130,Closure,44,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-620.json,Medium,src/com/google/javascript/jscomp/CodeConsumer.java,181,204,"void add(String newcode) {
    maybeEndStatement();
    if (newcode.length() == 0) {
        return;
    }
    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
        // need space to separate. This is not pretty printing.
        // For example: ""return foo;""
        append("" "");
    } else if (c == '/' && getLastChar() == '/') {
        // Do not allow a forward slash to appear after a DIV.
        // For example,
        // REGEXP DIV REGEXP
        // is valid and should print like
        // / // / /
        append("" "");
    }
    append(newcode);
}"
131,Closure,45,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-618.json,High,src/com/google/javascript/jscomp/RemoveUnusedVars.java,704,753,"/**
 * Look at all the property assigns to all variables.
 * These may or may not count as references. For example,
 *
 * <code>
 * var x = {};
 * x.foo = 3; // not a reference.
 * var y = foo();
 * y.foo = 3; // is a reference.
 * </code>
 *
 * Interpreting assignments could mark a variable as referenced that
 * wasn't referenced before, in order to keep it alive. Because we find
 * references by lazily traversing subtrees, marking a variable as
 * referenced could trigger new traversals of new subtrees, which could
 * find new references.
 *
 * Therefore, this interpretation needs to be run to a fixed point.
 */
private void interpretAssigns() {
    boolean changes = false;
    do {
        changes = false;
        // we traverse it.
        for (int current = 0; current < maybeUnreferenced.size(); current++) {
            Var var = maybeUnreferenced.get(current);
            if (referenced.contains(var)) {
                maybeUnreferenced.remove(current);
                current--;
            } else {
                boolean assignedToUnknownValue = false;
                boolean hasPropertyAssign = false;
                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {
                    Node value = var.getInitialValue();
                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);
                } else {
                    // This was initialized to a function arg or a catch param
                    // or a for...in variable.
                    assignedToUnknownValue = true;
                }
                boolean maybeEscaped = false;
                for (Assign assign : assignsByVar.get(var)) {
                    if (assign.isPropertyAssign) {
                        hasPropertyAssign = true;
                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {
                        assignedToUnknownValue = true;
                    }
                    if (assign.maybeAliased) {
                        maybeEscaped = true;
                    }
                }
                if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
                    changes = markReferencedVar(var) || changes;
                    maybeUnreferenced.remove(current);
                    current--;
                }
            }
        }
    } while (changes);
}"
132,Closure,47,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-575.json,Medium,src/com/google/debugging/sourcemap/SourceMapConsumerV3.java,482,496,"/**
 * Creates an ""OriginalMapping"" object for the given entry object.
 */
private OriginalMapping getOriginalMappingForEntry(Entry entry) {
    if (entry.getSourceFileId() == UNMAPPED) {
        return null;
    } else {
        // Adjust the line/column here to be start at 1.
        Builder x = OriginalMapping.newBuilder().setOriginalFile(sources[entry.getSourceFileId()]).setLineNumber(entry.getSourceLine() + 1).setColumnPosition(entry.getSourceColumn() + 1);
        if (entry.getNameId() != UNMAPPED) {
            x.setIdentifier(names[entry.getNameId()]);
        }
        return x.build();
    }
}"
133,Closure,47,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-575.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,117,148,"public void addMapping(Node node, FilePosition outputStartPosition, FilePosition outputEndPosition) {
    String sourceFile = node.getSourceFileName();
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    sourceFile = fixupSourceLocation(sourceFile);
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    // Strangely, Rhino source lines are one based but columns are
    // zero based.
    // We don't change this for the v1 or v2 source maps but for
    // v3 we make them both 0 based.
    int lineBaseOffset = 1;
    if (generator instanceof SourceMapGeneratorV1 || generator instanceof SourceMapGeneratorV2) {
        lineBaseOffset = 0;
    }
    generator.addMapping(sourceFile, originalName, new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition);
}"
134,Closure,48,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-586.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1416,1564,"/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
    // Precedence of type information on GETPROPs:
    // 1) @type annnotation / @enum annotation
    // 2) ASSIGN to FUNCTION literal
    // 3) @param/@return annotation (with no function literal)
    // 4) ASSIGN to something marked @const
    // 5) ASSIGN to anything else
    // 
    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
    // the function has jsdoc or has not been declared before.
    // 
    // FUNCTION literals are special because TypedScopeCreator is very smart
    // about getting as much type information as possible for them.
    // Determining type for #1 + #2 + #3 + #4
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
    }
    // allow F.prototype to be redefined arbitrarily.
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to an object literal,
            // then they are responsible for making sure that the object literal's
            // implicit prototype is set up appropriately. We just obey
            // the @extends tag.
            ObjectType qVarType = ObjectType.cast(qVar.getType());
            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {
                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());
            } else if (!qVar.isTypeInferred()) {
                // what props are going to be on that prototype.
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.isExprResult()) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    // NOTE(nicksantos): Determining whether a property is declared or not
    // is really really obnoxious.
    // 
    // The problem is that there are two (equally valid) coding styles:
    // 
    // (function() {
    // /* The authoritative definition of goog.bar. */
    // goog.bar = function() {};
    // })();
    // 
    // function f() {
    // goog.bar();
    // /* Reset goog.bar to a no-op. */
    // goog.bar = function() {};
    // }
    // 
    // In a dynamic language with first-class functions, it's very difficult
    // to know which one the user intended without looking at lots of
    // contextual information (the second example demonstrates a small case
    // of this, but there are some really pathological cases as well).
    // 
    // The current algorithm checks if either the declaration has
    // jsdoc type information, or @const with a known type,
    // or a function literal with a name we haven't seen before.
    boolean inferred = true;
    if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        // Determining declaration for #2
        if (info != null) {
            inferred = false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            inferred = false;
        }
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            // Only declare this as an official property if it has not been
            // declared yet.
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                // If the property is undeclared or inferred, declare it now.
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.isTrue()) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}"
135,Closure,49,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-539.json,Low,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,75,96,"@Override
public void enterScope(NodeTraversal t) {
    Node declarationRoot = t.getScopeRoot();
    Renamer renamer;
    if (nameStack.isEmpty()) {
        // If the contextual renamer is being used the starting context can not
        // be a function.
        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));
        Preconditions.checkState(t.inGlobalScope());
        renamer = rootRenamer;
    } else {
        renamer = nameStack.peek().forChildScope();
    }
    if (declarationRoot.getType() != Token.FUNCTION) {
        // Add the block declarations
        findDeclaredNames(declarationRoot, null, renamer);
    }
    nameStack.push(renamer);
}"
136,Closure,49,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-539.json,Low,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,105,156,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.FUNCTION:
            {
                // Add recursive function name, if needed.
                // NOTE: ""enterScope"" is called after we need to pick up this name.
                Renamer renamer = nameStack.peek().forChildScope();
                // If needed, add the function recursive name.
                String name = n.getFirstChild().getString();
                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {
                    renamer.addDeclaredName(name);
                }
                nameStack.push(renamer);
            }
            break;
        case Token.LP:
            {
                Renamer renamer = nameStack.peek().forChildScope();
                // Add the function parameters
                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                    String name = c.getString();
                    renamer.addDeclaredName(name);
                }
                // Add the function body declarations
                Node functionBody = n.getNext();
                findDeclaredNames(functionBody, null, renamer);
                nameStack.push(renamer);
            }
            break;
        case Token.CATCH:
            {
                Renamer renamer = nameStack.peek().forChildScope();
                String name = n.getFirstChild().getString();
                renamer.addDeclaredName(name);
                nameStack.push(renamer);
            }
            break;
    }
    return true;
}"
137,Closure,49,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-539.json,Low,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,158,192,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.NAME:
            String newName = getReplacementName(n.getString());
            if (newName != null) {
                Renamer renamer = nameStack.peek();
                if (renamer.stripConstIfReplaced()) {
                    // TODO(johnlenz): Do we need to do anything about the javadoc?
                    n.removeProp(Node.IS_CONSTANT_NAME);
                }
                n.setString(newName);
                t.getCompiler().reportCodeChange();
            }
            break;
        case Token.FUNCTION:
            // Remove the function body scope
            nameStack.pop();
            // Remove function recursive name (if any).
            nameStack.pop();
            break;
        case Token.LP:
            // visit of LP, but remove it when when we exit the function above.
            break;
        case Token.CATCH:
            // Remove catch except name from the stack of names.
            nameStack.pop();
            break;
    }
}"
138,Closure,50,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-558.json,Low,src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java,367,481,"/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
private Node tryFoldArrayJoin(Node n) {
    Node callTarget = n.getFirstChild();
    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
        return n;
    }
    Node right = callTarget.getNext();
    if (right != null) {
        if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {
            return n;
        }
    }
    Node arrayNode = callTarget.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return n;
    }
    if (right != null && right.getType() == Token.STRING && "","".equals(right.getString())) {
        // "","" is the default, it doesn't need to be explicit
        n.removeChild(right);
        reportCodeChange();
    }
    String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node prev = null;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getArrayElementStringValue(elem));
        } else {
            if (sb != null) {
                Preconditions.checkNotNull(prev);
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
                sb = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        prev = elem;
        elem = elem.getNext();
    }
    if (sb != null) {
        Preconditions.checkNotNull(prev);
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            n.getParent().replaceChild(n, emptyStringNode);
            reportCodeChange();
            return emptyStringNode;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD, Node.newString("""").copyInformationFrom(n), foldedStringNode);
                foldedStringNode = replacement;
            }
            n.getParent().replaceChild(n, foldedStringNode);
            reportCodeChange();
            return foldedStringNode;
        default:
            // No folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return n;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
            if (foldedSize > originalSize) {
                return n;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            reportCodeChange();
            break;
    }
    return n;
}"
139,Closure,51,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-582.json,Medium,src/com/google/javascript/jscomp/CodeConsumer.java,233,259,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    if (x < 0 && prev == '-') {
        add("" "");
    }
    if ((long) x == x && !isNegativeZero(x)) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}"
140,Closure,51,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-582.json,Medium,src/com/google/javascript/jscomp/CodeConsumer.java,261,263,"static boolean isNegativeZero(double x) {
    return x == 0.0 && Math.copySign(1, x) == -1.0;
}"
141,Closure,52,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-569.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,737,746,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len > 0 && s.charAt(0) != '0';
}"
142,Closure,53,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-545.json,Medium,src/com/google/javascript/jscomp/InlineObjectLiterals.java,303,364,"/**
 * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.
 * Note that the resulting expression will always evaluate to
 * true, as would the x = {...} expression.
 */
private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
    }
    // TODO(user): Better source information.
    for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }
    Node replacement;
    if (nodes.isEmpty()) {
        replacement = new Node(Token.TRUE);
    } else {
        // All assignments evaluate to true, so make sure that the
        // expr statement evaluates to true in case it matters.
        nodes.add(new Node(Token.TRUE));
        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
            cur.addChildToFront(nodes.get(i));
            Node t = new Node(Token.COMMA);
            cur.addChildToFront(t);
            cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));
    }
    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);
    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}"
143,Closure,54,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-537.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1373,1495,"/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
    // Precedence of type information on GETPROPs:
    // 1) @type annnotation / @enum annotation
    // 2) ASSIGN to FUNCTION literal
    // 3) @param/@return annotation (with no function literal)
    // 4) ASSIGN to something marked @const
    // 5) ASSIGN to anything else
    // 
    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
    // the function has jsdoc or has not been declared before.
    // 
    // FUNCTION literals are special because TypedScopeCreator is very smart
    // about getting as much type information as possible for them.
    // Determining type for #1 + #2 + #3 + #4
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
    }
    // allow F.prototype to be redefined arbitrarily.
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            // If the programmer has declared that F inherits from Super,
            // and they assign F.prototype to an object literal,
            // then they are responsible for making sure that the object literal's
            // implicit prototype is set up appropriately. We just obey
            // the @extends tag.
            ObjectType qVarType = ObjectType.cast(qVar.getType());
            if (qVarType != null && rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) {
                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());
            } else if (!qVar.isTypeInferred()) {
                // what props are going to be on that prototype.
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    boolean inferred = true;
    if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            // Only declare this as an official property if it has not been
            // declared yet.
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                // If the property is undeclared or inferred, declare it now.
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}"
144,Closure,54,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-537.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,322,349,"/**
 * Sets the prototype, creating the prototype object from the given
 * base type.
 * @param baseType The base type.
 */
public void setPrototypeBasedOn(ObjectType baseType) {
    // In the second case, we just use the anonymous object as the prototype.
    if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {
        baseType = new PrototypeObjectType(registry, this.getReferenceName() + "".prototype"", baseType);
    }
    setPrototype((PrototypeObjectType) baseType);
}"
145,Closure,54,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-537.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,356,398,"/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */
public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
        return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    PrototypeObjectType oldPrototype = this.prototype;
    boolean replacedPrototype = oldPrototype != null;
    this.prototype = prototype;
    this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
    this.prototype.setOwnerFunction(this);
    if (oldPrototype != null) {
        // Disassociating the old prototype makes this easier to debug--
        // we don't have to worry about two prototypes running around.
        oldPrototype.setOwnerFunction(null);
    }
    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }
        if (isInterface()) {
            for (ObjectType interfaceType : getExtendedInterfaces()) {
                if (interfaceType.getConstructor() != null) {
                    interfaceType.getConstructor().addSubType(this);
                }
            }
        }
    }
    if (replacedPrototype) {
        clearCachedValues();
    }
    return true;
}"
146,Closure,55,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-538.json,Medium,src/com/google/javascript/jscomp/FunctionRewriter.java,116,119,"private static boolean isReduceableFunctionExpression(Node n) {
    return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent());
}"
147,Closure,56,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-511.json,Medium,src/com/google/javascript/jscomp/SourceFile.java,205,250,"/**
 * Gets the source line for the indicated line number.
 *
 * @param lineNumber the line number, 1 being the first line of the file.
 * @return The line indicated. Does not include the newline at the end
 *     of the file. Returns {@code null} if it does not exist,
 *     or if there was an IO exception.
 */
public String getLine(int lineNumber) {
    String js = """";
    try {
        // NOTE(nicksantos): Right now, this is optimized for few warnings.
        // This is probably the right trade-off, but will be slow if there
        // are lots of warnings in one file.
        js = getCode();
    } catch (IOException e) {
        return null;
    }
    int pos = 0;
    int startLine = 1;
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
        pos = lastOffset;
        startLine = lastLine;
    }
    for (int n = startLine; n < lineNumber; n++) {
        int nextpos = js.indexOf('\n', pos);
        if (nextpos == -1) {
            return null;
        }
        pos = nextpos + 1;
    }
    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;
    if (js.indexOf('\n', pos) == -1) {
        // 2. otherwise, return the contents between pos and the end of file.
        if (pos >= js.length()) {
            return null;
        } else {
            return js.substring(pos, js.length());
        }
    } else {
        return js.substring(pos, js.indexOf('\n', pos));
    }
}"
148,Closure,57,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-530.json,Medium,src/com/google/javascript/jscomp/ClosureCodingConvention.java,188,204,"private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = callee.getNext();
                if (target != null && target.getType() == Token.STRING) {
                    className = target.getString();
                }
            }
        }
    }
    return className;
}"
149,Closure,58,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-528.json,Medium,src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,178,267,"/**
 * Computes the GEN and KILL set.
 *
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at
 *        {@code n} will be added to this set.
 * @param kill Local variables that are killed because of the instruction at
 *        {@code n} will be added to this set.
 * @param conditional {@code true} if any assignments encountered are
 *        conditionally executed. These assignments might not kill a variable.
 */
private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {
    switch(n.getType()) {
        case Token.SCRIPT:
        case Token.BLOCK:
        case Token.FUNCTION:
            return;
        case Token.WHILE:
        case Token.DO:
        case Token.IF:
            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            return;
        case Token.FOR:
            if (!NodeUtil.isForIn(n)) {
                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);
            } else {
                // for(x in y) {...}
                Node lhs = n.getFirstChild();
                Node rhs = lhs.getNext();
                if (NodeUtil.isVar(lhs)) {
                    // for(var x in y) {...}
                    lhs = lhs.getLastChild();
                }
                if (NodeUtil.isName(lhs)) {
                    addToSetIfLocal(lhs, kill);
                    addToSetIfLocal(lhs, gen);
                } else {
                    computeGenKill(lhs, gen, kill, conditional);
                }
                computeGenKill(rhs, gen, kill, conditional);
            }
            return;
        case Token.VAR:
            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                if (c.hasChildren()) {
                    computeGenKill(c.getFirstChild(), gen, kill, conditional);
                    if (!conditional) {
                        addToSetIfLocal(c, kill);
                    }
                }
            }
            return;
        case Token.AND:
        case Token.OR:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // May short circuit.
            computeGenKill(n.getLastChild(), gen, kill, true);
            return;
        case Token.HOOK:
            computeGenKill(n.getFirstChild(), gen, kill, conditional);
            // Assume both sides are conditional.
            computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
            computeGenKill(n.getLastChild(), gen, kill, true);
            return;
        case Token.NAME:
            if (isArgumentsName(n)) {
                markAllParametersEscaped();
            } else {
                addToSetIfLocal(n, gen);
            }
            return;
        default:
            if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
                Node lhs = n.getFirstChild();
                if (!conditional) {
                    addToSetIfLocal(lhs, kill);
                }
                if (!NodeUtil.isAssign(n)) {
                    // assignments such as a += 1 reads a.
                    addToSetIfLocal(lhs, gen);
                }
                computeGenKill(lhs.getNext(), gen, kill, conditional);
            } else {
                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
                    computeGenKill(c, gen, kill, conditional);
                }
            }
            return;
    }
}"
150,Closure,59,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-521.json,Medium,src/com/google/javascript/jscomp/Compiler.java,226,289,"/**
 * Initialize the compiler options. Only necessary if you're not doing
 * a normal compile() job.
 */
public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }
    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }
    if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }
    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
    }
    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());
    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);
    // error off.
    if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }
    this.warningsGuard = composedGuards;
}"
151,Closure,60,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-504.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,74,114,"/**
 * Gets the boolean value of a node that represents a expression. This method
 * effectively emulates the <code>Boolean()</code> JavaScript cast function.
 * Note: unlike getBooleanValue this function does not return UNKNOWN
 * for expressions with side-effects.
 */
static TernaryValue getImpureBooleanValue(Node n) {
    switch(n.getType()) {
        case Token.ASSIGN:
        case Token.COMMA:
            // For ASSIGN and COMMA the value is the value of the RHS.
            return getImpureBooleanValue(n.getLastChild());
        case Token.NOT:
            TernaryValue value = getImpureBooleanValue(n.getLastChild());
            return value.not();
        case Token.AND:
            {
                TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
                TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
                return lhs.and(rhs);
            }
        case Token.OR:
            {
                TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
                TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
                return lhs.or(rhs);
            }
        case Token.HOOK:
            {
                TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());
                TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
                if (trueValue.equals(falseValue)) {
                    return trueValue;
                } else {
                    return TernaryValue.UNKNOWN;
                }
            }
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // ignoring side-effects
            return TernaryValue.TRUE;
        case Token.VOID:
            return TernaryValue.FALSE;
        default:
            return getPureBooleanValue(n);
    }
}"
152,Closure,60,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-504.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,122,168,"/**
 * Gets the boolean value of a node that represents a literal. This method
 * effectively emulates the <code>Boolean()</code> JavaScript cast function
 * except it return UNKNOWN for known values with side-effects, use
 * getExpressionBooleanValue if you don't care about side-effects.
 */
static TernaryValue getPureBooleanValue(Node n) {
    switch(n.getType()) {
        case Token.STRING:
            return TernaryValue.forBoolean(n.getString().length() > 0);
        case Token.NUMBER:
            return TernaryValue.forBoolean(n.getDouble() != 0);
        case Token.NOT:
            return getPureBooleanValue(n.getLastChild()).not();
        case Token.NULL:
        case Token.FALSE:
            return TernaryValue.FALSE;
        case Token.VOID:
            if (!mayHaveSideEffects(n.getFirstChild())) {
                return TernaryValue.FALSE;
            }
            break;
        case Token.NAME:
            String name = n.getString();
            if (""undefined"".equals(name) || ""NaN"".equals(name)) {
                // undefined to something other than the value undefined.
                return TernaryValue.FALSE;
            } else if (""Infinity"".equals(name)) {
                return TernaryValue.TRUE;
            }
            break;
        case Token.TRUE:
        case Token.REGEXP:
            return TernaryValue.TRUE;
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            if (!mayHaveSideEffects(n)) {
                return TernaryValue.TRUE;
            }
            break;
    }
    return TernaryValue.UNKNOWN;
}"
153,Closure,61,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-501.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,926,982,"/**
 * Returns true if calls to this function have side effects.
 *
 * @param callNode The call node to inspected.
 * @param compiler A compiler object to provide program state changing
 *     context information. Can be null.
 */
static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
        throw new IllegalStateException(""Expected CALL node, got "" + Token.name(callNode.getType()));
    }
    if (callNode.isNoSideEffectsCall()) {
        return false;
    }
    Node nameNode = callNode.getFirstChild();
    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
        String name = nameNode.getString();
        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }
    } else if (nameNode.getType() == Token.GETPROP) {
        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {
            return false;
        }
        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {
            return false;
        }
        // Functions in the ""Math"" namespace have no side effects.
        if (nameNode.getFirstChild().getType() == Token.NAME) {
            String namespaceName = nameNode.getFirstChild().getString();
            if (namespaceName.equals(""Math"")) {
                return false;
            }
        }
        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                return false;
            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                Node param = nameNode.getNext();
                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))
                    return false;
            }
        }
    }
    return true;
}"
154,Closure,62,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-487.json,Medium,src/com/google/javascript/jscomp/LightweightMessageFormatter.java,66,111,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);
    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
        b.append(error.sourceName);
        if (error.lineNumber > 0) {
            b.append(':');
            b.append(error.lineNumber);
        }
        b.append("": "");
    }
    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");
    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
        b.append(sourceExcerpt);
        b.append('\n');
        int charno = error.getCharno();
        // at the end of the line
        if (excerpt.equals(LINE) && 0 <= charno && charno <= sourceExcerpt.length()) {
            for (int i = 0; i < charno; i++) {
                char c = sourceExcerpt.charAt(i);
                if (Character.isWhitespace(c)) {
                    b.append(c);
                } else {
                    b.append(' ');
                }
            }
            b.append(""^\n"");
        }
    }
    return b.toString();
}"
155,Closure,64,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-489.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1393,1452,"/**
 * Writes out js code from a root node. If printing input delimiters, this
 * method will attach a comment to the start of the text indicating which
 * input the output derived from. If there were any preserve annotations
 * within the root's source, they will also be printed in a block comment
 * at the beginning of the output.
 */
public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
    runInCompilerThread(new Callable<Void>() {

        public Void call() throws Exception {
            if (options.printInputDelimiter) {
                if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
                    // Make sure that the label starts on a new line
                    cb.append(""\n"");
                }
                Preconditions.checkState(root.getType() == Token.SCRIPT);
                String delimiter = options.inputDelimiter;
                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
                Preconditions.checkState(sourceName != null);
                Preconditions.checkState(!sourceName.isEmpty());
                delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
                cb.append(delimiter).append(""\n"");
            }
            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
                cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
            }
            // root node's mappings are offset by the given string builder buffer.
            if (options.sourceMapOutputPath != null) {
                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
            }
            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
            // for the first input file
            String code = toSource(root, sourceMap, inputSeqNum == 0);
            if (!code.isEmpty()) {
                cb.append(code);
                // In order to avoid parse ambiguity when files are concatenated
                // together, all files should end in a semi-colon. Do a quick
                // heuristic check if there's an obvious semi-colon already there.
                int length = code.length();
                char lastChar = code.charAt(length - 1);
                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
                boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
                if (!hasSemiColon) {
                    cb.append("";"");
                }
            }
            return null;
        }
    });
}"
156,Closure,64,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-489.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1397,1450,"public Void call() throws Exception {
    if (options.printInputDelimiter) {
        if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
            // Make sure that the label starts on a new line
            cb.append(""\n"");
        }
        Preconditions.checkState(root.getType() == Token.SCRIPT);
        String delimiter = options.inputDelimiter;
        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
        Preconditions.checkState(sourceName != null);
        Preconditions.checkState(!sourceName.isEmpty());
        delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
        cb.append(delimiter).append(""\n"");
    }
    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
        cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
    }
    // root node's mappings are offset by the given string builder buffer.
    if (options.sourceMapOutputPath != null) {
        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
    }
    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
    // for the first input file
    String code = toSource(root, sourceMap, inputSeqNum == 0);
    if (!code.isEmpty()) {
        cb.append(code);
        // In order to avoid parse ambiguity when files are concatenated
        // together, all files should end in a semi-colon. Do a quick
        // heuristic check if there's an obvious semi-colon already there.
        int length = code.length();
        char lastChar = code.charAt(length - 1);
        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
        boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
        if (!hasSemiColon) {
            cb.append("";"");
        }
    }
    return null;
}"
157,Closure,64,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-489.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1458,1462,"/**
 * Generates JavaScript source code for an AST, doesn't generate source
 * map info.
 */
@Override
String toSource(Node n) {
    initCompilerOptionsIfTesting();
    return toSource(n, null, true);
}"
158,Closure,64,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-489.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1467,1482,"/**
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    builder.setTagAsStrict(firstOutput && options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
    builder.setLineLengthThreshold(options.lineLengthThreshold);
    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;
    builder.setOutputCharset(charset);
    return builder.build();
}"
159,Closure,65,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-486.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,1005,1075,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\000"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}"
160,Closure,66,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-482.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,461,815,"/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.LP:
            // ignored here.
            if (parent.getType() != Token.FUNCTION) {
                ensureTyped(t, n, getJSType(n.getFirstChild()));
            } else {
                typeable = false;
            }
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.REF_SPECIAL:
            ensureTyped(t, n);
            break;
        case Token.GET_REF:
            ensureTyped(t, n, getJSType(n.getFirstChild()));
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            // Object literal keys are handled with OBJECTLIT
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                ensureTyped(t, n, STRING_TYPE);
            } else {
                // Object literal keys are not typeable
                typeable = false;
            }
            break;
        case Token.GET:
        case Token.SET:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            typeable = true;
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !NodeUtil.isExpressionNode(parent);
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                if (result != TernaryValue.UNKNOWN) {
                    if (n.getType() == Token.NE) {
                        result = result.not();
                    }
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.SHEQ:
        case Token.SHNE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
            // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right);
            validator.expectObject(t, n, rightType, ""'in' requires an object"");
            validator.expectString(t, left, leftType, ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            if (!isReference(n.getFirstChild())) {
                report(t, n, BAD_DELETE);
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.getType() == Token.OBJECTLIT) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}"
161,Closure,67,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-459.json,Medium,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,314,334,"private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP && assign.getParent().getType() == Token.EXPR_RESULT) {
        // We want to exclude the assignment itself from the usage list
        boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;
        if (isChainedProperty) {
            Node child = n.getFirstChild().getFirstChild().getNext();
            if (child.getType() == Token.STRING && child.getString().equals(""prototype"")) {
                return true;
            }
        }
    }
    return false;
}"
162,Closure,68,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-477.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,169,913,"/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                                    // If RETURN doesn't have a type annotation, record
                                    // it as the unknown type.
                                    typeNode = newNode(Token.QMARK);
                                } else {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                }
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                // error reported during recursive descent
                                // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}"
163,Closure,68,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-477.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,1685,1711,"/**
 * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName
 *     | FunctionType | UnionType | RecordType | ArrayType
 */
private Node parseBasicTypeExpression(JsDocToken token) {
    if (token == JsDocToken.STAR) {
        return newNode(Token.STAR);
    } else if (token == JsDocToken.LB) {
        skipEOLs();
        return parseArrayType(next());
    } else if (token == JsDocToken.LC) {
        skipEOLs();
        return parseRecordType(next());
    } else if (token == JsDocToken.LP) {
        skipEOLs();
        return parseUnionType(next());
    } else if (token == JsDocToken.STRING) {
        String string = stream.getString();
        if (""function"".equals(string)) {
            skipEOLs();
            return parseFunctionType(next());
        } else if (""null"".equals(string) || ""undefined"".equals(string)) {
            return newStringNode(string);
        } else {
            return parseTypeName(token);
        }
    }
    restoreLookAhead(token);
    return reportGenericTypeSyntaxWarning();
}"
164,Closure,68,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-477.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,1758,1828,"/**
 * FunctionType := 'function' FunctionSignatureType
 * FunctionSignatureType :=
 *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token) {
    // just throw out TypeParameters.
    if (token != JsDocToken.LP) {
        restoreLookAhead(token);
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
    }
    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        token = next();
        boolean hasParams = true;
        if (token == JsDocToken.STRING) {
            String tokenStr = stream.getString();
            boolean isThis = ""this"".equals(tokenStr);
            boolean isNew = ""new"".equals(tokenStr);
            if (isThis || isNew) {
                if (match(JsDocToken.COLON)) {
                    next();
                    skipEOLs();
                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));
                    if (contextType == null) {
                        return null;
                    }
                    functionType.addChildToFront(contextType);
                } else {
                    return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
                }
                if (match(JsDocToken.COMMA)) {
                    next();
                    skipEOLs();
                    token = next();
                } else {
                    hasParams = false;
                }
            }
        }
        if (hasParams) {
            parameters = parseParametersType(token);
            if (parameters == null) {
                return null;
            }
        }
    }
    if (parameters != null) {
        functionType.addChildToBack(parameters);
    }
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }
    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
        return null;
    } else {
        functionType.addChildToBack(resultType);
    }
    return functionType;
}"
165,Closure,69,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-440.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,1544,1597,"/**
 * Visits a CALL node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();
    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;
        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if (functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            CompilerInput functionSource = compiler.getInput(sourceName);
            isExtern = functionSource.isExtern();
        }
        // in an extern.
        if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
        }
        // or GETELEM.
        if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) {
            report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
        }
        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
// TODO: Add something to check for calls of RegExp objects, which is not
// supported by IE.  Either say something about the return type or warn
// about the non-portability of the call or both.
}"
166,Closure,70,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-433.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1734,1753,"/**
 * Declares all of a function's arguments.
 */
private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                if (jsDocParameter != null) {
                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), false);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        }
    }
}"
167,Closure,71,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-254.json,Medium,src/com/google/javascript/jscomp/CheckAccessControls.java,407,500,"/**
 * Determines whether the given property is visible in the current context.
 * @param t The current traversal.
 * @param getprop The getprop node.
 */
private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {
    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();
    if (objectType != null) {
        // Is this a normal property access, or are we trying to override
        // an existing property?
        boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
        // information.
        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        JSDocInfo docInfo = null;
        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
        }
        if (objectType == null) {
            // We couldn't find a visibility modifier; assume it's public.
            return;
        }
        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            // Check an ASSIGN statement that's trying to override a property
            // on a superclass.
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();
            // visibility of the original property.
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {
                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                // private access is always allowed in the same file.
                return;
            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                // private access is not allowed outside the file from a different
                // enclosing class.
                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                // The first two have already been checked for.
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
                }
            }
        }
    }
}"
168,Closure,72,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-435.json,Medium,src/com/google/javascript/jscomp/FunctionToBlockMutator.java,142,154,"/**
 * Fix-up all local names to be unique for this subtree.
 * @param fnNode A mutable instance of the function to be inlined.
 */
private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();
    // Make variable names unique to this instance.
    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, ""inline_"", isCallInLoop)));
    // Make label names unique to this instance.
    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false).process(null, fnNode);
}"
169,Closure,72,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-435.json,Medium,src/com/google/javascript/jscomp/RenameLabels.java,209,235,"/**
 * Rename or remove labels.
 * @param node  The label node.
 * @param parent The parent of the label node.
 */
private void visitLabel(Node node, Node parent) {
    Node nameNode = node.getFirstChild();
    Preconditions.checkState(nameNode != null);
    String name = nameNode.getString();
    LabelInfo li = getLabelInfo(name);
    // This is a label...
    if (li.referenced || !removeUnused) {
        String newName = getNameForId(li.id);
        if (!name.equals(newName)) {
            // ... and it is used, give it the short name.
            nameNode.setString(newName);
            compiler.reportCodeChange();
        }
    } else {
        // ... and it is not referenced, just remove it.
        Node newChild = node.getLastChild();
        node.removeChild(newChild);
        parent.replaceChild(node, newChild);
        if (newChild.getType() == Token.BLOCK) {
            NodeUtil.tryMergeBlock(newChild);
        }
        compiler.reportCodeChange();
    }
    // Remove the label from the current stack of labels.
    namespaceStack.peek().renameMap.remove(name);
}"
170,Closure,73,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-416.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,988,1058,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}"
171,Closure,74,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-413.json,Medium,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,887,1069,"/**
 * Try to fold comparison nodes, e.g ==
 */
@SuppressWarnings(""fallthrough"")
private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {
        // We only handle non-literal operands for LT and GT.
        if (n.getType() != Token.GT && n.getType() != Token.LT) {
            return n;
        }
    }
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = getNormalizedNodeType(left);
    int rhType = getNormalizedNodeType(right);
    switch(lhType) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
                return n;
            } else if (!rightLiteral) {
                return n;
            } else {
                result = compareToUndefined(right, op);
            }
            break;
        case Token.NULL:
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = lhType == rhType;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = lhType != rhType;
                    break;
                case Token.GE:
                case Token.LE:
                case Token.GT:
                case Token.LT:
                    Boolean compareResult = compareAsNumbers(op, left, right);
                    if (compareResult != null) {
                        result = compareResult;
                    } else {
                        return n;
                    }
                    break;
                default:
                    // we only handle == and != here
                    return n;
            }
            break;
        case Token.THIS:
            if (right.getType() != Token.THIS) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = true;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = false;
                    break;
                // whether it is a string, NaN or other number value.
                default:
                    return n;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return n;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
                result = compareResult;
            } else {
                return null;
            }
            break;
        case Token.NAME:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    result = compareToUndefined(right, op);
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return n;
            }
            switch(op) {
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return n;
            }
            break;
        default:
            // assert, this should cover all consts
            return n;
    }
    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();
    return newNode;
}"
172,Closure,74,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-413.json,Medium,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,1074,1086,"/**
 * @return Translate NOT expressions into TRUE or FALSE when possible.
 */
private int getNormalizedNodeType(Node n) {
    int type = n.getType();
    if (type == Token.NOT) {
        TernaryValue value = NodeUtil.getPureBooleanValue(n);
        switch(value) {
            case TRUE:
                return Token.TRUE;
            case FALSE:
                return Token.FALSE;
        }
    }
    return type;
}"
173,Closure,75,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-395.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,312,356,"static Double getStringNumberValue(String rawJsString) {
    if (rawJsString.contains(""\u000b"")) {
        // vertical tab is not always whitespace
        return null;
    }
    String s = trimJsWhiteSpace(rawJsString);
    // return ScriptRuntime.toNumber(s);
    if (s.length() == 0) {
        return 0.0;
    }
    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
        // Attempt to convert hex numbers.
        try {
            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
        } catch (NumberFormatException e) {
            return Double.NaN;
        }
    }
    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
        // hex numbers with explicit signs vary between browsers.
        return null;
    }
    // insensitive, but IE treats ""infinity"" as NaN.  So leave it alone.
    if (s.equals(""infinity"") || s.equals(""-infinity"") || s.equals(""+infinity"")) {
        return null;
    }
    try {
        return Double.parseDouble(s);
    } catch (NumberFormatException e) {
        return Double.NaN;
    }
}"
174,Closure,75,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-395.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,375,393,"/**
 * Copied from Rhino's ScriptRuntime
 */
static TernaryValue isStrWhiteSpaceChar(int c) {
    switch(c) {
        case // <VT>
        '\u000B':
            // IE says ""no"", EcmaScript says ""yes""
            return TernaryValue.UNKNOWN;
        // <SP>
        case ' ':
        // <LF>
        case '\n':
        // <CR>
        case '\r':
        // <TAB>
        case '\t':
        // <NBSP>
        case '\u00A0':
        // <FF>
        case '\u000C':
        // <LS>
        case '\u2028':
        // <PS>
        case '\u2029':
        case // <BOM>
        '\uFEFF':
            return TernaryValue.TRUE;
        default:
            return (Character.getType(c) == Character.SPACE_SEPARATOR) ? TernaryValue.TRUE : TernaryValue.FALSE;
    }
}"
175,Closure,76,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-384.json,Medium,src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,290,338,"/**
 * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as
 * the root, this function returns true if there exists a read of that
 * variable before a write to that variable that is on the right side of n.
 *
 * For example, suppose the node is x = 1:
 *
 * y = 1, x = 1; // false, there is no reads at all.
 * y = 1, x = 1, print(x) // true, there is a read right of n.
 * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but
 *                               // it is after a write.
 *
 * @param n The current node we should look at.
 * @param exprRoot The node
 */
private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) {
    while (n != exprRoot) {
        VariableLiveness state = VariableLiveness.MAYBE_LIVE;
        switch(n.getParent().getType()) {
            case Token.OR:
            case Token.AND:
                // of the second operand.
                if (n.getNext() != null) {
                    state = isVariableReadBeforeKill(n.getNext(), variable);
                    if (state == VariableLiveness.KILL) {
                        state = VariableLiveness.MAYBE_LIVE;
                    }
                }
                break;
            case Token.HOOK:
                // other branch can be ignored.
                if (n.getNext() != null && n.getNext().getNext() != null) {
                    state = checkHookBranchReadBeforeKill(n.getNext(), n.getNext().getNext(), variable);
                }
                break;
            default:
                for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {
                    state = isVariableReadBeforeKill(sibling, variable);
                    if (state != VariableLiveness.MAYBE_LIVE) {
                        break;
                    }
                }
        }
        // If we see a READ or KILL there is no need to continue.
        if (state == VariableLiveness.READ) {
            return true;
        } else if (state == VariableLiveness.KILL) {
            return false;
        }
        n = n.getParent();
    }
    return false;
}"
176,Closure,76,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-384.json,Medium,src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,352,413,"/**
 * Give an expression and a variable. It returns READ, if the first
 * reference of that variable is a read. It returns KILL, if the first
 * reference of that variable is an assignment. It returns MAY_LIVE otherwise.
 */
private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (ControlFlowGraph.isEnteringNewCfgNode(n)) {
        // Not a FUNCTION
        return VariableLiveness.MAYBE_LIVE;
    }
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
            // The expression to which the assignment is made is evaluated before
            // the RHS is evaluated (normal left to right evaluation) but the KILL
            // occurs after the RHS is evaluated.
            Node rhs = n.getNext();
            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
            if (state == VariableLiveness.READ) {
                return state;
            }
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }
    switch(n.getType()) {
        // Conditionals
        case Token.OR:
        case Token.AND:
            VariableLiveness v1 = isVariableReadBeforeKill(n.getFirstChild(), variable);
            VariableLiveness v2 = isVariableReadBeforeKill(n.getLastChild(), variable);
            // may not.
            if (v1 != VariableLiveness.MAYBE_LIVE) {
                return v1;
            } else if (v2 == VariableLiveness.READ) {
                return VariableLiveness.READ;
            } else {
                return VariableLiveness.MAYBE_LIVE;
            }
        case Token.HOOK:
            VariableLiveness first = isVariableReadBeforeKill(n.getFirstChild(), variable);
            if (first != VariableLiveness.MAYBE_LIVE) {
                return first;
            }
            return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
        default:
            // Expressions are evaluated left-right, depth first.
            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
                VariableLiveness state = isVariableReadBeforeKill(child, variable);
                if (state != VariableLiveness.MAYBE_LIVE) {
                    return state;
                }
            }
    }
    return VariableLiveness.MAYBE_LIVE;
}"
177,Closure,77,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-383.json,High,src/com/google/javascript/jscomp/CodeGenerator.java,956,1026,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c <= 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}"
178,Closure,78,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-381.json,Medium,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,664,744,"/**
 * Try to fold arithmetic binary operators
 */
private Node performArithmeticOp(int opType, Node left, Node right) {
    // to Number.
    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }
    double result;
    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.
    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
        return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
        return null;
    }
    double lval = lValObj;
    double rval = rValObj;
    switch(opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            if (rval == 0) {
                return null;
            }
            result = lval % rval;
            break;
        case Token.DIV:
            if (rval == 0) {
                return null;
            }
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // point, fixed-point math starts to break down and become inaccurate.
    Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    } else if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }
    return null;
}"
179,Closure,79,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-367.json,High,src/com/google/javascript/jscomp/Normalize.java,118,149,"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverseRoots(externs, root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    // function f() {
    // try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    // var e = 1; // f scope 'e'
    // }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}"
180,Closure,79,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-367.json,High,src/com/google/javascript/jscomp/VarCheck.java,205,222,"/**
 * Create a new variable in a synthetic script. This will prevent
 * subsequent compiler passes from crashing.
 */
private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);
    // cases for this configuration though, and it makes them happier.
    if (compiler.getCodingConvention().isConstant(varName)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));
    varsToDeclareInExterns.remove(varName);
    compiler.reportCodeChange();
}"
181,Closure,80,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-364.json,High,src/com/google/javascript/jscomp/NodeUtil.java,1242,1267,"static boolean isBooleanResultHelper(Node n) {
    switch(n.getType()) {
        // Primitives
        case Token.TRUE:
        case Token.FALSE:
        // Comparisons
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.LT:
        case Token.GT:
        case Token.LE:
        case Token.GE:
        // Queryies
        case Token.IN:
        case Token.INSTANCEOF:
        // Inversion
        case Token.NOT:
        // delete operator returns a boolean.
        case Token.DELPROP:
            return true;
        default:
            return false;
    }
}"
182,Closure,80,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-364.json,High,src/com/google/javascript/jscomp/NodeUtil.java,2865,2929,"/**
 * @param locals A predicate to apply to unknown local values.
 * @return Whether the node is known to be a value that is not a reference
 *     outside the expression scope.
 */
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch(value.getType()) {
        case Token.ASSIGN:
            // value is immutable.
            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // There is no information about the locality of object properties.
            return locals.apply(value);
        case Token.CALL:
            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
        case Token.NEW:
            return newHasLocalResult(value) || locals.apply(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // Literals objects with non-literal children are allowed.
            return true;
        case Token.DELPROP:
        case Token.IN:
            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
            return true;
        default:
            // x -= g (x is now an local number)
            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(""Unexpected expression node"" + value + ""\n parent:"" + value.getParent());
    }
}"
183,Closure,81,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-251.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,512,569,"@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    Boolean isUnnamedFunction = false;
    if (name == null) {
        int functionType = functionNode.getFunctionType();
        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
            errorReporter.error(""unnamed function statement"", sourceName, functionNode.getLineno(), """", 0);
        }
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }
    node.addChildToBack(newName);
    Node lp = newNode(Token.LP);
    // The left paren's complicated because it's not represented by an
    // AstNode, so there's nothing that has the actual line number that it
    // appeared on.  We know the paren has to appear on the same line as the
    // function name (or else a semicolon will be inserted.)  If there's no
    // function name, assume the paren was on the same line as the function.
    // TODO(bowdidge): Mark line number of paren correctly.
    Name fnName = functionNode.getFunctionName();
    if (fnName != null) {
        lp.setLineno(fnName.getLineno());
    } else {
        lp.setLineno(functionNode.getLineno());
    }
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);
    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    return node;
}"
184,Closure,82,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-301.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,162,166,"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE) == this);
}"
185,Closure,83,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-319.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,332,354,"@Override
public int parseArguments(Parameters params) throws CmdLineException {
    String param = null;
    try {
        param = params.getParameter(0);
    } catch (CmdLineException e) {
    }
    if (param == null) {
        setter.addValue(true);
        return 0;
    } else {
        String lowerParam = param.toLowerCase();
        if (TRUES.contains(lowerParam)) {
            setter.addValue(true);
        } else if (FALSES.contains(lowerParam)) {
            setter.addValue(false);
        } else {
            setter.addValue(true);
            return 0;
        }
        return 1;
    }
}"
186,Closure,84,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-215.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,338,349,"@Override
Node processAssignment(Assignment assignmentNode) {
    Node assign = processInfixExpression(assignmentNode);
    Node target = assign.getFirstChild();
    if (!validAssignmentTarget(target)) {
        errorReporter.error(""invalid assignment target"", sourceName, target.getLineno(), """", 0);
    }
    return assign;
}"
187,Closure,84,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-215.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,796,822,"@Override
Node processUnaryExpression(UnaryExpression exprNode) {
    int type = transformTokenType(exprNode.getType());
    Node operand = transform(exprNode.getOperand());
    if (type == Token.NEG && operand.getType() == Token.NUMBER) {
        operand.setDouble(-operand.getDouble());
        return operand;
    } else {
        if (type == Token.INC || type == Token.DEC) {
            if (!validAssignmentTarget(operand)) {
                String msg = (type == Token.INC) ? ""invalid increment target"" : ""invalid decrement target"";
                errorReporter.error(msg, sourceName, operand.getLineno(), """", 0);
            }
        }
        Node node = newNode(type, operand);
        if (exprNode.isPostfix()) {
            node.putBooleanProp(Node.INCRDECR_PROP, true);
        }
        return node;
    }
}"
188,Closure,84,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-215.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,824,832,"private boolean validAssignmentTarget(Node target) {
    switch(target.getType()) {
        case Token.NAME:
        case Token.GETPROP:
        case Token.GETELEM:
            return true;
    }
    return false;
}"
189,Closure,85,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-311.json,High,src/com/google/javascript/jscomp/UnreachableCodeElimination.java,130,179,"/**
 * Tries to remove n if an unconditional branch node (break, continue or
 * return) if the target of n is the same as the the follow of n. That is, if
 * we remove n, the control flow remains the same. Also if n targets to
 * another unconditional branch, this function will recursively try to remove
 * the target branch as well. The reason why we want to cascade this removal
 * is because we only run this pass once. If we have code such as
 *
 * break -> break -> break
 *
 * where all 3 break's are useless. The order of removal matters. When we
 * first look at the first break, we see that it branches to the 2nd break.
 * However, if we remove the last break, the 2nd break becomes useless and
 * finally the first break becomes useless as well.
 *
 * @return The target of this jump. If the target is also useless jump,
 *     the target of that useless jump recursively.
 */
@SuppressWarnings(""fallthrough"")
private Node tryRemoveUnconditionalBranching(Node n) {
    // If n is null the target is the end of the function, nothing to do.
    if (n == null) {
        return n;
    }
    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);
    if (gNode == null) {
        return n;
    }
    switch(n.getType()) {
        case Token.RETURN:
            if (n.hasChildren()) {
                break;
            }
        case Token.BREAK:
        case Token.CONTINUE:
            // We are looking for a control flow changing statement that always
            // branches to the same node. If removing it the control flow still
            // branches to that same node. It is safe to remove it.
            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();
            if (outEdges.size() == 1 && // If there is a next node, there is no chance this jump is useless.
            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
                Node fallThrough = computeFollowing(n);
                Node nextCfgNode = outEdges.get(0).getDestination().getValue();
                if (nextCfgNode == fallThrough) {
                    removeDeadExprStatementSafely(n);
                    return fallThrough;
                }
            }
    }
    return n;
}"
190,Closure,85,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-311.json,High,src/com/google/javascript/jscomp/UnreachableCodeElimination.java,181,191,"private Node computeFollowing(Node n) {
    Node next = ControlFlowAnalysis.computeFollowNode(n);
    while (next != null && next.getType() == Token.BLOCK) {
        if (next.hasChildren()) {
            next = next.getFirstChild();
        } else {
            next = computeFollowing(next);
        }
    }
    return next;
}"
191,Closure,86,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-303.json,Critical,src/com/google/javascript/jscomp/NodeUtil.java,2424,2489,"/**
 * @param locals A predicate to apply to unknown local values.
 * @return Whether the node is known to be a value that is not a reference
 *     outside the expression scope.
 */
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch(value.getType()) {
        case Token.ASSIGN:
            // value is immutable.
            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // There is no information about the locality of object properties.
            return locals.apply(value);
        case Token.CALL:
            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
        case Token.NEW:
            // the constructor (similar to callHasLocalResult)
            return false;
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // Literals objects with non-literal children are allowed.
            return true;
        case Token.IN:
            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
            return true;
        default:
            // x -= g (x is now an local number)
            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(""Unexpected expression node"" + value + ""\n parent:"" + value.getParent());
    }
}"
192,Closure,87,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-291.json,Medium,src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,519,550,"/**
 * @return Whether the node is a block with a single statement that is
 *     an expression.
 */
private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            if (maybeExpr.getType() == Token.EXPR_RESULT) {
                // into other expressions.
                if (maybeExpr.getFirstChild().getType() == Token.CALL) {
                    Node calledFn = maybeExpr.getFirstChild().getFirstChild();
                    // param, or this doesn't happen.
                    if (calledFn.getType() == Token.GETELEM) {
                        return false;
                    } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith(""on"")) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
    }
    return false;
}"
193,Closure,88,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-297.json,High,src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,323,353,"/**
 * Give an expression and a variable. It returns READ, if the first
 * reference of that variable is a read. It returns KILL, if the first
 * reference of that variable is an assignment. It returns MAY_LIVE otherwise.
 */
private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
            // The expression to which the assignment is made is evaluated before
            // the RHS is evaluated (normal left to right evaluation) but the KILL
            // occurs after the RHS is evaluated.
            Node rhs = n.getNext();
            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
            if (state == VariableLiveness.READ) {
                return state;
            }
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }
    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {
            // Not a FUNCTION
            VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
                return state;
            }
        }
    }
    return VariableLiveness.MAYBE_LIVE;
}"
194,Closure,89,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-289.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,477,543,"/**
 * Updates the initial assignment to a collapsible property at global scope
 * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).
 * The property's value may either be a primitive or an object literal or
 * function whose properties aren't collapsible.
 *
 * @param alias The flattened property name (e.g. ""a$b"")
 * @param refName The name for the reference being updated.
 * @param ref An object containing information about the assignment getting
 *     updated
 */
private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
    Node rvalue = ref.node.getNext();
    Node parent = ref.node.getParent();
    Node gramps = parent.getParent();
    Node greatGramps = gramps.getParent();
    Node greatGreatGramps = greatGramps.getParent();
    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
        checkForHosedThisReferences(rvalue, refName.docInfo, refName);
    }
    // Create the new alias node.
    Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());
    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);
    if (gramps.getType() == Token.EXPR_RESULT) {
        // BEFORE: a.b.c = ...;
        // exprstmt
        // assign
        // getprop
        // getprop
        // name a
        // string b
        // string c
        // NODE
        // AFTER: var a$b$c = ...;
        // var
        // name a$b$c
        // NODE
        // Remove the rvalue (NODE).
        parent.removeChild(rvalue);
        nameNode.addChildToFront(rvalue);
        Node varNode = new Node(Token.VAR, nameNode);
        greatGramps.replaceChild(gramps, varNode);
    } else {
        // This must be a complex assignment.
        Preconditions.checkNotNull(ref.getTwin());
        // BEFORE:
        // ... (x.y = 3);
        // 
        // AFTER:
        // var x$y;
        // ... (x$y = 3);
        Node current = gramps;
        Node currentParent = gramps.getParent();
        for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {
        }
        // Create a stub variable declaration right
        // before the current statement.
        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);
        currentParent.addChildBefore(stubVar, current);
        parent.replaceChild(ref.node, nameNode);
    }
    compiler.reportCodeChange();
}"
195,Closure,89,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-289.json,Medium,src/com/google/javascript/jscomp/GlobalNamespace.java,896,925,"boolean canCollapseUnannotatedChildNames() {
    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
    }
    // Don't try to collapse if the one global set is a twin reference.
    // We could theoretically handle this case in CollapseProperties, but
    // it's probably not worth the effort.
    Preconditions.checkNotNull(declaration);
    if (declaration.getTwin() != null) {
        return false;
    }
    if (isClassOrEnum) {
        return true;
    }
    // later. So we won't be able to collapse its properties.
    if (parent != null && parent.shouldKeepKeys()) {
        return false;
    }
    // If this is aliased, then its properties can't be collapsed either.
    if (aliasingGets > 0) {
        return false;
    }
    return (parent == null || parent.canCollapseUnannotatedChildNames());
}"
196,Closure,90,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-274.json,Medium,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,176,190,"@Override
public boolean apply(JSType type) {
    // union types can also be object types, etc.
    if (!type.restrictByNotNullOrUndefined().isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {
        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
        return false;
    }
    return true;
}"
197,Closure,90,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-274.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,861,906,"@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);
    call = (ArrowType) safeResolve(call, t, scope);
    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);
    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    // 
    // TODO(nicksantos): Handle this correctly if we have a UnionType.
    // 
    // TODO(nicksantos): In ES3, the runtime coerces ""null"" to the global
    // activation object. In ES5, it leaves it as null. Just punt on this
    // issue for now by coercing out null. This is complicated by the
    // fact that when most people write @this {Foo}, they really don't
    // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
    // the name for them.
    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
    if (maybeTypeOfThis != null) {
        maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
    }
    if (maybeTypeOfThis instanceof ObjectType) {
        typeOfThis = (ObjectType) maybeTypeOfThis;
    }
    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
        resolvedInterfaces.add(resolvedIface);
        changed |= (resolvedIface != iface);
    }
    if (changed) {
        implementedInterfaces = resolvedInterfaces.build();
    }
    if (subTypes != null) {
        for (int i = 0; i < subTypes.size(); i++) {
            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
        }
    }
    return super.resolveInternal(t, scope);
}"
198,Closure,91,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-248.json,Medium,src/com/google/javascript/jscomp/CheckGlobalThis.java,82,155,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys
        pType == Token.STRING || pType == Token.NUMBER)) {
            return false;
        }
        // Don't traverse functions that are getting lent to a prototype.
        Node gramps = parent.getParent();
        if (NodeUtil.isObjectLitKey(parent, gramps)) {
            JSDocInfo maybeLends = gramps.getJSDocInfo();
            if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith("".prototype"")) {
                return false;
            }
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}"
199,Closure,92,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-261.json,Medium,src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,747,809,"/**
 * Replace the provide statement.
 *
 * If we're providing a name with no definition, then create one.
 * If we're providing a name with a duplicate definition, then make sure
 * that definition becomes a declaration.
 */
void replace() {
    if (firstNode == null) {
        // Don't touch the base case ('goog').
        replacementNode = candidateDefinition;
        return;
    }
    // provided symbol.
    if (candidateDefinition != null && explicitNode != null) {
        explicitNode.detachFromParent();
        compiler.reportCodeChange();
        // Does this need a VAR keyword?
        replacementNode = candidateDefinition;
        if (NodeUtil.isExpressionNode(candidateDefinition)) {
            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);
            Node assignNode = candidateDefinition.getFirstChild();
            Node nameNode = assignNode.getFirstChild();
            if (nameNode.getType() == Token.NAME) {
                // Need to convert this assign to a var declaration.
                Node valueNode = nameNode.getNext();
                assignNode.removeChild(nameNode);
                assignNode.removeChild(valueNode);
                nameNode.addChildToFront(valueNode);
                Node varNode = new Node(Token.VAR, nameNode);
                varNode.copyInformationFrom(candidateDefinition);
                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);
                nameNode.setJSDocInfo(assignNode.getJSDocInfo());
                compiler.reportCodeChange();
                replacementNode = varNode;
            }
        }
    } else {
        // Handle the case where there's not a duplicate definition.
        replacementNode = createDeclarationNode();
        if (firstModule == minimumModule) {
            firstNode.getParent().addChildBefore(replacementNode, firstNode);
        } else {
            // In this case, the name was implicitly provided by two independent
            // modules. We need to move this code up to a common module.
            int indexOfDot = namespace.lastIndexOf('.');
            if (indexOfDot == -1) {
                // Any old place is fine.
                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);
            } else {
                // Add it after the parent namespace.
                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));
                Preconditions.checkNotNull(parentName);
                Preconditions.checkNotNull(parentName.replacementNode);
                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);
            }
        }
        if (explicitNode != null) {
            explicitNode.detachFromParent();
        }
        compiler.reportCodeChange();
    }
}"
200,Closure,94,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-255.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,320,366,"/**
 * Determines whether the given value may be assigned to a define.
 *
 * @param val The value being assigned.
 * @param defines The list of names of existing defines.
 */
static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch(val.getType()) {
        case Token.STRING:
        case Token.NUMBER:
        case Token.TRUE:
        case Token.FALSE:
            return true;
        // Binary operators are only valid if both children are valid.
        case Token.ADD:
        case Token.BITAND:
        case Token.BITNOT:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.DIV:
        case Token.EQ:
        case Token.GE:
        case Token.GT:
        case Token.LE:
        case Token.LSH:
        case Token.LT:
        case Token.MOD:
        case Token.MUL:
        case Token.NE:
        case Token.RSH:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.SUB:
        case Token.URSH:
            return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);
        // Uniary operators are valid if the child is valid.
        case Token.NOT:
        case Token.NEG:
        case Token.POS:
            return isValidDefineValue(val.getFirstChild(), defines);
        // Names are valid if and only if they are defines themselves.
        case Token.NAME:
        case Token.GETPROP:
            if (val.isQualifiedName()) {
                return defines.contains(val.getQualifiedName());
            }
    }
    return false;
}"
201,Closure,95,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-66.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,872,952,"/**
 * Defines a typed variable. The defining node will be annotated with the
 * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is
 * inferred.
 *
 * Slots may be any variable or any qualified name in the global scope.
 *
 * @param n the defining NAME or GETPROP node.
 * @param parent the {@code n}'s parent.
 * @param type the variable's type. It may be {@code null} if
 *     {@code inferred} is {@code true}.
 */
void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);
    // Only allow declarations of NAMEs and qualfied names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(!variableName.isEmpty());
    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = scope;
    if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) {
        Scope globalScope = scope.getGlobalScope();
        // already a symbol there with this name.
        if (!globalScope.isDeclared(variableName, false)) {
            scopeToDeclareIn = scope.getGlobalScope();
        }
    }
    // declared in closest scope?
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);
        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */
                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}"
202,Closure,96,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-229.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,1399,1433,"/**
 * Visits the parameters of a CALL or a NEW node.
 */
private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    // skip the function name
    arguments.next();
    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;
    while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) {
        // above implies that this must be a var_args function.
        if (parameters.hasNext()) {
            parameter = parameters.next();
        }
        argument = arguments.next();
        ordinal++;
        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);
    }
    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}"
203,Closure,97,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-200.json,High,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,652,714,"/**
 * Try to fold shift operations
 */
private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        // a 32-bit range, since the user likely does not intend that.
        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }
        // if the shift amount is outside [0,32)
        if (!(rval >= 0 && rval < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }
        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if (lvalInt != lval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, right);
            return n;
        }
        switch(n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                // JavaScript handles zero shifts on signed numbers differently than
                // Java as an Java int can not represent the unsigned 32-bit number
                // where JavaScript can so use a long here.
                long lvalLong = lvalInt & 0xffffffffL;
                result = lvalLong >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }
        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();
        return newNumber;
    }
    return n;
}"
204,Closure,98,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-174.json,High,src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,354,371,"/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    // Make sure this assignment is not in a loop.
    for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            break;
        } else if (block.isLoop) {
            return false;
        }
    }
    return true;
}"
205,Closure,99,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-125.json,Medium,src/com/google/javascript/jscomp/CheckGlobalThis.java,84,141,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}"
206,Closure,100,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-144.json,Medium,src/com/google/javascript/jscomp/CheckGlobalThis.java,84,135,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (lhs.getType() == Token.GETPROP) {
                if (lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                String leftName = lhs.getQualifiedName();
                if (leftName != null && leftName.contains("".prototype."")) {
                    return false;
                }
            }
        }
    }
    return true;
}"
207,Closure,100,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-144.json,Medium,src/com/google/javascript/jscomp/CheckGlobalThis.java,146,154,"private boolean shouldReportThis(Node n, Node parent) {
    if (assignLhsChild != null) {
        // Always report a THIS on the left side of an assign.
        return true;
    }
    // Also report a THIS with a property access.
    return parent != null && NodeUtil.isGet(parent);
}"
208,Closure,101,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-130.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,418,437,"@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    options.closurePass = flags.process_closure_primitives;
    initOptionsFromFlags(options);
    return options;
}"
209,Closure,102,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-115.json,Medium,src/com/google/javascript/jscomp/Normalize.java,86,97,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);
    removeDuplicateDeclarations(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}"
210,Closure,103,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-113.json,Medium,src/com/google/javascript/jscomp/ControlFlowAnalysis.java,884,905,"/**
 * Determines if the subtree might throw an exception.
 */
private static boolean mayThrowException(Node n) {
    switch(n.getType()) {
        case Token.CALL:
        case Token.GETPROP:
        case Token.GETELEM:
        case Token.THROW:
        case Token.NEW:
        case Token.ASSIGN:
        case Token.INC:
        case Token.DEC:
        case Token.INSTANCEOF:
            return true;
        case Token.FUNCTION:
            return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
            return true;
        }
    }
    return false;
}"
211,Closure,103,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-113.json,Medium,src/com/google/javascript/jscomp/DisambiguateProperties.java,736,774,"@Override
public ObjectType getTypeWithProperty(String field, JSType type) {
    if (!(type instanceof ObjectType)) {
        if (type.autoboxesTo() != null) {
            type = type.autoboxesTo();
        } else {
            return null;
        }
    }
    // Ignore the prototype itself at all times.
    if (""prototype"".equals(field)) {
        return null;
    }
    // We look up the prototype chain to find the highest place (if any) that
    // this appears.  This will make references to overriden properties look
    // like references to the initial property, so they are renamed alike.
    ObjectType foundType = null;
    ObjectType objType = ObjectType.cast(type);
    while (objType != null && objType.getImplicitPrototype() != objType) {
        if (objType.hasOwnProperty(field)) {
            foundType = objType;
        }
        objType = objType.getImplicitPrototype();
    }
    // type is an object type, see if any subtype has the property.
    if (foundType == null) {
        ObjectType maybeType = ObjectType.cast(registry.getGreatestSubtypeWithProperty(type, field));
        // so we have to double check.
        if (maybeType != null && maybeType.hasOwnProperty(field)) {
            foundType = maybeType;
        }
    }
    return foundType;
}"
212,Closure,104,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-114.json,Medium,src/com/google/javascript/rhino/jstype/UnionType.java,273,298,"JSType meet(JSType that) {
    UnionTypeBuilder builder = new UnionTypeBuilder(registry);
    for (JSType alternate : alternates) {
        if (alternate.isSubtype(that)) {
            builder.addAlternate(alternate);
        }
    }
    if (that instanceof UnionType) {
        for (JSType otherAlternate : ((UnionType) that).alternates) {
            if (otherAlternate.isSubtype(this)) {
                builder.addAlternate(otherAlternate);
            }
        }
    } else if (that.isSubtype(this)) {
        builder.addAlternate(that);
    }
    JSType result = builder.build();
    if (!result.isNoType()) {
        return result;
    } else if (this.isObject() && that.isObject()) {
        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    } else {
        return getNativeType(JSTypeNative.NO_TYPE);
    }
}"
213,Closure,105,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-106.json,Medium,src/com/google/javascript/jscomp/FoldConstants.java,1461,1551,"/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }
    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return;
    }
    String joinString = NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getStringValue(elem));
        } else {
            if (sb != null) {
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = null;
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    if (sb != null) {
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        default:
            // No folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}"
214,Closure,106,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-19.json,Medium,src/com/google/javascript/jscomp/GlobalNamespace.java,899,917,"boolean canCollapseUnannotatedChildNames() {
    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
    }
    // Don't try to collapse if the one global set is a twin reference.
    // We could theoretically handle this case in CollapseProperties, but
    // it's probably not worth the effort.
    Preconditions.checkNotNull(declaration);
    if (declaration.getTwin() != null) {
        return false;
    }
    if (isClassOrEnum) {
        return true;
    }
    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());
}"
215,Closure,106,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-19.json,Medium,src/com/google/javascript/rhino/JSDocInfoBuilder.java,188,191,"/**
 * Records a block-level description.
 *
 * @return {@code true} if the description was recorded.
 */
public boolean recordBlockDescription(String description) {
    populated = true;
    return currentInfo.documentBlock(description);
}"
216,Closure,107,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1135.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,805,866,"@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    if (flags.processJqueryPrimitives) {
        options.setCodingConvention(new JqueryCodingConvention());
    } else {
        options.setCodingConvention(new ClosureCodingConvention());
    }
    options.setExtraAnnotationNames(flags.extraAnnotationName);
    CompilationLevel level = flags.compilationLevel;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    if (flags.useTypesForOptimization) {
        level.setTypeBasedOptimizationOptions(options);
    }
    if (flags.generateExports) {
        options.setGenerateExports(flags.generateExports);
    }
    WarningLevel wLevel = flags.warningLevel;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    options.closurePass = flags.processClosurePrimitives;
    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;
    options.angularPass = flags.angularPass;
    if (!flags.translationsFile.isEmpty()) {
        try {
            options.messageBundle = new XtbMessageBundle(new FileInputStream(flags.translationsFile), flags.translationsProject);
        } catch (IOException e) {
            throw new RuntimeException(""Reading XTB file"", e);
        }
    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
        // In SIMPLE or WHITESPACE mode, if the user hasn't specified a
        // translations file, they might reasonably try to write their own
        // implementation of goog.getMsg that makes the substitution at
        // run-time.
        // 
        // In ADVANCED mode, goog.getMsg is going to be renamed anyway,
        // so we might as well inline it. But shut off the i18n warnings,
        // because the user didn't really ask for i18n.
        options.messageBundle = new EmptyMessageBundle();
        options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);
    }
    return options;
}"
217,Closure,108,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1144.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,309,323,"@Override
public void exitScope(NodeTraversal t) {
    if (t.getScopeDepth() > 2) {
        findNamespaceShadows(t);
    }
    if (t.getScopeDepth() == 2) {
        renameNamespaceShadows(t);
        injectedDecls.clear();
        aliases.clear();
        forbiddenLocals.clear();
        transformation = null;
        hasNamespaceShadows = false;
    }
}"
218,Closure,108,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1144.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,359,448,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
        // Bleeding functions already get a BAD_PARAMETERS error, so just
        // do nothing.
        } else if (parent.getType() == Token.LP) {
        // Parameters of the scope function also get a BAD_PARAMETERS
        // error.
        } else if (isVar || isFunctionDecl) {
            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
            Node grandparent = parent.getParent();
            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;
            Node varNode = null;
            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));
            compiler.ensureLibraryInjected(""base"");
            // to be used in another expression.
            if (isFunctionDecl) {
                // Replace ""function NAME() { ... }"" with ""var NAME;"".
                Node existingName = v.getNameNode();
                // We can't keep the local name on the function expression,
                // because IE is buggy and will leak the name into the global
                // scope. This is covered in more detail here:
                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
                // 
                // This will only cause problems if this is a hoisted, recursive
                // function, and the programmer is using the hoisting.
                Node newName = IR.name("""").useSourceInfoFrom(existingName);
                value.replaceChild(existingName, newName);
                varNode = IR.var(existingName).useSourceInfoFrom(existingName);
                grandparent.replaceChild(parent, varNode);
            } else {
                if (value != null) {
                    // If this is a VAR, we can just detach the expression and
                    // the tree will still be valid.
                    value.detachFromParent();
                }
                varNode = parent;
            }
            // Make sure we copy over all the jsdoc and debug info.
            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);
                if (isHoisted) {
                    grandparent.addChildToFront(newDecl);
                } else {
                    grandparent.addChildBefore(newDecl, varNode);
                }
                injectedDecls.add(newDecl.getFirstChild());
            }
            // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));
            recordAlias(v);
        } else {
            // Do not other kinds of local symbols, like catch params.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}"
219,Closure,108,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1144.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,525,592,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
    // Validate the top-level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
            // Note, to support the transitive case, it's important we don't
            // clone aliasedNode here.  For example,
            // var g = goog; var d = g.dom; d.createElement('DIV');
            // The node in aliasedNode (which is ""g"") will be replaced in the
            // changes pass above with ""goog"".  If we cloned here, we'd end up
            // with <code>g.dom.createElement('DIV')</code>.
            aliasUsages.add(new AliasedNode(aliasVar, n));
        }
        // When we inject declarations, we duplicate jsdoc. Make sure
        // we only process that jsdoc once.
        JSDocInfo info = n.getJSDocInfo();
        if (info != null && !injectedDecls.contains(n)) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}"
220,Closure,109,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1105.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,1907,1913,"/**
 * ContextTypeExpression := BasicTypeExpression | '?'
 * For expressions on the right hand side of a this: or new:
 */
private Node parseContextTypeExpression(JsDocToken token) {
    if (token == JsDocToken.QMARK) {
        return newNode(Token.QMARK);
    } else {
        return parseBasicTypeExpression(token);
    }
}"
221,Closure,110,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1111.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,352,440,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
        // Bleeding functions already get a BAD_PARAMETERS error, so just
        // do nothing.
        } else if (parent.getType() == Token.LP) {
        // Parameters of the scope function also get a BAD_PARAMETERS
        // error.
        } else if (isVar || isFunctionDecl) {
            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
            Node grandparent = parent.getParent();
            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;
            Node varNode = null;
            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));
            compiler.ensureLibraryInjected(""base"");
            // to be used in another expression.
            if (isFunctionDecl) {
                // Replace ""function NAME() { ... }"" with ""var NAME;"".
                Node existingName = v.getNameNode();
                // We can't keep the local name on the function expression,
                // because IE is buggy and will leak the name into the global
                // scope. This is covered in more detail here:
                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
                // 
                // This will only cause problems if this is a hoisted, recursive
                // function, and the programmer is using the hoisting.
                Node newName = IR.name("""").useSourceInfoFrom(existingName);
                value.replaceChild(existingName, newName);
                varNode = IR.var(existingName).useSourceInfoFrom(existingName);
                grandparent.replaceChild(parent, varNode);
            } else {
                if (value != null) {
                    // If this is a VAR, we can just detach the expression and
                    // the tree will still be valid.
                    value.detachFromParent();
                }
                varNode = parent;
            }
            // Make sure we copy over all the jsdoc and debug info.
            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);
                if (isHoisted) {
                    grandparent.addChildToFront(newDecl);
                } else {
                    grandparent.addChildBefore(newDecl, varNode);
                }
            }
            // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));
            recordAlias(v);
        } else {
            // Do not other kinds of local symbols, like catch params.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}"
222,Closure,110,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1111.json,Medium,src/com/google/javascript/rhino/Node.java,549,565,"public Node getChildBefore(Node child) {
    if (child == first) {
        return null;
    }
    Node n = first;
    if (n == null) {
        throw new RuntimeException(""node is not a child"");
    }
    while (n.next != child) {
        n = n.next;
        if (n == null) {
            throw new RuntimeException(""node is not a child"");
        }
    }
    return n;
}"
223,Closure,111,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1114.json,Medium,src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java,52,56,"@Override
protected JSType caseTopType(JSType topType) {
    return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType;
}"
224,Closure,112,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1058.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,1183,1216,"/**
 * For functions with function(this: T, ...) and T as parameters, type
 * inference will set the type of this on a function literal argument to the
 * the actual type of T.
 */
private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys.isEmpty()) {
        return false;
    }
    // Try to infer the template types
    Map<TemplateType, JSType> inferred = Maps.filterKeys(inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() {

        @Override
        public boolean apply(TemplateType key) {
            return keys.contains(key);
        }
    });
    // Replace all template types. If we couldn't find a replacement, we
    // replace it with UNKNOWN.
    TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);
    Node callTarget = n.getFirstChild();
    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();
    Preconditions.checkNotNull(replacementFnType);
    callTarget.setJSType(replacementFnType);
    n.setJSType(replacementFnType.getReturnType());
    return replacer.madeChanges;
}"
225,Closure,112,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1058.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,1196,1199,"@Override
public boolean apply(TemplateType key) {
    return keys.contains(key);
}"
226,Closure,113,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1079.json,Medium,src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,295,334,"/**
 * Handles a goog.require call.
 */
private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;
            // This must be non-null, because there was an explicit provide.
            Preconditions.checkNotNull(providedModule);
            JSModule module = t.getModule();
            if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {
                compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));
            }
        }
        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);
        // let them be caught in the subsequent run.
        if (provided != null || requiresLevel.isOn()) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}"
227,Closure,114,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1085.json,Medium,src/com/google/javascript/jscomp/NameAnalyzer.java,558,588,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // logic.
            if (parent.getFirstChild().getNext() != n) {
                recordDepScope(recordNode, ns);
            } else {
                recordDepScope(nameNode, ns);
            }
        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {
            // The rhs of the assignment is the caller, so it's used by the
            // context. Don't associate it w/ the lhs.
            // FYI: this fixes only the specific case where the assignment is the
            // caller expression, but it could be nested deeper in the caller and
            // we would still get a bug.
            // See testAssignWithCall2 for an example of this.
            recordDepScope(recordNode, ns);
        }
    }
}"
228,Closure,115,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json,Medium,src/com/google/javascript/jscomp/FunctionInjector.java,689,747,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter check if a mutable argument use more than one.
        if (fnParam != null) {
            if (cArg != null) {
                // parameter reference will be in a loop.
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            // Move to the next name.
            fnParam = fnParam.getNext();
        }
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}"
229,Closure,116,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json,Medium,src/com/google/javascript/jscomp/FunctionInjector.java,689,761,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    // empty function case
    boolean hasSideEffects = false;
    if (block.hasChildren()) {
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter check if a mutable argument use more than one.
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                // parameter reference will be in a loop.
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            // Move to the next name.
            fnParam = fnParam.getNext();
        }
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}"
230,Closure,117,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1047.json,Medium,src/com/google/javascript/jscomp/TypeValidator.java,724,777,"/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */
String getReadableJSTypeName(Node n, boolean dereference) {
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    // The best type name is the actual type name.
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    // the property was originally defined.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}"
231,Closure,118,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1024.json,Medium,src/com/google/javascript/jscomp/DisambiguateProperties.java,490,516,"/**
 * Processes a OBJECTLIT node.
 */
private void handleObjectLit(NodeTraversal t, Node n) {
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        // Maybe STRING, GET, SET
        if (child.isQuotedString()) {
            continue;
        }
        // We should never see a mix of numbers and strings.
        String name = child.getString();
        T type = typeSystem.getType(getScope(), n, name);
        Property prop = getProperty(name);
        if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {
            // case right now.
            if (propertiesToErrorFor.containsKey(name)) {
                compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? ""null"" : type.toString()), n.toString(), """"));
            }
        }
    }
}"
232,Closure,119,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1070.json,Low,src/com/google/javascript/jscomp/GlobalNamespace.java,306,431,"public void collect(JSModule module, Scope scope, Node n) {
    Node parent = n.getParent();
    String name;
    boolean isSet = false;
    Name.Type type = Name.Type.OTHER;
    boolean isPropAssign = false;
    switch(n.getType()) {
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
        case Token.STRING_KEY:
            // This may be a key in an object literal declaration.
            name = null;
            if (parent != null && parent.isObjectLit()) {
                name = getNameForObjLitKey(n);
            }
            if (name == null) {
                return;
            }
            isSet = true;
            switch(n.getType()) {
                case Token.STRING_KEY:
                    type = getValueType(n.getFirstChild());
                    break;
                case Token.GETTER_DEF:
                    type = Name.Type.GET;
                    break;
                case Token.SETTER_DEF:
                    type = Name.Type.SET;
                    break;
                default:
                    throw new IllegalStateException(""unexpected:"" + n);
            }
            break;
        case Token.NAME:
            // This may be a variable get or set.
            if (parent != null) {
                switch(parent.getType()) {
                    case Token.VAR:
                        isSet = true;
                        Node rvalue = n.getFirstChild();
                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
                        break;
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                        }
                        break;
                    case Token.GETPROP:
                        return;
                    case Token.FUNCTION:
                        Node gramps = parent.getParent();
                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
                            return;
                        }
                        isSet = true;
                        type = Name.Type.FUNCTION;
                        break;
                    case Token.CATCH:
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getString();
            break;
        case Token.GETPROP:
            // This may be a namespaced name get or set.
            if (parent != null) {
                switch(parent.getType()) {
                    case Token.ASSIGN:
                        if (parent.getFirstChild() == n) {
                            isSet = true;
                            type = getValueType(n.getNext());
                            isPropAssign = true;
                        }
                        break;
                    case Token.INC:
                    case Token.DEC:
                        isSet = true;
                        type = Name.Type.OTHER;
                        break;
                    case Token.GETPROP:
                        return;
                    default:
                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
                            isSet = true;
                            type = Name.Type.OTHER;
                        }
                }
            }
            name = n.getQualifiedName();
            if (name == null) {
                return;
            }
            break;
        default:
            return;
    }
    // We are only interested in global names.
    if (!isGlobalNameReference(name, scope)) {
        return;
    }
    if (isSet) {
        if (isGlobalScope(scope)) {
            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);
        } else {
            handleSetFromLocal(module, scope, n, parent, name);
        }
    } else {
        handleGet(module, scope, n, parent, name);
    }
}"
233,Closure,120,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1053.json,Medium,src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,421,441,"/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    // Make sure this assignment is not in a loop.
    for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            if (ref.getSymbol().getScope() != ref.scope) {
                return false;
            }
            break;
        } else if (block.isLoop) {
            return false;
        }
    }
    return true;
}"
234,Closure,121,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1053.json,Medium,src/com/google/javascript/jscomp/InlineVariables.java,254,329,"private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;
    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
            // Create a new node for variable that is never initialized.
            Node srcLocation = declaration.getNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            // The only reference is the initialization, remove the assignment and
            // the variable declaration.
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
    // the next pass.)
    if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime() && // the variable is declared constant.
    (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; /* start from a read */
        i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }
}"
235,Closure,122,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1037.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,251,259,"/**
 * Check to see if the given block comment looks like it should be JSDoc.
 */
private void handleBlockComment(Comment comment) {
    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
    if (p.matcher(comment.getValue()).find()) {
        errorReporter.warning(SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), """", 0);
    }
}"
236,Closure,123,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1033.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,107,771,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = getContextForNoInOperator(context);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}"
237,Closure,124,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1017.json,Medium,src/com/google/javascript/jscomp/ExploitAssigns.java,206,222,"/**
 * Checks name referenced in node to determine if it might have
 * changed.
 * @return Whether the replacement can be made.
 */
private boolean isSafeReplacement(Node node, Node replacement) {
    // No checks are needed for simple names.
    if (node.isName()) {
        return true;
    }
    Preconditions.checkArgument(node.isGetProp());
    while (node.isGetProp()) {
        node = node.getFirstChild();
    }
    if (node.isName() && isNameAssignedTo(node.getString(), replacement)) {
        return false;
    }
    return true;
}"
238,Closure,125,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1002.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,1656,1671,"/**
 * Visits a NEW node.
 */
private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
        FunctionType fnType = type.toMaybeFunctionType();
        if (fnType != null && fnType.hasInstanceType()) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else {
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}"
239,Closure,126,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-936.json,Medium,src/com/google/javascript/jscomp/MinimizeExitPoints.java,106,197,"/**
 * Attempts to minimize the number of explicit exit points in a control
 * structure to take advantage of the implied exit at the end of the
 * structure.  This is accomplished by removing redundant statements, and
 * moving statements following a qualifying IF node into that node.
 * For example:
 *
 * function () {
 *   if (x) return;
 *   else blah();
 *   foo();
 * }
 *
 * becomes:
 *
 * function () {
 *  if (x) ;
 *  else {
 *    blah();
 *    foo();
 *  }
 *
 * @param n The execution node of a parent to inspect.
 * @param exitType The type of exit to look for.
 * @param labelName If parent is a label the name of the label to look for,
 *   null otherwise.
 * @nullable labelName non-null only for breaks within labels.
 */
void tryMinimizeExits(Node n, int exitType, String labelName) {
    // Just an 'exit'.
    if (matchingExitNode(n, exitType, labelName)) {
        NodeUtil.removeChild(n.getParent(), n);
        compiler.reportCodeChange();
        return;
    }
    // Just an 'if'.
    if (n.isIf()) {
        Node ifBlock = n.getFirstChild().getNext();
        tryMinimizeExits(ifBlock, exitType, labelName);
        Node elseBlock = ifBlock.getNext();
        if (elseBlock != null) {
            tryMinimizeExits(elseBlock, exitType, labelName);
        }
        return;
    }
    // Just a 'try/catch/finally'.
    if (n.isTry()) {
        Node tryBlock = n.getFirstChild();
        tryMinimizeExits(tryBlock, exitType, labelName);
        Node allCatchNodes = NodeUtil.getCatchBlock(n);
        if (NodeUtil.hasCatchHandler(allCatchNodes)) {
            Preconditions.checkState(allCatchNodes.hasOneChild());
            Node catchNode = allCatchNodes.getFirstChild();
            Node catchCodeBlock = catchNode.getLastChild();
            tryMinimizeExits(catchCodeBlock, exitType, labelName);
        }
    /* Don't try to minimize the exits of finally blocks, as this
       * can cause problems if it changes the completion type of the finally
       * block. See ECMA 262 Sections 8.9 & 12.14
       */
    }
    // Just a 'label'.
    if (n.isLabel()) {
        Node labelBlock = n.getLastChild();
        tryMinimizeExits(labelBlock, exitType, labelName);
    }
    // The rest assumes a block with at least one child, bail on anything else.
    if (!n.isBlock() || n.getLastChild() == null) {
        return;
    }
    // which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
    for (Node c : n.children()) {
        // An 'if' block to process below.
        if (c.isIf()) {
            Node ifTree = c;
            Node trueBlock, falseBlock;
            // First, the true condition block.
            trueBlock = ifTree.getFirstChild().getNext();
            falseBlock = trueBlock.getNext();
            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);
            // Now the else block.
            // The if blocks may have changed, get them again.
            trueBlock = ifTree.getFirstChild().getNext();
            falseBlock = trueBlock.getNext();
            if (falseBlock != null) {
                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);
            }
        }
        if (c == n.getLastChild()) {
            break;
        }
    }
    // look at what has become the last child.
    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
        tryMinimizeExits(c, exitType, labelName);
        // If the node is still the last child, we are done.
        if (c == n.getLastChild()) {
            break;
        }
    }
}"
240,Closure,127,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-936.json,Medium,src/com/google/javascript/jscomp/UnreachableCodeElimination.java,128,175,"/**
 * Tries to remove n if it is an unconditional branch node (break, continue,
 * or return) and the target of n is the same as the the follow of n.
 * That is, if removing n preserves the control flow. Also if n targets
 * another unconditional branch, this function will recursively try to
 * remove the target branch as well. The reason why we want to cascade this
 * removal is because we only run this pass once. If we have code such as
 *
 * break -> break -> break
 *
 * where all 3 breaks are useless, then the order of removal matters. When
 * we first look at the first break, we see that it branches to the 2nd
 * break. However, if we remove the last break, the 2nd break becomes
 * useless and finally the first break becomes useless as well.
 *
 * @returns The target of this jump. If the target is also useless jump,
 *     the target of that useless jump recursively.
 */
@SuppressWarnings(""fallthrough"")
private void tryRemoveUnconditionalBranching(Node n) {
    // If n is null the target is the end of the function, nothing to do.
    if (n == null) {
        return;
    }
    DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);
    if (gNode == null) {
        return;
    }
    switch(n.getType()) {
        case Token.RETURN:
            if (n.hasChildren()) {
                break;
            }
        case Token.BREAK:
        case Token.CONTINUE:
            // We are looking for a control flow changing statement that always
            // branches to the same node. If after removing it control still
            // branches to the same node, it is safe to remove.
            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();
            if (outEdges.size() == 1 && // If there is a next node, this jump is not useless.
            (n.getNext() == null || n.getNext().isFunction())) {
                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
                Node fallThrough = computeFollowing(n);
                Node nextCfgNode = outEdges.get(0).getDestination().getValue();
                if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
                    removeNode(n);
                }
            }
    }
}"
241,Closure,127,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-936.json,Medium,src/com/google/javascript/jscomp/UnreachableCodeElimination.java,177,185,"private boolean inFinally(Node parent, Node child) {
    if (parent == null || parent.isFunction()) {
        return false;
    } else if (NodeUtil.isTryFinallyNode(parent, child)) {
        return true;
    } else {
        return inFinally(parent.getParent(), parent);
    }
}"
242,Closure,128,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-942.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,783,795,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    if (len == 0) {
        return false;
    }
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len == 1 || s.charAt(0) != '0';
}"
243,Closure,129,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-937.json,Medium,src/com/google/javascript/jscomp/PrepareAst.java,158,180,"/**
 * There are two types of calls we are interested in calls without explicit
 * ""this"" values (what we are call ""free"" calls) and direct call to eval.
 */
private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());
    // Keep track of of the ""this"" context of a call.  A call without an
    // explicit ""this"" is a free call.
    Node first = n.getFirstChild();
    // ignore cast nodes.
    while (first.isCast()) {
        first = first.getFirstChild();
    }
    if (!NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }
    // to distinguish between ""(0, eval)()"" and ""eval()"".
    if (first.isName() && ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}"
244,Closure,130,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-931.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,161,197,"/**
 * For each qualified name N in the global scope, we check if:
 * (a) No ancestor of N is ever aliased or assigned an unknown value type.
 *     (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased).
 * (b) N has exactly one write, and it lives in the global scope.
 * (c) N is aliased in a local scope.
 *
 * If (a) is true, then GlobalNamespace must know all the writes to N.
 * If (a) and (b) are true, then N cannot change during the execution of
 *    a local scope.
 * If (a) and (b) and (c) are true, then the alias can be inlined if the
 *    alias obeys the usual rules for how we decide whether a variable is
 *    inlineable.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();
        // Don't attempt to inline a getter or setter property as a variable.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }
        if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                    }
                }
            }
        }
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}"
245,Closure,131,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-921.json,Medium,src/com/google/javascript/rhino/TokenStream.java,190,207,"public static boolean isJSIdentifier(String s) {
    int length = s.length();
    if (length == 0 || Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }
    for (int i = 1; i < length; i++) {
        if (Character.isIdentifierIgnorable(s.charAt(i)) || !Character.isJavaIdentifierPart(s.charAt(i))) {
            return false;
        }
    }
    return true;
}"
246,Closure,132,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-925.json,Medium,src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,636,870,"/**
 * Try turning IF nodes into smaller HOOKs
 *
 * Returns the replacement for n or the original if no replacement was
 * necessary.
 */
private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();
    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                // until CollapseProperties has been run.
                return n;
            }
            if (cond.isNot()) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return n;
                }
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                // we can further optimize its parent.
                return n;
            }
            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else {
            // Try to combine two IF-ELSE
            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
                Node innerIf = thenBranch.getFirstChild();
                if (innerIf.isIf()) {
                    Node innerCond = innerIf.getFirstChild();
                    Node innerThenBranch = innerCond.getNext();
                    Node innerElseBranch = innerThenBranch.getNext();
                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                        n.detachChildren();
                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                        n.addChildrenToBack(innerThenBranch.detachFromParent());
                        reportCodeChange();
                        // the inner IF-ELSE wasn't able to be folded into && anyways.
                        return n;
                    }
                }
            }
        }
        return n;
    }
    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...
                !mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
        // if(x)foo();else bar(); -> x?foo():bar()
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }
    return n;
}"
247,Closure,133,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-919.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,2399,2403,"/**
 * Returns the remainder of the line.
 */
private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    unreadToken = NO_UNREAD_TOKEN;
    return result;
}"
248,Closure,134,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-86.json,Medium,src/com/google/javascript/jscomp/AmbiguateProperties.java,195,248,"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}"
249,Closure,134,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-86.json,Medium,src/com/google/javascript/jscomp/AmbiguateProperties.java,351,356,"/**
 * Returns true if prop is in an independent set from all properties in
 * this sub graph.  That is, if none of its types is contained in the
 * related types for this sub graph and if none if its related types is one
 * of the types in the sub graph.
 */
public boolean isIndependentOf(Property prop) {
    if (typesRelatedToSet.intersects(prop.typesSet)) {
        return false;
    }
    return !prop.relatedTypesSet.intersects(typesInSet);
}"
250,Closure,134,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-86.json,Medium,src/com/google/javascript/jscomp/AmbiguateProperties.java,363,366,"/**
 * Adds the node to the sub graph, adding all of its types to the set of
 * types in the sub graph and all of its related types to the related types
 * for the sub graph.
 */
public void addNode(Property prop) {
    typesInSet.or(prop.typesSet);
    typesRelatedToSet.or(prop.relatedTypesSet);
}"
251,Closure,134,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-86.json,Medium,src/com/google/javascript/jscomp/AmbiguateProperties.java,587,599,"private void addNonUnionType(JSType newType) {
    if (skipAmbiguating || isInvalidatingType(newType)) {
        skipAmbiguating = true;
        return;
    }
    int typeInt = getIntForType(newType);
    if (!typesSet.get(typeInt)) {
        computeRelatedTypes(newType);
        typesSet.set(typeInt);
        relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));
    }
}"
252,Closure,134,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-86.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,553,573,"/**
 * Find the function that's being overridden on this type, if any.
 */
private FunctionType findOverriddenFunction(ObjectType ownerType, String propName) {
    // First, check to see if the property is implemented
    // on a superclass.
    JSType propType = ownerType.getPropertyType(propName);
    if (propType instanceof FunctionType) {
        return (FunctionType) propType;
    } else {
        // on an implemented interface.
        for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) {
            propType = iface.getPropertyType(propName);
            if (propType instanceof FunctionType) {
                return (FunctionType) propType;
            }
        }
    }
    return null;
}"
253,Closure,135,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-59.json,Medium,src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java,354,368,"/**
 * Replaces references to ""this"" with references to name.  Do not
 * traverse function boundaries.
 */
private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
        return;
    }
    for (Node child : node.children()) {
        if (NodeUtil.isThis(child)) {
            Node newName = Node.newString(Token.NAME, name);
            newName.setJSType(child.getJSType());
            node.replaceChild(child, newName);
        } else {
            replaceReferencesToThis(child, name);
        }
    }
}"
254,Closure,135,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-59.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,412,415,"@Override
public boolean hasOwnProperty(String name) {
    return super.hasOwnProperty(name) || ""prototype"".equals(name);
}"
255,Closure,135,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-59.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,470,487,"@Override
boolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (objType.equals(prototype)) {
                return true;
            }
            return setPrototype(new FunctionPrototypeType(registry, this, objType, isNativeObjectType()));
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, inExterns);
}"
256,Closure,136,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-103.json,Medium,src/com/google/javascript/jscomp/MethodCompilerPass.java,101,108,"/**
 * Adds a node that may represent a function signature (if it's a function
 * itself or the name of a function).
 */
private void addPossibleSignature(String name, Node node, NodeTraversal t) {
    if (node.getType() == Token.FUNCTION) {
        // The node we're looking at is a function, so we can add it directly
        addSignature(name, node, t.getSourceName());
    } else {
        nonMethodProperties.add(name);
    }
}"
257,Closure,136,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-103.json,Medium,src/com/google/javascript/jscomp/RenameVars.java,170,234,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() != Token.NAME) {
        return;
    }
    String name = n.getString();
    // Ignore anonymous functions
    if (name.length() == 0) {
        return;
    }
    // Is this local or Global?
    Scope.Var var = t.getScope().getVar(name);
    boolean local = (var != null) && var.isLocal();
    // Are we renaming global variables?
    if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
    }
    // Are we renaming anonymous function names?
    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
    }
    // Check if we can rename this.
    if (!okToRenameVar(name, local)) {
        if (local) {
            // Blindly de-uniquify for the Prototype library for issue 103.
            String newName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
            if (!newName.equals(name)) {
                n.setString(newName);
            }
        }
        return;
    }
    if (isExternsPass_) {
        // Keep track of extern globals.
        if (!local) {
            externNames.add(name);
        }
        return;
    }
    if (local) {
        // Local var: assign a new name
        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
    } else if (var != null) {
        // Not an extern
        // If it's global, increment global count
        incCount(name, var.input);
        globalNameNodes.add(n);
    }
}"
258,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,273,280,"/**
 * Prepare a set for the new scope.
 */
public void enterScope(NodeTraversal t) {
    if (t.inGlobalScope()) {
        return;
    }
    referenceStack.push(referencedNames);
    referencedNames = Sets.newHashSet();
}"
259,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,286,306,"/**
 * Rename vars for the current scope, and merge any referenced
 * names into the parent scope reference set.
 */
public void exitScope(NodeTraversal t) {
    if (t.inGlobalScope()) {
        return;
    }
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {
        Var v = it.next();
        handleScopeVar(v);
    }
    // Merge any names that were referenced but not declared in the current
    // scope.
    Set<String> current = referencedNames;
    referencedNames = referenceStack.pop();
    // global scope.
    if (!referenceStack.isEmpty()) {
        referencedNames.addAll(current);
    }
}"
260,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,313,335,"/**
 * For the Var declared in the current scope determine if it is possible
 * to revert the name to its orginal form without conflicting with other
 * values.
 */
void handleScopeVar(Var v) {
    String name = v.getName();
    if (containsSeparator(name)) {
        String newName = getOrginalName(name);
        // Check if the new name is valid and if it would cause conflicts.
        if (TokenStream.isJSIdentifier(newName) && !referencedNames.contains(newName) && !newName.equals(ARGUMENTS)) {
            referencedNames.remove(name);
            // Adding a reference to the new name to prevent either the parent
            // scopes or the current scope renaming another var to this new name.
            referencedNames.add(newName);
            List<Node> references = nameMap.get(name);
            Preconditions.checkState(references != null);
            for (Node n : references) {
                Preconditions.checkState(n.getType() == Token.NAME);
                n.setString(newName);
            }
            compiler.reportCodeChange();
        }
        nameMap.remove(name);
    }
}"
261,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,337,340,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    return true;
}"
262,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,342,358,"@Override
public void visit(NodeTraversal t, Node node, Node parent) {
    if (t.inGlobalScope()) {
        return;
    }
    if (NodeUtil.isReferenceName(node)) {
        String name = node.getString();
        // Add all referenced names to the set so it is possible to check for
        // conflicts.
        referencedNames.add(name);
        // Store only references to candidate names in the node map.
        if (containsSeparator(name)) {
            addCandidateNameReference(name, node);
        }
    }
}"
263,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,360,367,"private void addCandidateNameReference(String name, Node n) {
    List<Node> nodes = nameMap.get(name);
    if (null == nodes) {
        nodes = Lists.newLinkedList();
        nameMap.put(name, nodes);
    }
    nodes.add(n);
}"
264,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,412,429,"/**
 * Adds a name to the map of names declared in this scope.
 */
@Override
public void addDeclaredName(String name) {
    if (!name.equals(ARGUMENTS)) {
        if (global) {
            reserveName(name);
        } else {
            // It hasn't been declared locally yet, so increment the count.
            if (!declarations.containsKey(name)) {
                int id = incrementNameCount(name);
                String newName = null;
                if (id != 0) {
                    newName = getUniqueName(name, id);
                }
                declarations.put(name, newName);
            }
        }
    }
}"
265,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,484,490,"@Override
public void addDeclaredName(String name) {
    Preconditions.checkState(!name.equals(ARGUMENTS));
    if (!declarations.containsKey(name)) {
        declarations.put(name, getUniqueName(name));
    }
}"
266,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,1043,1045,"/**
 * @return Whether the name is a reference to a variable, function or
 *       function parameter (not a label or a empty anonymous function name).
 */
static boolean isReferenceName(Node n) {
    return isName(n) && !n.getString().isEmpty() && !isLabelName(n);
}"
267,Closure,137,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/Normalize.java,78,104,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    // function f() {
    // try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    // var e = 1; // f scope 'e'
    // }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(root);
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}"
268,Closure,138,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java,200,223,"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    if (condition.getType() == CALL && condition.getChildCount() == 2) {
        Node callee = condition.getFirstChild();
        Node param = condition.getLastChild();
        if (callee.getType() == GETPROP && param.isQualifiedName()) {
            JSType paramType = getTypeIfRefinable(param, blindScope);
            Node left = callee.getFirstChild();
            Node right = callee.getLastChild();
            if (left.getType() == NAME && ""goog"".equals(left.getString()) && right.getType() == STRING) {
                Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());
                if (restricter != null) {
                    return restrictParameter(param, paramType, blindScope, restricter, outcome);
                }
            }
        }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}"
269,Closure,138,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,621,660,"private FlowScope traverseName(Node n, FlowScope scope) {
    String varName = n.getString();
    Node value = n.getFirstChild();
    JSType type = n.getJSType();
    if (value != null) {
        scope = traverse(value, scope);
        updateScopeForTypeChange(scope, n, n.getJSType(), /* could be null */
        getJSType(value));
        return scope;
    } else {
        StaticSlot<JSType> var = scope.getSlot(varName);
        if (var != null) {
            // There are two situations where we don't want to use type information
            // from the scope, even if we have it.
            // 1) The var is escaped in a weird way, e.g.,
            // function f() { var x = 3; function g() { x = null } (x); }
            boolean isInferred = var.isTypeInferred();
            boolean unflowable = isInferred && unflowableVarNames.contains(varName);
            // 2) We're reading type information from another scope for an
            // inferred variable.
            // var t = null; function f() { (t); }
            boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName);
            if (!unflowable && !nonLocalInferredSlot) {
                type = var.getType();
                if (type == null) {
                    type = getNativeType(UNKNOWN_TYPE);
                }
            }
        }
    }
    n.setJSType(type);
    return scope;
}"
270,Closure,139,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-33.json,Medium,src/com/google/javascript/jscomp/Normalize.java,268,285,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.WHILE:
            if (CONVERT_WHILE_TO_FOR) {
                Node expr = n.getFirstChild();
                n.setType(Token.FOR);
                n.addChildBefore(new Node(Token.EMPTY), expr);
                n.addChildAfter(new Node(Token.EMPTY), expr);
                reportCodeChange(""WHILE node"");
            }
            break;
        case Token.FUNCTION:
            normalizeFunctionDeclaration(n);
            break;
    }
}"
271,Closure,139,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-33.json,Medium,src/com/google/javascript/jscomp/Normalize.java,295,301,"/**
 * Rewrite named unhoisted functions declarations to a known
 * consistent behavior so we don't to different logic paths for the same
 * code. From:
 *    function f() {}
 * to:
 *    var f = function () {};
 */
private void normalizeFunctionDeclaration(Node n) {
    Preconditions.checkState(n.getType() == Token.FUNCTION);
    if (!NodeUtil.isFunctionAnonymous(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) {
        rewriteFunctionDeclaration(n);
    }
}"
272,Closure,139,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-33.json,Medium,src/com/google/javascript/jscomp/Normalize.java,319,335,"/**
 * Rewrite the function declaration from:
 *   function x() {}
 *   FUNCTION
 *     NAME
 *     LP
 *     BLOCK
 * to:
 *   var x = function() {};
 *   VAR
 *     NAME
 *       FUNCTION
 *         NAME (w/ empty string)
 *         LP
 *         BLOCK
 */
private void rewriteFunctionDeclaration(Node n) {
    // Prepare a spot for the function.
    Node oldNameNode = n.getFirstChild();
    Node fnNameNode = oldNameNode.cloneNode();
    Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno());
    var.copyInformationFrom(n);
    // Prepare the function
    oldNameNode.setString("""");
    // Move the function
    Node parent = n.getParent();
    parent.replaceChild(n, var);
    fnNameNode.addChildToFront(n);
    reportCodeChange(""Function declaration"");
}"
273,Closure,139,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-33.json,Medium,src/com/google/javascript/jscomp/Normalize.java,537,558,"/**
 * Remove duplicate VAR declarations encountered discovered during
 * scope creation.
 */
@Override
public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Var v = s.getVar(name);
    // If name is ""arguments"", Var maybe null.
    Preconditions.checkState(v == null || v.getParentNode().getType() != Token.CATCH);
    if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());
        replaceVarWithAssignment(n, parent, gramps);
    }
}"
274,Closure,141,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-116.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,584,616,"/**
 * @param knownConstants A set of names known to be constant value at
 * node 'n' (such as locals that are last written before n can execute).
 * @return Whether the tree can be affected by side-effects or
 * has side-effects.
 */
static boolean canBeSideEffected(Node n, Set<String> knownConstants) {
    switch(n.getType()) {
        case Token.CALL:
        case Token.NEW:
            // are unaffected by side effects.
            return true;
        case Token.NAME:
            // Non-constant names values may have been changed.
            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());
        // Properties on constant NAMEs can still be side-effected.
        case Token.GETPROP:
        case Token.GETELEM:
            return true;
        case Token.FUNCTION:
            // Anonymous functions definitions are not changed by side-effects,
            // and named functions are not part of expressions.
            Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
            return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (canBeSideEffected(c, knownConstants)) {
            return true;
        }
    }
    return false;
}"
275,Closure,141,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-116.json,Medium,src/com/google/javascript/jscomp/PureFunctionIdentifier.java,175,217,"/**
 * Query the DefinitionProvider for the list of definitions that
 * correspond to a given qualified name subtree.  Return null if
 * DefinitionProvider does not contain an entry for a given name,
 * one or more of the values returned by getDeclarations is not
 * callable, or the ""name"" node is not a GETPROP or NAME.
 *
 * @param definitionProvider The name reference graph
 * @param name Query node
 * @return non-empty definition list or null
 */
private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {
    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {
        List<Definition> result = Lists.newArrayList();
        Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);
        if (decls == null) {
            return null;
        }
        for (Definition current : decls) {
            Node rValue = current.getRValue();
            if ((rValue != null) && NodeUtil.isFunction(rValue)) {
                result.add(current);
            } else {
                return null;
            }
        }
        return result;
    } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
        Node firstVal;
        if (name.getType() == Token.HOOK) {
            firstVal = name.getFirstChild().getNext();
        } else {
            firstVal = name.getFirstChild();
        }
        Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal);
        Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext());
        if (defs1 != null && defs2 != null) {
            defs1.addAll(defs2);
            return defs1;
        } else {
            return null;
        }
    } else {
        return null;
    }
}"
276,Closure,142,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-58.json,Medium,src/com/google/javascript/jscomp/CoalesceVariableNames.java,90,123,"@Override
public void enterScope(NodeTraversal t) {
    // TODO(user): We CAN do this in the global scope, just need to be
    // careful when something is exported. Liveness uses bit-vector for live
    // sets so I don't see compilation time will be a problem for running this
    // pass in the global scope.
    Scope scope = t.getScope();
    if (scope.isGlobal()) {
        return;
    }
    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();
    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);
    // http://code.google.com/p/closure-compiler/issues/detail?id=58
    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {
        liveness.markAllParametersEscaped();
    }
    liveness.analyze();
    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());
    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);
    coloring.color();
    colorings.push(coloring);
}"
277,Closure,142,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-58.json,Medium,src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,1112,1209,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    do {
        switch(token) {
            case STAR:
                if (!ignoreStar) {
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;
            case ANNOTATION:
            case EOC:
            case EOF:
                // in the block are ok.
                if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}"
278,Closure,143,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-139.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,847,896,"/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */
@VisibleForTesting
static void createDefineReplacements(List<String> definitions, CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            if (assignment.length == 1) {
                options.setDefineToBooleanLiteral(defName, true);
                continue;
            } else {
                String defValue = assignment[1];
                if (defValue.equals(""true"")) {
                    options.setDefineToBooleanLiteral(defName, true);
                    continue;
                } else if (defValue.equals(""false"")) {
                    options.setDefineToBooleanLiteral(defName, false);
                    continue;
                } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                    // If the value starts and ends with a single quote,
                    // we assume that it's a string.
                    String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                    if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                        continue;
                    }
                } else {
                    try {
                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));
                        continue;
                    } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                    }
                }
            }
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}"
279,Closure,143,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-139.json,Medium,src/com/google/javascript/jscomp/RemoveConstantExpressions.java,84,95,"/**
 * Attempts to replace the input node with a simpler but functionally
 * equivalent set of nodes.
 */
private void trySimplify(Node parent, Node node) {
    if (node.getType() != Token.EXPR_RESULT) {
        return;
    }
    Node exprBody = node.getFirstChild();
    if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody) || exprBody.getType() == Token.NEW || exprBody.getType() == Token.CALL) {
        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));
    }
}"
280,Closure,144,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json,Medium,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,199,208,"/**
 * Infer the return type from JSDocInfo.
 */
FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
    returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : null;
    if (templateTypeName != null && returnType != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    return this;
}"
281,Closure,144,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json,Medium,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,214,244,"/**
 * If we haven't found a return value yet, try to look at the ""return""
 * statements in the function.
 */
FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) {
    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {
        return this;
    }
    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);
    if (returnType == null) {
        boolean hasNonEmptyReturns = false;
        List<Node> worklist = Lists.newArrayList(functionBlock);
        while (!worklist.isEmpty()) {
            Node current = worklist.remove(worklist.size() - 1);
            int cType = current.getType();
            if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) {
                hasNonEmptyReturns = true;
                break;
            } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) {
                for (Node child = current.getFirstChild(); child != null; child = child.getNext()) {
                    worklist.add(child);
                }
            }
        }
        if (!hasNonEmptyReturns) {
            returnType = typeRegistry.getNativeType(VOID_TYPE);
            returnTypeInferred = true;
        }
    }
    return this;
}"
282,Closure,144,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json,Medium,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,503,541,"/**
 * Builds the function type, and puts it in the registry.
 */
FunctionType buildAndRegister() {
    if (returnType == null) {
        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }
    if (parametersNode == null) {
        throw new IllegalStateException(""All Function types must have params and a return type"");
    }
    FunctionType fnType;
    if (isConstructor) {
        fnType = getOrCreateConstructor();
    } else if (isInterface) {
        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
        if (scope.isGlobal() && !fnName.isEmpty()) {
            typeRegistry.declareType(fnName, fnType.getInstanceType());
        }
        maybeSetBaseType(fnType);
    } else {
        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();
        maybeSetBaseType(fnType);
    }
    if (implementedInterfaces != null) {
        fnType.setImplementedInterfaces(implementedInterfaces);
    }
    typeRegistry.clearTemplateTypeName();
    return fnType;
}"
283,Closure,144,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,550,647,"/**
 * Gets the function type from the function node and its attached
 * {@link JSDocInfo}.
 * @param name the function's name
 * @param rValue the function node. It must be a {@link Token#FUNCTION}.
 * @param info the {@link JSDocInfo} attached to the function definition
 * @param lvalueNode The node where this function is being
 *     assigned. For example, {@code A.prototype.foo = ...} would be used to
 *     determine that this function is a method of A.prototype. May be
 *     null to indicate that this is not being assigned to a qualified name.
 */
private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
    FunctionType functionType = null;
    // Handle function aliases.
    if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
            functionType = (FunctionType) var.getType();
            if (functionType != null && functionType.isConstructor()) {
                typeRegistry.declareType(name, functionType.getInstanceType());
            }
        }
        return functionType;
    }
    Node owner = null;
    if (lvalueNode != null) {
        owner = getPrototypePropertyOwner(lvalueNode);
    }
    Node errorRoot = rValue == null ? lvalueNode : rValue;
    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;
    Node fnRoot = isFnLiteral ? rValue : null;
    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;
    Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;
    if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);
        // Known to be not null since we have the FUNCTION token there.
        type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
            functionType = (FunctionType) type;
            functionType.setJSDocInfo(info);
        }
    }
    if (functionType == null) {
        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
            // to this function.
            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {
                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());
                if (var != null) {
                    ObjectType ownerType = ObjectType.cast(var.getType());
                    FunctionType propType = null;
                    if (ownerType != null) {
                        String propName = lvalueNode.getLastChild().getString();
                        propType = findOverriddenFunction(ownerType, propName);
                    }
                    if (propType != null) {
                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).inferReturnStatements(fnBlock).buildAndRegister();
                    }
                }
            }
        }
    }
    if (functionType == null) {
        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).inferReturnStatements(fnBlock).buildAndRegister();
    }
    // assigning the function type to the function node
    if (rValue != null) {
        setDeferredType(rValue, functionType);
    }
    // all done
    return functionType;
}"
284,Closure,144,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json,Medium,src/com/google/javascript/rhino/jstype/FunctionBuilder.java,101,105,"/**
 * Set the return type and whether it's inferred.
 */
public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {
    this.returnType = returnType;
    this.inferredReturnType = inferred;
    return this;
}"
285,Closure,144,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,515,521,"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
    return new FunctionType(registry, null, source, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);
}"
286,Closure,145,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-190.json,High,src/com/google/javascript/jscomp/CodeGenerator.java,708,728,"/**
 * @return Whether the Node is a DO or FUNCTION (with or without
 * labels).
 */
private boolean isOneExactlyFunctionOrDo(Node n) {
    if (n.getType() == Token.LABEL) {
        Node labeledStatement = n.getLastChild();
        if (labeledStatement.getType() != Token.BLOCK) {
            return isOneExactlyFunctionOrDo(labeledStatement);
        } else {
            // are skipped.
            if (getNonEmptyChildCount(n, 2) == 1) {
                return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));
            } else {
                // way it isn't a FUNCTION or DO.
                return false;
            }
        }
    } else {
        return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);
    }
}"
287,Closure,146,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-172.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,696,716,"/**
 * Computes the subset of {@code this} and {@code that} types if inequality
 * is observed. If a value {@code v1} of type {@code number} is not equal to a
 * value {@code v2} of type {@code (undefined,number)}, we can infer that the
 * type of {@code v1} is {@code number} and the type of {@code v2} is
 * {@code number} as well.
 *
 * @return a pair containing the restricted type of {@code this} as the first
 *         component and the restricted type of {@code that} as the second
 *         element. The returned pair is never {@code null} even though its
 *         components may be {@code null}
 */
public TypePair getTypesUnderInequality(JSType that) {
    // unions types
    if (that instanceof UnionType) {
        TypePair p = that.getTypesUnderInequality(this);
        return new TypePair(p.typeB, p.typeA);
    }
    // other types
    switch(this.testForEquality(that)) {
        case TRUE:
            JSType noType = getNativeType(JSTypeNative.NO_TYPE);
            return new TypePair(noType, noType);
        case FALSE:
        case UNKNOWN:
            return new TypePair(this, that);
    }
    // switch case is exhaustive
    throw new IllegalStateException();
}"
288,Closure,147,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-182.json,Medium,src/com/google/javascript/jscomp/CheckGlobalThis.java,84,143,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || pType == Token.OBJECTLIT)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}"
289,Closure,147,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-182.json,Medium,src/com/google/javascript/jscomp/RuntimeTypeCheck.java,239,279,"/**
 * Insert checks for the parameters of the function.
 */
private void visitFunction(NodeTraversal t, Node n) {
    FunctionType funType = (FunctionType) n.getJSType();
    Node block = n.getLastChild();
    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();
    Node insertionPoint = null;
    // added after any inner function declarations.
    for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) {
        insertionPoint = next;
    }
    for (Node paramType : funType.getParameters()) {
        // Can this ever happen?
        if (paramName == null) {
            return;
        }
        Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree());
        if (checkNode == null) {
            // We don't know how to check this parameter type.
            paramName = paramName.getNext();
            continue;
        }
        checkNode = new Node(Token.EXPR_RESULT, checkNode);
        if (insertionPoint == null) {
            block.addChildToFront(checkNode);
        } else {
            block.addChildAfter(checkNode, insertionPoint);
        }
        compiler.reportCodeChange();
        paramName = paramName.getNext();
        insertionPoint = checkNode;
    }
}"
290,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,156,203,"/**
 * Folds 'typeof(foo)' if foo is a literal, e.g.
 * typeof(""bar"") --> ""string""
 * typeof(6) --> ""number""
 */
private Node tryFoldTypeof(Node originalTypeofNode) {
    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);
    Node argumentNode = originalTypeofNode.getFirstChild();
    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
        return originalTypeofNode;
    }
    String typeNameString = null;
    switch(argumentNode.getType()) {
        case Token.STRING:
            typeNameString = ""string"";
            break;
        case Token.NUMBER:
            typeNameString = ""number"";
            break;
        case Token.TRUE:
        case Token.FALSE:
            typeNameString = ""boolean"";
            break;
        case Token.NULL:
        case Token.OBJECTLIT:
        case Token.ARRAYLIT:
            typeNameString = ""object"";
            break;
        case Token.VOID:
            typeNameString = ""undefined"";
            break;
        case Token.NAME:
            // keyword undefined to something other than the value undefined.
            if (""undefined"".equals(argumentNode.getString())) {
                typeNameString = ""undefined"";
            }
            break;
    }
    if (typeNameString != null) {
        Node newNode = Node.newString(typeNameString);
        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);
        reportCodeChange();
        return newNode;
    }
    return originalTypeofNode;
}"
291,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,101,135,"/**
 * Appends the mapping to the given buffer.
 */
private void appendMappingTo(Mapping m, Appendable out) throws IOException {
    out.append(""["");
    String sourceFile = m.sourceFile;
    // The source file rarely changes, so cache the escaped string.
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
        // yes, s1 != s2, not !s1.equals(s2)
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
    out.append(escapedSourceFile);
    out.append("","");
    int line = m.originalPosition.getLineNumber();
    if (line != lastLine) {
        lastLineString = String.valueOf(line);
    }
    String lineValue = lastLineString;
    out.append(lineValue);
    out.append("","");
    out.append(String.valueOf(m.originalPosition.getCharacterIndex()));
    if (m.originalName != null) {
        out.append("","");
        out.append(escapeString(m.originalName));
    }
    out.append(""]\n"");
}"
292,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,140,146,"/**
 * Add used mappings to the supplied Appendable.
 */
void appendMappings(Appendable out) throws IOException {
    for (Mapping m : mappings) {
        if (m.used) {
            appendMappingTo(m, out);
        }
    }
}"
293,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,181,232,"/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */
void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    // Create the new mapping.
    Mapping mapping = new Mapping();
    mapping.sourceFile = sourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = originalName;
    }
    if (offsetPosition.getLineNumber() == 0 && offsetPosition.getCharacterIndex() == 0) {
        mapping.startPosition = startPosition;
        mapping.endPosition = endPosition;
    } else {
        // If the mapping is found on the first line, we need to offset
        // its character position by the number of characters found on
        // the *last* line of the source file to which the code is
        // being generated.
        int offsetLine = offsetPosition.getLineNumber();
        int startOffsetPosition = offsetPosition.getCharacterIndex();
        int endOffsetPosition = offsetPosition.getCharacterIndex();
        if (startPosition.getLineNumber() > 0) {
            startOffsetPosition = 0;
        }
        if (endPosition.getLineNumber() > 0) {
            endOffsetPosition = 0;
        }
        mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
        mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    }
    mappings.add(mapping);
}"
294,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,291,346,"/**
 * Appends the source map in LavaBug format to the given buffer.
 *
 * @param out The stream to which the map will be appended.
 * @param name The name of the generated source file that this source map
 *   represents.
 */
public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    // 
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    // 
    // The second section contains an array per generated line. Unused.
    // 
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    // 
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    // 
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
    // 11) [""c.js"", 1, 4]
    // 12) [""d.js"", 3, 78, ""foo""]
    int maxLine = prepMappings();
    // Add the line character maps.
    out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();
    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }
    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");
    (new MappingWriter()).appendMappings(out);
}"
295,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,351,368,"/**
 * Assigns sequential ids to used mappings, and returns the last line mapped.
 */
private int prepMappings() throws IOException {
    // Mark any unused mappings.
    (new MappingTraversal()).traverse(new UsedMappingCheck());
    // Renumber used mappings and keep track of the last line.
    int id = 0;
    int maxLine = 0;
    for (Mapping m : mappings) {
        if (m.used) {
            m.id = id++;
            int endPositionLine = m.endPosition.getLineNumber();
            maxLine = Math.max(maxLine, endPositionLine);
        }
    }
    // Adjust for the prefix.
    return maxLine + prefixPosition.getLineNumber();
}"
296,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,389,412,"/**
 * As each segment is visited write out the appropriate line mapping.
 */
public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException {
    int id = (m != null) ? m.id : UNMAPPED;
    if (lastId != id) {
        // Prevent the creation of unnecessary temporary stings for often
        // repeated values.
        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);
        lastId = id;
    }
    String idString = lastIdString;
    for (int i = line; i <= nextLine; i++) {
        if (i == nextLine) {
            for (int j = col; j < nextCol; j++) {
                addCharEntry(idString);
            }
            break;
        }
        closeLine();
        openLine();
    }
}"
297,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,415,425,"// Append the line mapping entries.
void appendLineMappings() throws IOException {
    Preconditions.checkState(!mappings.isEmpty());
    // Start the first line.
    openLine();
    (new MappingTraversal()).traverse(this);
    // And close the final line.
    closeLine();
}"
298,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,430,435,"/**
 * Begin the entry for a new line.
 */
private void openLine() throws IOException {
    if (out != null) {
        out.append(""["");
        this.firstChar = true;
    }
}"
299,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,440,444,"/**
 * End the entry for a line.
 */
private void closeLine() throws IOException {
    if (out != null) {
        out.append(""]\n"");
    }
}"
300,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,450,459,"/**
 * Add a new char position entry.
 * @param id The mapping id to record.
 */
private void addCharEntry(String id) throws IOException {
    if (out != null) {
        if (firstChar) {
            firstChar = false;
        } else {
            out.append("","");
        }
        out.append(id);
    }
}"
301,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,469,475,"/**
 * @throws IOException
 */
@Override
public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException {
    if (m != null) {
        m.used = true;
    }
}"
302,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,488,489,"/**
 * @param m The mapping for the current code segment. null if the segment
 *     is unmapped.
 * @param line The starting line for this code segment.
 * @param col The starting column for this code segment.
 * @param endLine The ending line
 * @param endCol The ending column
 * @throws IOException
 */
void visit(Mapping m, int line, int col, int endLine, int endCol) throws IOException;"
303,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,505,536,"// Append the line mapping entries.
void traverse(MappingVisitor v) throws IOException {
    Preconditions.checkState(!mappings.isEmpty());
    // The mapping list is ordered as a pre-order traversal.  The mapping
    // positions give us enough information to rebuild the stack and this
    // allows the building of the source map in O(n) time.
    Deque<Mapping> stack = new ArrayDeque<Mapping>();
    for (Mapping m : mappings) {
        // closed in the reverse order of when they encountered.
        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {
            Mapping previous = stack.pop();
            maybeVisit(v, previous);
        }
        // Any gaps between the current line position and the start of the
        // current mapping belong to the parent.
        Mapping parent = stack.peek();
        maybeVisitParent(v, parent, m);
        stack.push(m);
    }
    // mappings in the reverse order of when they encountered.
    while (!stack.isEmpty()) {
        Mapping m = stack.pop();
        maybeVisit(v, m);
    }
}"
304,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,573,581,"/**
 * Write any needed entries from the current position to the end of the
 * provided mapping.
 */
private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {
    int nextLine = getAdjustedLine(m.endPosition);
    int nextCol = getAdjustedCol(m.endPosition);
    // current line and column position, write it out now.
    if (line < nextLine || (line == nextLine && col < nextCol)) {
        visit(v, m, nextLine, nextCol);
    }
}"
305,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,586,595,"/**
 * Write any needed entries to complete the provided mapping.
 */
private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m) throws IOException {
    int nextLine = getAdjustedLine(m.startPosition);
    int nextCol = getAdjustedCol(m.startPosition);
    // If the previous value is null, no mapping exists.
    Preconditions.checkState(line < nextLine || col <= nextCol);
    if (line < nextLine || (line == nextLine && col < nextCol)) {
        visit(v, parent, nextLine, nextCol);
    }
}"
306,Closure,148,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json,Medium,src/com/google/javascript/jscomp/SourceMap.java,601,617,"/**
 * Write any entries needed between the current position the next position
 * and update the current position.
 */
private void visit(MappingVisitor v, Mapping m, int nextLine, int nextCol) throws IOException {
    Preconditions.checkState(line <= nextLine);
    Preconditions.checkState(line < nextLine || col < nextCol);
    if (line == nextLine && col == nextCol) {
        // Nothing to do.
        Preconditions.checkState(false);
        return;
    }
    v.visit(m, line, col, nextLine, nextCol);
    line = nextLine;
    col = nextCol;
}"
307,Closure,149,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,141,180,"/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineReplacements(config.define, options);
    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
}"
308,Closure,149,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,505,543,"/**
 * Parses command-line arguments and runs the compiler.
 *
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
    List<JSSourceFile> externsList = createExterns();
    JSSourceFile[] externs = new JSSourceFile[externsList.size()];
    externsList.toArray(externs);
    compiler = createCompiler();
    B options = createOptions();
    JSModule[] modules = null;
    Result result;
    setRunOptions(options);
    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();
    if (writeOutputToFile) {
        out = toWriter(options.jsOutputFile, inputCharset.name());
    }
    List<String> jsFiles = config.js;
    List<String> moduleSpecs = config.module;
    if (!moduleSpecs.isEmpty()) {
        modules = createJsModules(moduleSpecs, jsFiles);
        result = compiler.compile(externs, modules, options);
    } else {
        List<JSSourceFile> inputList = createSourceInputs(jsFiles);
        JSSourceFile[] inputs = new JSSourceFile[inputList.size()];
        inputList.toArray(inputs);
        result = compiler.compile(externs, inputs, options);
    }
    int errCode = processResults(result, modules, options);
    // Close the output if we are writing to a file.
    if (writeOutputToFile) {
        ((Writer) out).close();
    }
    return errCode;
}"
309,Closure,149,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,689,698,"/**
 * Query the flag for the output charset.
 *
 * Let the outputCharset be the same as the input charset... except if
 * we're reading in UTF-8 by default.  By tradition, we've always
 * output ASCII to avoid various hiccups with different browsers,
 * proxies and firewalls.
 *
 * @return Name of the charset to use when writing outputs. Guaranteed to
 *    be a supported charset.
 * @throws FlagUsageException if flag is not a valid Charset name.
 */
private String getOutputCharset() throws FlagUsageException {
    if (!config.charset.isEmpty()) {
        if (!Charset.isSupported(config.charset)) {
            throw new FlagUsageException(config.charset + "" is not a valid charset name."");
        }
        return config.charset;
    }
    return ""US-ASCII"";
}"
310,Closure,149,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,454,472,"@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    options.closurePass = flags.process_closure_primitives;
    return options;
}"
311,Closure,149,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json,Medium,src/com/google/javascript/jscomp/Compiler.java,1355,1367,"/**
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;
    builder.setOutputCharset(charset);
    return builder.build();
}"
312,Closure,149,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json,Medium,src/com/google/javascript/jscomp/CompilerOptions.java,960,962,"/**
 * Sets the output charset by name.
 */
public void setOutputCharset(String charsetName) {
    this.outputCharset = charsetName;
}"
313,Closure,150,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-61.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1443,1452,"/**
 * Visit a node in a local scope, and add any local variables or catch
 * parameters into the local symbol table.
 *
 * @param t The node traversal.
 * @param n The node being visited.
 * @param parent The parent of n
 */
@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n == scope.getRootNode())
        return;
    if (n.getType() == Token.LP && parent == scope.getRootNode()) {
        handleFunctionInputs(parent);
        return;
    }
    super.visit(t, n, parent);
}"
314,Closure,151,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-74.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,390,469,"private void initConfigFromFlags(String[] args, PrintStream err) {
    // Args4j has a different format that the old command-line parser.
    // So we use some voodoo to get the args into the format that args4j
    // expects.
    Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
    Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
    List<String> processedArgs = Lists.newArrayList();
    for (String arg : args) {
        Matcher matcher = argPattern.matcher(arg);
        if (matcher.matches()) {
            processedArgs.add(matcher.group(1));
            String value = matcher.group(2);
            Matcher quotesMatcher = quotesPattern.matcher(value);
            if (quotesMatcher.matches()) {
                processedArgs.add(quotesMatcher.group(1));
            } else {
                processedArgs.add(value);
            }
        } else {
            processedArgs.add(arg);
        }
    }
    CmdLineParser parser = new CmdLineParser(flags);
    isConfigValid = true;
    try {
        parser.parseArgument(processedArgs.toArray(new String[] {}));
    } catch (CmdLineException e) {
        err.println(e.getMessage());
        isConfigValid = false;
    }
    if (flags.version) {
        ResourceBundle config = ResourceBundle.getBundle(configResource);
        err.println(""Closure Compiler (http://code.google.com/p/closure/compiler)\n"" + ""Version: "" + config.getString(""compiler.version"") + ""\n"" + ""Built on: "" + config.getString(""compiler.date""));
        err.flush();
    }
    if (!isConfigValid || flags.display_help) {
        isConfigValid = false;
        parser.printUsage(err);
    } else {
        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);
    }
}"
315,Closure,152,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-268.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,861,895,"@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);
    call = (ArrowType) safeResolve(call, t, scope);
    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);
    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    // TODO(nicksantos): Handle this correctly if we have a UnionType.
    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
    if (maybeTypeOfThis instanceof ObjectType) {
        typeOfThis = (ObjectType) maybeTypeOfThis;
    }
    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
        resolvedInterfaces.add(resolvedIface);
        changed |= (resolvedIface != iface);
    }
    if (changed) {
        implementedInterfaces = resolvedInterfaces.build();
    }
    if (subTypes != null) {
        for (int i = 0; i < subTypes.size(); i++) {
            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
        }
    }
    return super.resolveInternal(t, scope);
}"
316,Closure,153,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json,Medium,src/com/google/javascript/jscomp/Normalize.java,637,691,"/**
 * Remove duplicate VAR declarations encountered discovered during
 * scope creation.
 */
@Override
public void onRedeclaration(Scope s, String name, Node n, CompilerInput input) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Node parent = n.getParent();
    Var v = s.getVar(name);
    if (v != null && s.isGlobal()) {
        // in one browser but not in another.
        if (v.isExtern() && !input.isExtern()) {
            if (hasOkDuplicateDeclaration.add(v)) {
                return;
            }
        }
    }
    // If name is ""arguments"", Var maybe null.
    if (v != null && v.getParentNode().getType() == Token.CATCH) {
        // Redeclaration of a catch expression variable is hard to model
        // without support for ""with"" expressions.
        // The EcmaScript spec (section 12.14), declares that a catch
        // ""catch (e) {}"" is handled like ""with ({'e': e}) {}"" so that
        // ""var e"" would refer to the scope variable, but any following
        // reference would still refer to ""e"" of the catch expression.
        // Until we have support for this disallow it.
        // Currently the Scope object adds the catch expression to the
        // function scope, which is technically not true but a good
        // approximation for most uses.
        // TODO(johnlenz): Consider improving how scope handles catch
        // expression.
        // Use the name of the var before it was made unique.
        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
        compiler.report(JSError.make(input.getName(), n, CATCH_BLOCK_VAR_ERROR, name));
    } else if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());
        replaceVarWithAssignment(n, parent, parent.getParent());
    }
}"
317,Closure,153,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json,Medium,src/com/google/javascript/jscomp/SyntacticScopeCreator.java,82,112,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        final Node fnNameNode = n.getFirstChild();
        final Node args = fnNameNode.getNext();
        final Node body = args.getNext();
        // Bleed the function name into the scope, if it hasn't
        // been declared in the outer scope.
        String fnName = fnNameNode.getString();
        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
            declareVar(fnNameNode);
        }
        // Args: Declare function variables
        Preconditions.checkState(args.getType() == Token.LP);
        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {
            Preconditions.checkState(a.getType() == Token.NAME);
            declareVar(a);
        }
        // Body
        scanVars(body, n);
    } else {
        // It's the global block
        Preconditions.checkState(scope.getParent() == null);
        scanVars(n, null);
    }
}"
318,Closure,153,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json,Medium,src/com/google/javascript/jscomp/SyntacticScopeCreator.java,117,170,"/**
 * Scans and gather variables declarations under a Node
 */
private void scanVars(Node n, Node parent) {
    switch(n.getType()) {
        case Token.VAR:
            // Declare all variables. e.g. var x = 1, y, z;
            for (Node child = n.getFirstChild(); child != null; ) {
                Node next = child.getNext();
                declareVar(child);
                child = next;
            }
            return;
        case Token.FUNCTION:
            if (NodeUtil.isFunctionExpression(n)) {
                return;
            }
            String fnName = n.getFirstChild().getString();
            if (fnName.isEmpty()) {
                // This is invalid, but allow it so the checks can catch it.
                return;
            }
            declareVar(n.getFirstChild());
            // should not examine function's children
            return;
        case Token.CATCH:
            Preconditions.checkState(n.getChildCount() == 2);
            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);
            // the first child is the catch var and the third child
            // is the code block
            final Node var = n.getFirstChild();
            final Node block = var.getNext();
            declareVar(var);
            scanVars(block, n);
            // only one child to scan
            return;
        case Token.SCRIPT:
            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
            break;
    }
    // we only need to traverse children in a couple special cases.
    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {
        for (Node child = n.getFirstChild(); child != null; ) {
            Node next = child.getNext();
            scanVars(child, n);
            child = next;
        }
    }
}"
319,Closure,153,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json,Medium,src/com/google/javascript/jscomp/SyntacticScopeCreator.java,176,177,"void onRedeclaration(Scope s, String name, Node n, CompilerInput input);"
320,Closure,153,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json,Medium,src/com/google/javascript/jscomp/SyntacticScopeCreator.java,184,222,"public void onRedeclaration(Scope s, String name, Node n, CompilerInput input) {
    Node parent = n.getParent();
    // Don't allow multiple variables to be declared at the top level scope
    if (scope.isGlobal()) {
        Scope.Var origVar = scope.getVar(name);
        Node origParent = origVar.getParentNode();
        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {
            // Okay, both are 'catch(x)' variables.
            return;
        }
        boolean allowDupe = false;
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
        if (!allowDupe) {
            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : ""??"")));
        }
    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {
        // Disallow shadowing ""arguments"" as we can't handle with our current
        // scope modeling.
        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));
    }
}"
321,Closure,153,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json,Medium,src/com/google/javascript/jscomp/SyntacticScopeCreator.java,231,243,"/**
 * Declares a variable.
 *
 * @param n The node corresponding to the variable name.
 * @param declaredType The variable's type, according to JSDoc
 */
private void declareVar(Node n) {
    Preconditions.checkState(n.getType() == Token.NAME);
    CompilerInput input = compiler.getInput(sourceName);
    String name = n.getString();
    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {
        redeclarationHandler.onRedeclaration(scope, name, n, input);
    } else {
        scope.declare(name, n, null, input);
    }
}"
322,Closure,154,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-204.json,Medium,src/com/google/javascript/jscomp/TypeCheck.java,1006,1080,"/**
 * Given a constructor type and a property name, check that the property has
 * the JSDoc annotation @override iff the property is declared on a
 * superclass. Several checks regarding inheritance correctness are also
 * performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {
    // already.
    if (hasUnknownOrEmptySupertype(ctorType)) {
        return;
    }
    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();
    boolean foundInterfaceProperty = false;
    if (ctorType.isConstructor()) {
        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
                continue;
            }
            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();
            Preconditions.checkNotNull(interfaceType);
            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);
            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
                // @override not present, but the property does override an interface
                // property
                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));
            }
        }
    }
    if (!declaredOverride && !superClassHasProperty) {
        // nothing to do here, it's just a plain new property
        return;
    }
    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;
    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {
        // @override not present, but the property does override a superclass
        // property
        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));
    }
    if (!declaredOverride) {
        // there's no @override to check
        return;
    }
    // @override is present and we have to check that it is ok
    if (superClassHasProperty) {
        // there is a superclass implementation
        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);
        if (!propertyType.canAssignTo(superClassPropType)) {
            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));
        }
    } else if (!foundInterfaceProperty) {
        // there is no superclass nor interface implementation
        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));
    }
}"
323,Closure,154,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-204.json,Medium,src/com/google/javascript/jscomp/TypeValidator.java,584,615,"/**
 * Expect that the peroperty in an interface that this type implements is
 * implemented and correctly typed.
 */
private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {
    if (!instance.hasProperty(prop)) {
        // Not implemented
        String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        sourceName = sourceName == null ? """" : sourceName;
        if (shouldReport) {
            compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));
        }
        registerMismatch(instance, implementedInterface);
    } else {
        JSType found = instance.getPropertyType(prop);
        JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);
        found = found.restrictByNotNullOrUndefined();
        required = required.restrictByNotNullOrUndefined();
        if (!found.canAssignTo(required)) {
            // Implemented, but not correctly typed
            if (shouldReport) {
                FunctionType constructor = implementedInterface.toObjectType().getConstructor();
                compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()));
            }
            registerMismatch(found, required);
        }
    }
}"
324,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/InlineVariables.java,196,225,"/**
 * For all variables in this scope, see if they are only used once.
 * If it looks safe to do so, inline them.
 */
private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {
    boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {
        Var v = it.next();
        ReferenceCollection referenceInfo = referenceMap.get(v);
        // and the variable is not a constant.
        if (referenceInfo == null || isVarInlineForbidden(v)) {
            // were not collected or variables that have already been inlined.
            continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
            Reference init = referenceInfo.getInitializingReferenceForConstants();
            Node value = init.getAssignedValue();
            inlineDeclaredConstant(v, value, referenceInfo.references);
            staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
            // inlining heuristics. See InlineConstantsTest.
            continue;
        } else {
            inlineNonConstants(v, referenceInfo, maybeModifiedArguments);
        }
    }
}"
325,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/InlineVariables.java,227,247,"private boolean maybeEscapedOrModifiedArguments(Scope scope, Map<Var, ReferenceCollection> referenceMap) {
    if (scope.isLocal()) {
        Var arguments = scope.getArgumentsVar();
        ReferenceCollection refs = referenceMap.get(arguments);
        if (refs != null && !refs.references.isEmpty()) {
            for (Reference ref : refs.references) {
                Node refNode = ref.getNameNode();
                Node refParent = ref.getParent();
                // consider a escape of the arguments object.
                if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) {
                    return true;
                }
            }
        }
    }
    return false;
}"
326,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/InlineVariables.java,249,255,"private boolean isLValue(Node n) {
    Node parent = n.getParent();
    return (parent.getType() == Token.INC || parent.getType() == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n));
}"
327,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/InlineVariables.java,257,326,"private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;
    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
            // Create a new node for variable that is never initialized.
            Node srcLocation = declaration.getNameNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            // The only reference is the initialization, remove the assignment and
            // the variable declaration.
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
    // the next pass.)
    if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; /* start from a read */
        i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNameNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }
}"
328,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,121,138,"/**
 * For each node, update the block stack and reference collection
 * as appropriate.
 */
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.NAME) {
        Var v;
        if (n.getString().equals(""arguments"")) {
            v = t.getScope().getArgumentsVar();
        } else {
            v = t.getScope().getVar(n.getString());
        }
        if (v != null && varFilter.apply(v)) {
            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));
        }
    }
    if (isBlockBoundary(n, parent)) {
        blockStack.pop();
    }
}"
329,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/Scope.java,307,314,"@Override
public boolean equals(Object other) {
    if (!(other instanceof Arguments)) {
        return false;
    }
    Arguments otherVar = (Arguments) other;
    return otherVar.scope.getRootNode() == scope.getRootNode();
}"
330,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/Scope.java,316,318,"@Override
public int hashCode() {
    return System.identityHashCode(this);
}"
331,Closure,155,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json,Medium,src/com/google/javascript/jscomp/Scope.java,485,490,"/**
 * Get a unique VAR object to represents ""arguments"" within this scope
 */
public Var getArgumentsVar() {
    if (arguments == null) {
        arguments = new Arguments(this);
    }
    return arguments;
}"
332,Closure,156,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-389.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,451,474,"/**
 * Collapses definitions of the collapsible properties of a global name.
 * Recurses on subnames that also represent JavaScript objects with
 * collapsible properties.
 *
 * @param n A node representing a global name
 * @param alias The flattened name for {@code n}
 */
private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {
    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();
    // Handle this name first so that nested object literals get unrolled.
    if (n.canCollapse()) {
        updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);
    }
    if (n.props != null) {
        for (Name p : n.props) {
            // Recurse first so that saved node ancestries are intact when needed.
            collapseDeclarationOfNameAndDescendants(p, appendPropForAlias(alias, p.name));
            if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) {
                updateSimpleDeclaration(appendPropForAlias(alias, p.name), p, p.declaration);
            }
        }
    }
}"
333,Closure,156,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-389.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,574,600,"/**
 * Updates the first initialization (a.k.a ""declaration"") of a global name.
 * This involves flattening the global name (if it's not just a global
 * variable name already), collapsing object literal keys into global
 * variables, declaring stub global variables for properties added later
 * in a local scope.
 *
 * It may seem odd that this function also takes care of declaring stubs
 * for direct children. The ultimate goal of this function is to eliminate
 * the global name entirely (when possible), so that ""middlemen"" namespaces
 * disappear, and to do that we need to make sure that all the direct children
 * will be collapsed as well.
 *
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 * @param canCollapseChildNames Whether it's possible to collapse children of
 *     this name. (This is mostly passed for convenience; it's equivalent to
 *     n.canCollapseChildNames()).
 */
private void updateObjLitOrFunctionDeclaration(Name n, String alias, boolean canCollapseChildNames) {
    if (n.declaration == null) {
        // are only defined in local scopes.
        return;
    }
    if (n.declaration.getTwin() != null) {
        // are handled.
        return;
    }
    switch(n.declaration.node.getParent().getType()) {
        case Token.ASSIGN:
            updateObjLitOrFunctionDeclarationAtAssignNode(n, alias, canCollapseChildNames);
            break;
        case Token.VAR:
            updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);
            break;
        case Token.FUNCTION:
            updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);
            break;
    }
}"
334,Closure,156,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-389.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,610,671,"/**
 * Updates the first initialization (a.k.a ""declaration"") of a global name
 * that occurs at an ASSIGN node. See comment for
 * {@link #updateObjLitOrFunctionDeclaration}.
 *
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 */
private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n, String alias, boolean canCollapseChildNames) {
    // NOTE: It's important that we don't add additional nodes
    // (e.g. a var node before the exprstmt) because the exprstmt might be
    // the child of an if statement that's not inside a block).
    Ref ref = n.declaration;
    Node rvalue = ref.node.getNext();
    Node varNode = new Node(Token.VAR);
    Node varParent = ref.node.getAncestor(3);
    Node gramps = ref.node.getAncestor(2);
    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;
    boolean insertedVarNode = false;
    if (isObjLit && n.canEliminate()) {
        // Eliminate the object literal altogether.
        varParent.replaceChild(gramps, varNode);
        ref.node = null;
        insertedVarNode = true;
    } else if (!n.isSimpleName()) {
        // Create a VAR node to declare the name.
        if (rvalue.getType() == Token.FUNCTION) {
            checkForHosedThisReferences(rvalue, n.docInfo, n);
        }
        ref.node.getParent().removeChild(rvalue);
        Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName());
        if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
        }
        varNode.addChildToBack(nameNode);
        nameNode.addChildToFront(rvalue);
        varParent.replaceChild(gramps, varNode);
        // Update the node ancestry stored in the reference.
        ref.node = nameNode;
        insertedVarNode = true;
    }
    if (canCollapseChildNames) {
        if (isObjLit) {
            declareVarsForObjLitValues(n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent);
        }
        addStubsForUndeclaredProperties(n, alias, varParent, varNode);
    }
    if (insertedVarNode) {
        if (!varNode.hasChildren()) {
            varParent.removeChild(varNode);
        }
        compiler.reportCodeChange();
    }
}"
335,Closure,156,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-389.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,703,741,"/**
 * Updates the first initialization (a.k.a ""declaration"") of a global name
 * that occurs at a VAR node. See comment for
 * {@link #updateObjLitOrFunctionDeclaration}.
 *
 * @param n An object representing a global name (e.g. ""a"")
 */
private void updateObjLitOrFunctionDeclarationAtVarNode(Name n, boolean canCollapseChildNames) {
    if (!canCollapseChildNames) {
        return;
    }
    Ref ref = n.declaration;
    String name = ref.node.getString();
    Node rvalue = ref.node.getFirstChild();
    Node varNode = ref.node.getParent();
    Node gramps = varNode.getParent();
    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;
    int numChanges = 0;
    if (isObjLit) {
        numChanges += declareVarsForObjLitValues(n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps);
    }
    numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);
    if (isObjLit && n.canEliminate()) {
        varNode.removeChild(ref.node);
        if (!varNode.hasChildren()) {
            gramps.removeChild(varNode);
        }
        numChanges++;
        // Clear out the object reference, since we've eliminated it from the
        // parse tree.
        ref.node = null;
    }
    if (numChanges > 0) {
        compiler.reportCodeChange();
    }
}"
336,Closure,156,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-389.json,Medium,src/com/google/javascript/jscomp/CollapseProperties.java,750,760,"/**
 * Updates the first initialization (a.k.a ""declaration"") of a global name
 * that occurs at a FUNCTION node. See comment for
 * {@link #updateObjLitOrFunctionDeclaration}.
 *
 * @param n An object representing a global name (e.g. ""a"")
 */
private void updateFunctionDeclarationAtFunctionNode(Name n, boolean canCollapseChildNames) {
    if (!canCollapseChildNames) {
        return;
    }
    Ref ref = n.declaration;
    String fnName = ref.node.getString();
    addStubsForUndeclaredProperties(n, fnName, ref.node.getAncestor(2), ref.node.getParent());
}"
337,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,82,734,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.getType() == Token.EMPTY) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.getType() == Token.COMMA) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.LP:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addList(first, false, context);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type));
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().getType() == Token.NUMBER) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type));
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addLeftExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1);
                cc.addOp("":"", true);
                addExpr(last, 1);
                break;
            }
        case Token.REGEXP:
            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.GET_REF:
            add(first);
            break;
        case Token.REF_SPECIAL:
            Preconditions.checkState(childCount == 1);
            add(first);
            add(""."");
            add((String) n.getProp(Node.NAME_PROP));
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GET:
        case Token.SET:
            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.getType() == Token.FUNCTION);
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GET) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    add(jsString(n.getString(), outputCharsetEncoder));
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.getType() == Token.VAR) {
                        cc.endStatement();
                    }
                    if (c.getType() == Token.FUNCTION) {
                        cc.maybeLineBreak();
                    }
                    // because top level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.getType() == Token.VAR) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.getType() == Token.STRING, ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.getType() == Token.NUMBER);
                if (needsParens) {
                    add(""("");
                }
                addLeftExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addLeftExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addLeftExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA));
                add("")"");
            } else {
                addLeftExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
        case Token.THIS:
        case Token.FALSE:
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(Node.tokenToName(type));
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_VOID:
            throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            add(jsString(n.getString(), outputCharsetEncoder));
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.getType() == Token.GET || c.getType() == Token.SET) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.getType() == Token.STRING);
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && // were unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (first.getType() != Token.LABEL_NAME) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        // ignored for our purposes.
        case Token.SETNAME:
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}"
338,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,736,745,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len > 0;
}"
339,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,747,755,"static double getSimpleNumber(String s) {
    if (isSimpleNumber(s)) {
        long l = Long.parseLong(s);
        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
            return l;
        }
    }
    return Double.NaN;
}"
340,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/RenamePrototypes.java,313,343,"public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.GETPROP:
        case Token.GETELEM:
            Node dest = n.getFirstChild().getNext();
            if (dest.getType() == Token.STRING) {
                String s = dest.getString();
                if (s.equals(""prototype"")) {
                    processPrototypeParent(parent, t.getInput());
                } else {
                    markPropertyAccessCandidate(dest, t.getInput());
                }
            }
            break;
        case Token.OBJECTLIT:
            if (!prototypeObjLits.contains(n)) {
                // only the property names.
                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
                    if (TokenStream.isJSIdentifier(child.getString())) {
                        markObjLitPropertyCandidate(child, t.getInput());
                    }
                }
            }
            break;
    }
}"
341,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/RenamePrototypes.java,350,385,"/**
 * Processes the parent of a GETPROP prototype, which can either be
 * another GETPROP (in the case of Foo.prototype.bar), or can be
 * an assignment (in the case of Foo.prototype = ...).
 */
private void processPrototypeParent(Node n, CompilerInput input) {
    switch(n.getType()) {
        // Foo.prototype.getBar = function() { ... }
        case Token.GETPROP:
        case Token.GETELEM:
            Node dest = n.getFirstChild().getNext();
            if (dest.getType() == Token.STRING) {
                markPrototypePropertyCandidate(dest, input);
            }
            break;
        // Foo.prototype = { ""getBar"" : function() { ... } }
        case Token.ASSIGN:
        case Token.CALL:
            Node map;
            if (n.getType() == Token.ASSIGN) {
                map = n.getFirstChild().getNext();
            } else {
                map = n.getLastChild();
            }
            if (map.getType() == Token.OBJECTLIT) {
                // Remember this node so that we can avoid processing it again when
                // the traversal reaches it.
                prototypeObjLits.add(map);
                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {
                    if (TokenStream.isJSIdentifier(key.getString())) {
                        // May be STRING, GET, or SET
                        markPrototypePropertyCandidate(key, input);
                    }
                }
            }
            break;
    }
}"
342,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,255,263,"private Node transformNumberAsString(NumberLiteral literalNode) {
    JSDocInfo jsDocInfo = handleJsDoc(literalNode);
    Node irNode = newStringNode(getStringValue(literalNode.getNumber()));
    if (jsDocInfo != null) {
        irNode.setJSDocInfo(jsDocInfo);
    }
    setSourceInfo(irNode, literalNode);
    return irNode;
}"
343,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,265,274,"private static String getStringValue(double value) {
    long longValue = (long) value;
    // Return ""1"" instead of ""1.0""
    if (longValue == value) {
        return Long.toString(longValue);
    } else {
        return Double.toString(value);
    }
}"
344,Closure,157,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json,Medium,src/com/google/javascript/jscomp/parsing/IRFactory.java,360,373,"/**
 * Transforms the given node and then sets its type to Token.STRING if it
 * was Token.NAME. If its type was already Token.STRING, then quotes it.
 * Used for properties, as the old AST uses String tokens, while the new one
 * uses Name tokens for unquoted strings. For example, in
 * var o = {'a' : 1, b: 2};
 * the string 'a' is quoted, while the name b is turned into a string, but
 * unquoted.
 */
private Node transformAsString(AstNode n) {
    Node ret;
    if (n instanceof Name) {
        ret = transformNameAsString((Name) n);
    } else if (n instanceof NumberLiteral) {
        ret = transformNumberAsString((NumberLiteral) n);
        ret.putBooleanProp(Node.QUOTED_PROP, true);
    } else {
        ret = transform(n);
        ret.putBooleanProp(Node.QUOTED_PROP, true);
    }
    Preconditions.checkState(ret.getType() == Token.STRING);
    return ret;
}"
345,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,193,256,"/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    if (config.warningGuards != null) {
        for (WarningGuardSpec.Entry entry : config.warningGuards.entries) {
            diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level);
        }
    }
    createDefineOrTweakReplacements(config.define, options, false);
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);
    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
        options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
    if (config.languageIn.length() > 0) {
        if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") || config.languageIn.equals(""ES5_STRICT"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT5"") || config.languageIn.equals(""ES5"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT3"") || config.languageIn.equals(""ES3"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
        } else {
            throw new FlagUsageException(""Unknown language `"" + config.languageIn + ""' specified."");
        }
    }
    options.acceptConstKeyword = config.acceptConstKeyword;
}"
346,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,1501,1504,"/**
 * Add warning guards.
 */
CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) {
    this.warningGuards = spec;
    return this;
}"
347,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,1628,1630,"protected void add(CheckLevel level, String groupName) {
    entries.add(new Entry(level, groupName));
}"
348,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,1632,1634,"protected void clear() {
    entries.clear();
}"
349,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,432,432,"@Override
public boolean isMultiValued() {
    return proxy.isMultiValued();
}"
350,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,434,434,"@Override
public Class getType() {
    return proxy.getType();
}"
351,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,436,439,"@Override
public void addValue(Object value) throws CmdLineException {
    proxy.addValue((String) value);
    warningGuardSpec.add(level, (String) value);
}"
352,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,515,539,"private void processFlagFile(PrintStream err) throws CmdLineException, IOException {
    List<String> argsInFile = Lists.newArrayList();
    File flagFileInput = new File(flags.flag_file);
    StringTokenizer tokenizer = new StringTokenizer(Files.toString(flagFileInput, Charset.defaultCharset()));
    while (tokenizer.hasMoreTokens()) {
        argsInFile.add(tokenizer.nextToken());
    }
    flags.flag_file = """";
    List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {}));
    CmdLineParser parserFileArgs = new CmdLineParser(flags);
    Flags.warningGuardSpec.clear();
    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));
    // Currently we are not supporting this (prevent direct/indirect loops)
    if (!flags.flag_file.equals("""")) {
        err.println(""ERROR - Arguments in the file cannot contain "" + ""--flagfile option."");
        isConfigValid = false;
    }
}"
353,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/CommandLineRunner.java,541,608,"private void initConfigFromFlags(String[] args, PrintStream err) {
    List<String> processedArgs = processArgs(args);
    CmdLineParser parser = new CmdLineParser(flags);
    Flags.warningGuardSpec.clear();
    isConfigValid = true;
    try {
        parser.parseArgument(processedArgs.toArray(new String[] {}));
        // For contains --flagfile flag
        if (!flags.flag_file.equals("""")) {
            processFlagFile(err);
        }
    } catch (CmdLineException e) {
        err.println(e.getMessage());
        isConfigValid = false;
    } catch (IOException ioErr) {
        err.println(""ERROR - "" + flags.flag_file + "" read error."");
        isConfigValid = false;
    }
    if (flags.version) {
        ResourceBundle config = ResourceBundle.getBundle(configResource);
        err.println(""Closure Compiler (http://code.google.com/closure/compiler)\n"" + ""Version: "" + config.getString(""compiler.version"") + ""\n"" + ""Built on: "" + config.getString(""compiler.date""));
        err.flush();
    }
    if (!isConfigValid || flags.display_help) {
        isConfigValid = false;
        parser.printUsage(err);
    } else {
        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setWarningGuardSpec(Flags.warningGuardSpec).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setClosureEntryPoints(flags.closure_entry_point).setOutputManifest(flags.output_manifest).setAcceptConstKeyword(flags.accept_const_keyword).setLanguageIn(flags.language_in);
    }
}"
354,Closure,158,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json,Medium,src/com/google/javascript/jscomp/DiagnosticGroups.java,185,190,"/**
 * Adds warning levels by name.
 */
void setWarningLevel(CompilerOptions options, String name, CheckLevel level) {
    DiagnosticGroup group = forName(name);
    Preconditions.checkNotNull(group, ""No warning class for name: "" + name);
    options.setWarningLevel(group, level);
}"
355,Closure,159,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-423.json,Medium,src/com/google/javascript/jscomp/InlineFunctions.java,773,786,"/**
 * @see #findCalledFunctions(Node)
 */
private void findCalledFunctions(Node node, Set<String> changed) {
    Preconditions.checkArgument(changed != null);
    // For each referenced function, add a new reference
    if (node.getType() == Token.NAME) {
        if (isCandidateUsage(node)) {
            changed.add(node.getString());
        }
    }
    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
        findCalledFunctions(c, changed);
    }
}"
356,Closure,160,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-467.json,Medium,src/com/google/javascript/jscomp/Compiler.java,226,282,"/**
 * Initialize the compiler options. Only necessary if you're not doing
 * a normal compile() job.
 */
public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }
    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }
    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }
    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());
    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);
    // error off.
    if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }
    this.warningsGuard = composedGuards;
}"
357,Closure,161,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-522.json,Medium,src/com/google/javascript/jscomp/PeepholeFoldConstants.java,1278,1325,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
    Node parent = n.getParent();
    // ""[][0] += 1""
    if (isAssignmentTarget(n)) {
        return n;
    }
    if (right.getType() != Token.NUMBER) {
        // arrays, or strings to index into array methods.
        return n;
    }
    double index = right.getDouble();
    int intIndex = (int) index;
    if (intIndex != index) {
        error(INVALID_GETELEM_INDEX_ERROR, right);
        return n;
    }
    if (intIndex < 0) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
    Node elem = left.getFirstChild();
    for (int i = 0; elem != null && i < intIndex; i++) {
        elem = elem.getNext();
    }
    if (elem == null) {
        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
        return n;
    }
    if (elem.getType() == Token.EMPTY) {
        elem = NodeUtil.newUndefinedNode(elem);
    } else {
        left.removeChild(elem);
    }
    // Replace the entire GETELEM with the value
    n.getParent().replaceChild(n, elem);
    reportCodeChange();
    return elem;
}"
358,Closure,162,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-548.json,Medium,src/com/google/javascript/jscomp/Scope.java,568,570,"/**
 * Return an iterable over all of the variables declared in this scope.
 */
Iterable<Var> getVarIterable() {
    return vars.values();
}"
359,Closure,162,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-548.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,220,228,"@Override
public void enterScope(NodeTraversal t) {
    Node n = t.getCurrentNode().getParent();
    if (n != null && isCallToScopeMethod(n)) {
        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));
        findAliases(t);
    }
}"
360,Closure,162,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-548.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,272,293,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                aliases.put(name, aliasVar);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
            } else {
                // TODO(robbyw): Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}"
361,Closure,162,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-548.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,318,384,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
    // Validate the top level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
            // Note, to support the transitive case, it's important we don't
            // clone aliasedNode here.  For example,
            // var g = goog; var d = g.dom; d.createElement('DIV');
            // The node in aliasedNode (which is ""g"") will be replaced in the
            // changes pass above with ""goog"".  If we cloned here, we'd end up
            // with <code>g.dom.createElement('DIV')</code>.
            Node aliasedNode = aliasVar.getInitialValue();
            aliasUsages.add(new AliasedNode(n, aliasedNode));
        }
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}"
362,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,201,230,"@Override
public void enterScope(NodeTraversal t) {
    Node n = t.getCurrentNode();
    if (n.isFunction()) {
        String propName = getPrototypePropertyNameFromRValue(n);
        if (propName != null) {
            symbolStack.push(new NameContext(getNameInfoForName(propName, PROPERTY), t.getScope()));
        } else if (isGlobalFunctionDeclaration(t, n)) {
            Node parent = n.getParent();
            String name = parent.isName() ? parent.getString() : /* VAR */
            n.getFirstChild().getString();
            symbolStack.push(new NameContext(getNameInfoForName(name, VAR), t.getScope()));
        } else {
            // NOTE(nicksantos): We use the same anonymous node for all
            // functions that do not have reasonable names. I can't remember
            // at the moment why we do this. I think it's because anonymous
            // nodes can never have in-edges. They're just there as a placeholder
            // for scope information, and do not matter in the edge propagation.
            symbolStack.push(new NameContext(anonymousNode, t.getScope()));
        }
    } else {
        Preconditions.checkState(t.inGlobalScope());
        symbolStack.push(new NameContext(globalNode, t.getScope()));
    }
}"
363,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,232,235,"@Override
public void exitScope(NodeTraversal t) {
    symbolStack.pop();
}"
364,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,237,247,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    // Process prototype assignments to non-functions.
    String propName = processNonFunctionPrototypeAssign(n, parent);
    if (propName != null) {
        symbolStack.push(new NameContext(getNameInfoForName(propName, PROPERTY), null));
    }
    return true;
}"
365,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,249,331,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isGetProp()) {
        String propName = n.getFirstChild().getNext().getString();
        if (n.isQualifiedName()) {
            if (propName.equals(""prototype"")) {
                if (processPrototypeRef(t, n)) {
                    return;
                }
            } else if (compiler.getCodingConvention().isExported(propName)) {
                addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
                return;
            } else {
                // Do not mark prototype prop assigns as a 'use' in the global scope.
                if (n.getParent().isAssign() && n.getNext() != null) {
                    String rValueName = getPrototypePropertyNameFromRValue(n);
                    if (rValueName != null) {
                        return;
                    }
                }
            }
        }
        addSymbolUse(propName, t.getModule(), PROPERTY);
    } else if (n.isObjectLit()) {
        // Make sure that we're not handling object literals being
        // assigned to a prototype, as in:
        // Foo.prototype = {bar: 3, baz: 5};
        String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
        if (lValueName != null && lValueName.endsWith("".prototype"")) {
            return;
        }
        // should count as a use of property a and b.
        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {
            // May be STRING, GET, or SET, but NUMBER isn't interesting.
            if (!propNameNode.isQuotedString()) {
                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);
            }
        }
    } else if (n.isName()) {
        String name = n.getString();
        Var var = t.getScope().getVar(name);
        if (var != null) {
            // Only process global functions.
            if (var.isGlobal()) {
                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {
                    if (t.inGlobalScope()) {
                        if (!processGlobalFunctionDeclaration(t, n, var)) {
                            addGlobalUseOfSymbol(name, t.getModule(), VAR);
                        }
                    } else {
                        addSymbolUse(name, t.getModule(), VAR);
                    }
                }
            // If it is not a global, it might be accessing a local of the outer
            // scope. If that's the case the functions between the variable's
            // declaring scope and the variable reference scope cannot be moved.
            } else if (var.getScope() != t.getScope()) {
                for (int i = symbolStack.size() - 1; i >= 0; i--) {
                    NameContext context = symbolStack.get(i);
                    if (context.scope == var.getScope()) {
                        break;
                    }
                    context.name.readClosureVariables = true;
                }
            }
        }
    }
    // Process prototype assignments to non-functions.
    if (processNonFunctionPrototypeAssign(n, parent) != null) {
        symbolStack.pop();
    }
}"
366,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,352,357,"/**
 * If this is a non-function prototype assign, return the prop name.
 * Otherwise, return null.
 */
private String processNonFunctionPrototypeAssign(Node n, Node parent) {
    if (isAssignRValue(n, parent) && !n.isFunction()) {
        return getPrototypePropertyNameFromRValue(n);
    }
    return null;
}"
367,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,363,374,"/**
 * Determines whether {@code n} is the FUNCTION node in a global function
 * declaration.
 */
private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {
    // Make sure we're either in the global scope, or the function
    // we're looking at is the root of the current local scope.
    Scope s = t.getScope();
    if (!(s.isGlobal() || s.getDepth() == 1 && s.getRootNode() == n)) {
        return false;
    }
    return NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName();
}"
368,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,379,381,"/**
 * Returns true if this is the r-value of an assignment.
 */
private boolean isAssignRValue(Node n, Node parent) {
    return parent != null && parent.isAssign() && parent.getFirstChild() != n;
}"
369,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,390,416,"/**
 * Returns the name of a prototype property being assigned to this r-value.
 *
 * Returns null if this is not the R-value of a prototype property, or if
 * the R-value is used in multiple expressions (i.e., if there's
 * a prototype property assignment in a more complex expression).
 */
private String getPrototypePropertyNameFromRValue(Node rValue) {
    Node lValue = NodeUtil.getBestLValue(rValue);
    if (lValue == null || lValue.getParent() == null || lValue.getParent().getParent() == null || !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) || NodeUtil.isExprAssign(lValue.getParent().getParent()))) {
        return null;
    }
    String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue));
    if (lValueName == null) {
        return null;
    }
    int lastDot = lValueName.lastIndexOf('.');
    if (lastDot == -1) {
        return null;
    }
    String firstPart = lValueName.substring(0, lastDot);
    if (!firstPart.endsWith("".prototype"")) {
        return null;
    }
    return lValueName.substring(lastDot + 1);
}"
370,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,422,446,"/**
 * Processes a NAME node to see if it's a global function declaration.
 * If it is, record it and return true. Otherwise, return false.
 */
private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Var v) {
    Node firstChild = nameNode.getFirstChild();
    Node parent = nameNode.getParent();
    if (// Check for a named FUNCTION.
    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.
    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {
        String name = nameNode.getString();
        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, v, t.getModule()));
        // so that it's never removed.
        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {
            addGlobalUseOfSymbol(name, t.getModule(), VAR);
        }
        return true;
    }
    return false;
}"
371,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,454,497,"/**
 * Processes the GETPROP of prototype, which can either be under
 * another GETPROP (in the case of Foo.prototype.bar), or can be
 * under an assignment (in the case of Foo.prototype = ...).
 * @return True if a declaration was added.
 */
private boolean processPrototypeRef(NodeTraversal t, Node ref) {
    Node root = NodeUtil.getRootOfQualifiedName(ref);
    Node n = ref.getParent();
    switch(n.getType()) {
        // Foo.prototype.getBar = function() { ... }
        case Token.GETPROP:
            Node dest = n.getFirstChild().getNext();
            Node parent = n.getParent();
            Node grandParent = parent.getParent();
            if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {
                String name = dest.getString();
                Property prop = new AssignmentProperty(grandParent, t.getScope().getVar(root.getString()), t.getModule());
                getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
                return true;
            }
            break;
        // Foo.prototype = { ""getBar"" : function() { ... } }
        case Token.ASSIGN:
            Node map = n.getFirstChild().getNext();
            if (map.isObjectLit()) {
                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {
                    // May be STRING, GET, or SET,
                    String name = key.getString();
                    Property prop = new LiteralProperty(key, key.getFirstChild(), map, n, t.getScope().getVar(root.getString()), t.getModule());
                    getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
                }
                return true;
            }
            break;
    }
    return false;
}"
372,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,548,548,"/**
 * The variable for the root of this symbol.
 */
Var getRootVar();"
373,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,579,582,"@Override
public Var getRootVar() {
    return var;
}"
374,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,645,648,"@Override
public Var getRootVar() {
    return rootVar;
}"
375,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,699,702,"@Override
public Var getRootVar() {
    return rootVar;
}"
376,Closure,163,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json,High,src/com/google/javascript/jscomp/CrossModuleMethodMotion.java,96,199,"/**
 * Move methods deeper in the module graph when possible.
 */
private void moveMethods(Collection<NameInfo> allNameInfo) {
    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();
    for (NameInfo nameInfo : allNameInfo) {
        if (!nameInfo.isReferenced()) {
            // deepestCommonModuleRef is null.
            continue;
        }
        if (nameInfo.readsClosureVariables()) {
            continue;
        }
        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();
        if (deepestCommonModuleRef == null) {
            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));
            continue;
        }
        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();
        while (declarations.hasNext()) {
            Symbol symbol = declarations.next();
            if (!(symbol instanceof Property)) {
                continue;
            }
            Property prop = (Property) symbol;
            // behavior.
            if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) {
                continue;
            }
            Node value = prop.getValue();
            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {
                Node valueParent = value.getParent();
                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {
                    // of a GET instead of the function itself.
                    continue;
                }
                Node proto = prop.getPrototype();
                int stubId = idGenerator.newId();
                // example: JSCompiler_stubMethod(id);
                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);
                stubCall.putBooleanProp(Node.FREE_CALL, true);
                // stub out the method in the original module
                // A.prototype.b = JSCompiler_stubMethod(id);
                valueParent.replaceChild(value, stubCall);
                // unstub the function body in the deeper module
                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);
                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);
                unstubCall.putBooleanProp(Node.FREE_CALL, true);
                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);
                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));
                compiler.reportCodeChange();
            }
        }
    }
    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {
        // Declare stub functions in the top-most module.
        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);
        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());
    }
}"
377,Closure,164,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-634.json,Medium,src/com/google/javascript/rhino/jstype/ArrowType.java,79,171,"@Override
public boolean isSubtype(JSType other) {
    if (!(other instanceof ArrowType)) {
        return false;
    }
    ArrowType that = (ArrowType) other;
    // this.returnType <: that.returnType (covariant)
    if (!this.returnType.isSubtype(that.returnType)) {
        return false;
    }
    // that.paramType[i] <: this.paramType[i] (contravariant)
    // 
    // If this.paramType[i] is required,
    // then that.paramType[i] is required.
    // 
    // In theory, the ""required-ness"" should work in the other direction as
    // well. In other words, if we have
    // 
    // function f(number, number) {}
    // function g(number) {}
    // 
    // Then f *should* not be a subtype of g, and g *should* not be
    // a subtype of f. But in practice, we do not implement it this way.
    // We want to support the use case where you can pass g where f is
    // expected, and pretend that g ignores the second argument.
    // That way, you can have a single ""no-op"" function, and you don't have
    // to create a new no-op function for every possible type signature.
    // 
    // So, in this case, g < f, but f !< g
    Node thisParam = parameters.getFirstChild();
    Node thatParam = that.parameters.getFirstChild();
    while (thisParam != null && thatParam != null) {
        JSType thisParamType = thisParam.getJSType();
        JSType thatParamType = thatParam.getJSType();
        if (thisParamType != null) {
            if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) {
                return false;
            }
        }
        boolean thisIsVarArgs = thisParam.isVarArgs();
        boolean thatIsVarArgs = thatParam.isVarArgs();
        boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();
        boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();
        // ""that"" can't be a supertype, because it's missing a required argument.
        if (!thisIsOptional && thatIsOptional) {
            // NOTE(nicksantos): In our type system, we use {function(...?)} and
            // {function(...NoType)} to to indicate that arity should not be
            // checked. Strictly speaking, this is not a correct formulation,
            // because now a sub-function can required arguments that are var_args
            // in the super-function. So we special-case this.
            boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType());
            if (!isTopFunction) {
                return false;
            }
        }
        // don't advance if we have variable arguments
        if (!thisIsVarArgs) {
            thisParam = thisParam.getNext();
        }
        if (!thatIsVarArgs) {
            thatParam = thatParam.getNext();
        }
        // both var_args indicates the end
        if (thisIsVarArgs && thatIsVarArgs) {
            thisParam = null;
            thatParam = null;
        }
    }
    // ""that"" can't be a supertype, because it's missing a required arguement.
    if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) {
        return false;
    }
    return true;
}"
378,Closure,165,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json,Medium,src/com/google/javascript/rhino/jstype/JSTypeRegistry.java,690,708,"/**
 * Returns whether the given property can possibly be set on the given type.
 */
public boolean canPropertyBeDefined(JSType type, String propertyName) {
    if (typesIndexedByProperty.containsKey(propertyName)) {
        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {
            JSType greatestSubtype = alt.getGreatestSubtype(type);
            if (!greatestSubtype.isEmptyType()) {
                // We've found a type with this property. Now we just have to make
                // sure it's not a type used for internal bookkeeping.
                RecordType maybeRecordType = greatestSubtype.toMaybeRecordType();
                if (maybeRecordType != null && maybeRecordType.isSynthetic()) {
                    continue;
                }
                return true;
            }
        }
    }
    return false;
}"
379,Closure,165,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json,Medium,src/com/google/javascript/rhino/jstype/ObjectType.java,290,293,"/**
 * Defines a property whose type is on a synthesized object. These objects
 * don't actually exist in the user's program. They're just used for
 * bookkeeping in the type system.
 */
public final boolean defineSynthesizedProperty(String propertyName, JSType type, Node propertyNode) {
    return defineProperty(propertyName, type, false, propertyNode);
}"
380,Closure,165,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json,Medium,src/com/google/javascript/rhino/jstype/RecordType.java,113,115,"/**
 * @return Is this synthesized for internal bookkeeping?
 */
boolean isSynthetic() {
    return !declared;
}"
381,Closure,165,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json,Medium,src/com/google/javascript/rhino/jstype/RecordType.java,162,222,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}"
382,Closure,165,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json,Medium,src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java,63,65,"/**
 * See the comments on RecordType about synthetic types.
 */
void setSynthesized(boolean synthesized) {
    isDeclared = !synthesized;
}"
383,Closure,165,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json,Medium,src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java,89,97,"/**
 * Creates a record.
 * @return The record type.
 */
public JSType build() {
    // If we have an empty record, simply return the object type.
    if (isEmpty) {
        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
    }
    return new RecordType(registry, Collections.unmodifiableMap(properties), isDeclared);
}"
384,Closure,166,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-785.json,Medium,src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,555,580,"@Override
public void matchConstraint(JSType constraint) {
    // We only want to match constraints on anonymous types.
    if (hasReferenceName()) {
        return;
    }
    // properties on this object.
    if (constraint.isRecordType()) {
        matchRecordTypeConstraint(constraint.toObjectType());
    } else if (constraint.isUnionType()) {
        for (JSType alt : constraint.toMaybeUnionType().getAlternates()) {
            if (alt.isRecordType()) {
                matchRecordTypeConstraint(alt.toObjectType());
            }
        }
    }
}"
385,Closure,167,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json,Medium,src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,272,305,"private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
        leftIsRefineable = true;
    } else {
        leftIsRefineable = false;
        leftType = left.getJSType();
    }
    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
        rightIsRefineable = true;
    } else {
        rightIsRefineable = false;
        rightType = right.getJSType();
    }
    // merged types
    TypePair merged = merging.apply(new TypePair(leftType, rightType));
    // creating new scope
    if (merged != null) {
        return maybeRestrictTwoNames(blindScope, left, leftType, leftIsRefineable ? merged.typeA : null, right, rightType, rightIsRefineable ? merged.typeB : null);
    }
    return blindScope;
}"
386,Closure,167,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json,Medium,src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,307,352,"private FlowScope caseAndOrNotShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
        leftIsRefineable = true;
    } else {
        leftIsRefineable = false;
        leftType = left.getJSType();
        blindScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, condition);
    }
    // restricting left type
    JSType restrictedLeftType = (leftType == null) ? null : leftType.getRestrictedTypeGivenToBooleanOutcome(condition);
    if (restrictedLeftType == null) {
        return firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);
    }
    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
        rightIsRefineable = true;
    } else {
        rightIsRefineable = false;
        rightType = right.getJSType();
        blindScope = firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);
    }
    if (condition) {
        JSType restrictedRightType = (rightType == null) ? null : rightType.getRestrictedTypeGivenToBooleanOutcome(condition);
        // creating new scope
        return maybeRestrictTwoNames(blindScope, left, leftType, leftIsRefineable ? restrictedLeftType : null, right, rightType, rightIsRefineable ? restrictedRightType : null);
    }
    return blindScope;
}"
387,Closure,167,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json,Medium,src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,392,400,"/**
 * If the restrictedType differs from the originalType, then we should
 * branch the current flow scope and create a new flow scope with the name
 * declared with the new type.
 *
 * We try not to create spurious child flow scopes as this makes type
 * inference slower.
 *
 * We also do not want spurious slots around in type inference, because
 * we use these as a signal for ""checked unknown"" types. A ""checked unknown""
 * type is a symbol that the programmer has already checked and verified that
 * it's defined, even if we don't know what it is.
 *
 * It is OK to pass non-name nodes into this method, as long as you pass
 * in {@code null} for a restricted type.
 */
private FlowScope maybeRestrictName(FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {
    if (restrictedType != null && restrictedType != originalType) {
        FlowScope informed = blindScope.createChildFlowScope();
        declareNameInScope(informed, node, restrictedType);
        return informed;
    }
    return blindScope;
}"
388,Closure,167,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json,Medium,src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,405,424,"/**
 * @see maybeRestrictName
 */
private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, JSType originalLeftType, JSType restrictedLeftType, Node right, JSType originalRightType, JSType restrictedRightType) {
    boolean shouldRefineLeft = restrictedLeftType != null && restrictedLeftType != originalLeftType;
    boolean shouldRefineRight = restrictedRightType != null && restrictedRightType != originalRightType;
    if (shouldRefineLeft || shouldRefineRight) {
        FlowScope informed = blindScope.createChildFlowScope();
        if (shouldRefineLeft) {
            declareNameInScope(informed, left, restrictedLeftType);
        }
        if (shouldRefineRight) {
            declareNameInScope(informed, right, restrictedRightType);
        }
        return informed;
    }
    return blindScope;
}"
389,Closure,167,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json,Medium,src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,426,435,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {
    JSType type = getTypeIfRefinable(name, blindScope);
    if (type != null) {
        return maybeRestrictName(blindScope, name, type, type.getRestrictedTypeGivenToBooleanOutcome(outcome));
    }
    return blindScope;
}"
390,Closure,167,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,882,893,"/**
 * Computes the restricted type of this type knowing that the
 * {@code ToBoolean} predicate has a specific value. For more information
 * about the {@code ToBoolean} predicate, see
 * {@link #getPossibleToBooleanOutcomes}.
 *
 * @param outcome the value of the {@code ToBoolean} predicate
 *
 * @return the restricted type, or the Any Type if the underlying type could
 *         not have yielded this ToBoolean value
 *
 * TODO(user): Move this method to the SemanticRAI and use the visit
 * method of types to get the restricted type.
 */
public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {
    if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }
    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();
    if (literals.contains(outcome)) {
        return this;
    } else {
        return getNativeType(JSTypeNative.NO_TYPE);
    }
}"
391,Closure,168,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-726.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1987,2038,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (t.inGlobalScope()) {
        return;
    }
    if (n.isReturn() && n.getFirstChild() != null) {
        data.get(t.getScopeRoot()).recordNonEmptyReturn();
    }
    if (t.getScopeDepth() <= 1) {
        // no reason to do this extra computation for them.
        return;
    }
    if (n.isName() && NodeUtil.isLValue(n) && // in the inner scope, not the scope where the name appears.
    !NodeUtil.isBleedingFunctionName(n)) {
        String name = n.getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordAssignedName(name);
            }
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
            }
        }
    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {
        String name = NodeUtil.getRootOfQualifiedName(n).getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());
            }
        }
    }
}"
392,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/ArrowType.java,177,201,"/**
 * @return True if our parameter spec is equal to {@code that}'s parameter
 *     spec.
 */
boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {
    Node thisParam = parameters.getFirstChild();
    Node otherParam = that.parameters.getFirstChild();
    while (thisParam != null && otherParam != null) {
        JSType thisParamType = thisParam.getJSType();
        JSType otherParamType = otherParam.getJSType();
        if (thisParamType != null) {
            // Both parameter lists give a type for this param, it should be equal
            if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType, eqMethod)) {
                return false;
            }
        } else {
            if (otherParamType != null) {
                return false;
            }
        }
        thisParam = thisParam.getNext();
        otherParam = otherParam.getNext();
    }
    // parameter lists are null (they are equal).
    return thisParam == otherParam;
}"
393,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/ArrowType.java,203,210,"boolean checkArrowEquivalenceHelper(ArrowType that, EquivalenceMethod eqMethod) {
    // Please keep this method in sync with the hashCode() method below.
    if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {
        return false;
    }
    return hasEqualParameters(that, eqMethod);
}"
394,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,789,828,"/**
 * Try to get the sup/inf of two functions by looking at the
 * piecewise components.
 */
private FunctionType tryMergeFunctionPiecewise(FunctionType other, boolean leastSuper) {
    Node newParamsNode = null;
    if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {
        newParamsNode = call.parameters;
    } else {
        // Someday, we should try to merge the individual params.
        return null;
    }
    JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);
    ObjectType newTypeOfThis = null;
    if (isEquivalent(typeOfThis, other.typeOfThis)) {
        newTypeOfThis = typeOfThis;
    } else {
        JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);
        if (maybeNewTypeOfThis instanceof ObjectType) {
            newTypeOfThis = (ObjectType) maybeNewTypeOfThis;
        } else {
            newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
        }
    }
    boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred;
    return new FunctionType(registry, null, null, new ArrowType(registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false);
}"
395,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,889,910,"/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */
boolean checkFunctionEquivalenceHelper(FunctionType that, EquivalenceMethod eqMethod) {
    if (isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (isInterface()) {
        if (that.isInterface()) {
            return getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod);
}"
396,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/FunctionType.java,917,920,"public boolean hasEqualCallType(FunctionType otherType) {
    return this.call.checkArrowEquivalenceHelper(otherType.call, EquivalenceMethod.IDENTITY);
}"
397,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,491,493,"/**
 * Checks if two types are equivalent.
 */
public final boolean isEquivalentTo(JSType that) {
    return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);
}"
398,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,499,501,"/**
 * Checks if two types are invariant.
 * @see EquivalenceMethod
 */
public final boolean isInvariant(JSType that) {
    return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);
}"
399,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,513,515,"/**
 * Whether this type is meaningfully different from {@code that} type for
 * the purposes of data flow analysis.
 *
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types. See {@code EquivalenceMethod} for more info.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */
public final boolean differsFrom(JSType that) {
    return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW);
}"
400,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/JSType.java,520,608,"/**
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {
    if (this == that) {
        return true;
    }
    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
        if (eqMethod == EquivalenceMethod.INVARIANT) {
            // with everyone.
            return true;
        } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {
            // both unknown.
            return thisUnknown && thatUnknown;
        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
            // we won't unbox the unknowns further down.
            return false;
        }
    }
    if (isUnionType() && that.isUnionType()) {
        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), eqMethod);
    }
    if (isFunctionType() && that.isFunctionType()) {
        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), eqMethod);
    }
    if (isRecordType() && that.isRecordType()) {
        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), eqMethod);
    }
    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
        // Check if one type is parameterized, but the other is not.
        boolean paramsMatch = false;
        if (thisParamType != null && thatParamType != null) {
            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), eqMethod);
        } else if (eqMethod == EquivalenceMethod.IDENTITY) {
            paramsMatch = false;
        } else {
            // If one of the type parameters is unknown, but the other is not,
            // then we consider these the same for the purposes of data flow
            // and invariance.
            paramsMatch = true;
        }
        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);
    }
    if (isNominalType() && that.isNominalType()) {
        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
    }
    // Unbox other proxies.
    if (this instanceof ProxyObjectType) {
        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, eqMethod);
    }
    if (that instanceof ProxyObjectType) {
        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), eqMethod);
    }
    // identical, then the type member must be different.
    return this == that;
}"
401,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/RecordType.java,117,131,"boolean checkRecordEquivalenceHelper(RecordType otherRecord, EquivalenceMethod eqMethod) {
    Set<String> keySet = properties.keySet();
    Map<String, JSType> otherProps = otherRecord.properties;
    if (!otherProps.keySet().equals(keySet)) {
        return false;
    }
    for (String key : keySet) {
        if (!otherProps.get(key).checkEquivalenceHelper(properties.get(key), eqMethod)) {
            return false;
        }
    }
    return true;
}"
402,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/RecordType.java,153,212,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && propType.isInvariant(altPropType)) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}"
403,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/RecordType.java,242,283,"/**
 * Determines if typeA is a subtype of typeB
 */
static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (typeA.isPropertyTypeDeclared(property)) {
            // then the whole record isn't covariant.
            if (!propA.isInvariant(propB)) {
                return false;
            }
        } else {
            // then the whole record isn't covariant.
            if (!propA.isSubtype(propB)) {
                return false;
            }
        }
    }
    return true;
}"
404,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/UnionType.java,333,345,"/**
 * Two union types are equal if they have the same number of alternates
 * and all alternates are equal.
 */
boolean checkUnionEquivalenceHelper(UnionType that, EquivalenceMethod eqMethod) {
    if (eqMethod == EquivalenceMethod.IDENTITY && alternates.size() != that.alternates.size()) {
        return false;
    }
    for (JSType alternate : that.alternates) {
        if (!hasAlternate(alternate, eqMethod)) {
            return false;
        }
    }
    return true;
}"
405,Closure,169,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json,Medium,src/com/google/javascript/rhino/jstype/UnionType.java,347,354,"private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) {
    for (JSType alternate : alternates) {
        if (alternate.checkEquivalenceHelper(type, eqMethod)) {
            return true;
        }
    }
    return false;
}"
406,Closure,170,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-965.json,Medium,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,474,509,"/**
 * Computes the number of uses of the variable varName and store it in
 * numUseWithinUseCfgNode.
 */
private void getNumUseInUseCfgNode(final Node cfgNode) {
    numUsesWithinCfgNode = 0;
    AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName() && n.getString().equals(varName)) {
                // and remove this special case.
                if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) {
                    // Don't count lhs of top-level assignment chain
                    return;
                } else {
                    numUsesWithinCfgNode++;
                }
            }
        }

        private boolean isAssignChain(Node child, Node ancestor) {
            for (Node n = child; n != ancestor; n = n.getParent()) {
                if (!n.isAssign()) {
                    return false;
                }
            }
            return true;
        }
    };
    NodeTraversal.traverse(compiler, cfgNode, gatherCb);
}"
407,Closure,170,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-965.json,Medium,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,480,496,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.isName() && n.getString().equals(varName)) {
        // and remove this special case.
        if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) {
            // Don't count lhs of top-level assignment chain
            return;
        } else {
            numUsesWithinCfgNode++;
        }
    }
}"
408,Closure,170,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-965.json,Medium,src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,498,505,"private boolean isAssignChain(Node child, Node ancestor) {
    for (Node n = child; n != ancestor; n = n.getParent()) {
        if (!n.isAssign()) {
            return false;
        }
    }
    return true;
}"
409,Closure,171,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1023.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,719,768,"private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
    JSType type = n.getJSType();
    Preconditions.checkNotNull(type);
    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
        scope = traverse(name.getFirstChild(), scope);
    }
    // Object literals can be reflected on other types.
    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.
    // Ignore these types of literals.
    ObjectType objectType = ObjectType.cast(type);
    if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {
        return scope;
    }
    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
        String memberName = NodeUtil.getObjectLitKeyName(name);
        if (memberName != null) {
            JSType rawValueType = name.getFirstChild().getJSType();
            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);
            if (valueType == null) {
                valueType = unknownType;
            }
            objectType.defineInferredProperty(memberName, valueType, name);
            // Do normal flow inference if this is a direct property assignment.
            if (qObjName != null && name.isStringKey()) {
                String qKeyName = qObjName + ""."" + memberName;
                Var var = syntacticScope.getVar(qKeyName);
                JSType oldType = var == null ? null : var.getType();
                if (var != null && var.isTypeInferred()) {
                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));
                }
                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);
            }
        } else {
            n.setJSType(unknownType);
        }
    }
    return scope;
}"
410,Closure,171,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1023.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1661,1709,"/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
    // Prototype sets are always declared.
    if (qName != null && qName.endsWith("".prototype"")) {
        return false;
    }
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            // Functions assigned in conditional blocks are inferred.
            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}"
411,Closure,172,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1042.json,Medium,src/com/google/javascript/jscomp/TypedScopeCreator.java,1661,1715,"/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
    // Prototypes of constructors and interfaces are always declared.
    if (qName != null && qName.endsWith("".prototype"")) {
        String className = qName.substring(0, qName.lastIndexOf("".prototype""));
        Var slot = scope.getSlot(className);
        JSType classType = slot == null ? null : slot.getType();
        if (classType != null && (classType.isConstructor() || classType.isInterface())) {
            return false;
        }
    }
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            // Functions assigned in conditional blocks are inferred.
            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}"
412,Closure,173,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1062.json,Medium,src/com/google/javascript/jscomp/CodeGenerator.java,107,763,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = getContextForNoInOperator(context);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}"
413,Closure,173,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1062.json,Medium,src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,65,113,"/**
 * Tries apply our various peephole minimizations on the passed in node.
 */
@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        case Token.MUL:
        case Token.AND:
        case Token.OR:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
            return tryRotateAssociativeOperator(node);
        default:
            // Nothing changed
            return node;
    }
}"
414,Closure,173,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1062.json,Medium,src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,115,135,"private Node tryRotateAssociativeOperator(Node n) {
    if (!late) {
        return n;
    }
    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
    Node rhs = n.getLastChild();
    if (n.getType() == rhs.getType()) {
        Node parent = n.getParent();
        Node first = n.getFirstChild().detachFromParent();
        Node second = rhs.getFirstChild().detachFromParent();
        Node third = rhs.getLastChild().detachFromParent();
        Node newLhs = new Node(n.getType(), first, second).copyInformationFrom(n);
        Node newRoot = new Node(rhs.getType(), newLhs, third).copyInformationFrom(rhs);
        parent.replaceChild(n, newRoot);
        reportCodeChange();
        return newRoot;
    }
    return n;
}"
415,Closure,174,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1103.json,Medium,src/com/google/javascript/jscomp/JsAst.java,81,110,"private void parse(AbstractCompiler compiler) {
    int startErrorCount = compiler.getErrorManager().getErrorCount();
    try {
        ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(), compiler.getDefaultErrorReporter(), logger_);
        root = result.ast;
        compiler.setOldParseTree(sourceFile.getName(), result.oldAst);
    } catch (IOException e) {
        compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));
    }
    if (root == null || // errors in the code we just parsed.
    (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {
        // There was a parse error or IOException, so use a dummy block.
        root = IR.script();
    } else {
        compiler.prepareAst(root);
    }
    // Set the source name so that the compiler passes can track
    // the source file and module.
    root.setStaticSourceFile(sourceFile);
}"
416,Closure,174,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1103.json,Medium,src/com/google/javascript/jscomp/NodeUtil.java,2360,2375,"/**
 * Creates a node representing a qualified name.
 *
 * @param name A qualified name (e.g. ""foo"" or ""foo.bar.baz"")
 * @return A NAME or GETPROP node
 */
public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) {
    Node result;
    Node nameNode = newQualifiedNameNode(convention, name);
    if (nameNode.isName()) {
        result = IR.var(nameNode, value);
        result.setJSDocInfo(info);
    } else if (value != null) {
        result = IR.exprResult(IR.assign(nameNode, value));
        result.getFirstChild().setJSDocInfo(info);
    } else {
        result = IR.exprResult(nameNode);
        result.getFirstChild().setJSDocInfo(info);
    }
    return result;
}"
417,Closure,174,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1103.json,Medium,src/com/google/javascript/jscomp/ScopedAliases.java,351,402,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
            recordAlias(v);
        } else if (v.isBleedingFunction()) {
        // Bleeding functions already get a BAD_PARAMETERS error, so just
        // do nothing.
        } else if (parent.getType() == Token.LP) {
        // Parameters of the scope function also get a BAD_PARAMETERS
        // error.
        } else if (isVar) {
            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;
            String name = n.getString();
            int nameCount = scopedAliasNames.count(name);
            scopedAliasNames.add(name);
            String globalName = ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));
            compiler.ensureLibraryInjected(""base"");
            // Make sure we copy over all the jsdoc and debug info.
            if (value != null || v.getJSDocInfo() != null) {
                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);
                parent.getParent().addChildBefore(newDecl, parent);
            }
            // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));
            recordAlias(v);
        } else {
            // Do not allow hoisted functions or other kinds of local symbols.
            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
    }
}"
418,Closure,175,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json,Medium,src/com/google/javascript/jscomp/FunctionInjector.java,49,52,"@Override
public String get() {
    return String.valueOf(nextId++);
}"
419,Closure,175,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json,Medium,src/com/google/javascript/jscomp/FunctionInjector.java,181,221,"/**
 * @param t  The traversal use to reach the call site.
 * @param callNode The CALL node.
 * @param fnNode The function to evaluate for inlining.
 * @param needAliases A set of function parameter names that can not be
 *     used without aliasing. Returned by getUnsafeParameterNames().
 * @param mode Inlining mode to be used.
 * @param referencesThis Whether fnNode contains references to its this
 *     object.
 * @param containsFunctions Whether fnNode contains inner functions.
 * @return Whether the inlining can occur.
 */
CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {
    // Allow direct function calls or ""fn.call"" style calls.
    if (!isSupportedCallType(callNode)) {
        return CanInlineResult.NO;
    }
    // last until explicitly cleared.
    if (containsFunctions) {
        if (!assumeMinimumCapture && !t.inGlobalScope()) {
            // inner functions.
            return CanInlineResult.NO;
        } else if (NodeUtil.isWithinLoop(callNode)) {
            // single iteration through a loop.
            return CanInlineResult.NO;
        }
    }
    // TODO(johnlenz): Add support for 'apply'
    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {
        // global 'this' object.
        return CanInlineResult.NO;
    }
    if (mode == InliningMode.DIRECT) {
        return canInlineReferenceDirectly(callNode, fnNode, needAliases);
    } else {
        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);
    }
}"
420,Closure,175,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json,Medium,src/com/google/javascript/jscomp/FunctionInjector.java,697,737,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode, Set<String> namesToAlias) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.throwawayNameSupplier);
    boolean hasArgs = !args.isEmpty();
    if (hasArgs) {
        // Limit the inlining
        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);
        FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());
        if (!allNamesToAlias.isEmpty()) {
            return CanInlineResult.NO;
        }
    }
    return CanInlineResult.YES;
}"
421,Closure,176,googleapis,https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1056.json,Medium,src/com/google/javascript/jscomp/TypeInference.java,523,589,"/**
 * Updates the scope according to the result of a type change, like
 * an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {
    Preconditions.checkNotNull(resultType);
    switch(left.getType()) {
        case Token.NAME:
            String varName = left.getString();
            Var var = syntacticScope.getVar(varName);
            JSType varType = var == null ? null : var.getType();
            boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred();
            // When looking at VAR initializers for declared VARs, we tend
            // to use the declared type over the type it's being
            // initialized to in the global scope.
            // 
            // For example,
            // /** @param {number} */ var f = goog.abstractMethod;
            // it's obvious that the programmer wants you to use
            // the declared function signature, not the inferred signature.
            // 
            // Or,
            // /** @type {Object.<string>} */ var x = {};
            // the one-time anonymous object on the right side
            // is as narrow as it can possibly be, but we need to make
            // sure we back-infer the <string> element constraint on
            // the left hand side, so we use the left hand side.
            boolean isVarTypeBetter = isVarDeclaration && // Makes it easier to check for NPEs.
            !resultType.isNullType() && !resultType.isVoidType();
            if (isVarTypeBetter) {
                redeclareSimpleVar(scope, left, varType);
            } else {
                redeclareSimpleVar(scope, left, resultType);
            }
            left.setJSType(resultType);
            if (var != null && var.isTypeInferred()) {
                JSType oldType = var.getType();
                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
            }
            break;
        case Token.GETPROP:
            String qualifiedName = left.getQualifiedName();
            if (qualifiedName != null) {
                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);
            }
            left.setJSType(resultType);
            ensurePropertyDefined(left, resultType);
            break;
    }
}"
422,Codec,1,jira,https://issues.apache.org/jira/browse/CODEC-65,High,src/java/org/apache/commons/codec/language/Caverphone.java,50,140,"/**
 * Find the caverphone value of a String.
 *
 * @param txt String to find the caverphone code for
 * @return A caverphone code corresponding to the String supplied
 */
public String caverphone(String txt) {
    if (txt == null || txt.length() == 0) {
        return ""1111111111"";
    }
    // 1. Convert to lowercase
    txt = txt.toLowerCase(java.util.Locale.ENGLISH);
    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");
    // 2.5. Remove final e
    // 2.0 only
    txt = txt.replaceAll(""e$"", """");
    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    // 2.0 only
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    // 2.0 only - note the spec says ^enough here again, c+p error I assume
    txt = txt.replaceAll(""^trough"", ""trou2f"");
    txt = txt.replaceAll(""^gn"", ""2n"");
    txt = txt.replaceAll(""^mb"", ""m2"");
    // 4. Handle replacements
    txt = txt.replaceAll(""cq"", ""2q"");
    txt = txt.replaceAll(""ci"", ""si"");
    txt = txt.replaceAll(""ce"", ""se"");
    txt = txt.replaceAll(""cy"", ""sy"");
    txt = txt.replaceAll(""tch"", ""2ch"");
    txt = txt.replaceAll(""c"", ""k"");
    txt = txt.replaceAll(""q"", ""k"");
    txt = txt.replaceAll(""x"", ""k"");
    txt = txt.replaceAll(""v"", ""f"");
    txt = txt.replaceAll(""dg"", ""2g"");
    txt = txt.replaceAll(""tio"", ""sio"");
    txt = txt.replaceAll(""tia"", ""sia"");
    txt = txt.replaceAll(""d"", ""t"");
    txt = txt.replaceAll(""ph"", ""fh"");
    txt = txt.replaceAll(""b"", ""p"");
    txt = txt.replaceAll(""sh"", ""s2"");
    txt = txt.replaceAll(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    // 2.0 only
    txt = txt.replaceAll(""j"", ""y"");
    // 2.0 only
    txt = txt.replaceAll(""^y3"", ""Y3"");
    // 2.0 only
    txt = txt.replaceAll(""^y"", ""A"");
    // 2.0 only
    txt = txt.replaceAll(""y"", ""3"");
    txt = txt.replaceAll(""3gh3"", ""3kh3"");
    txt = txt.replaceAll(""gh"", ""22"");
    txt = txt.replaceAll(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replaceAll(""w3"", ""W3"");
    // txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
    txt = txt.replaceAll(""wh3"", ""Wh3"");
    // 2.0 only
    txt = txt.replaceAll(""w$"", ""3"");
    // txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
    txt = txt.replaceAll(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replaceAll(""h"", ""2"");
    txt = txt.replaceAll(""r3"", ""R3"");
    // 2.0 only
    txt = txt.replaceAll(""r$"", ""3"");
    // txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
    txt = txt.replaceAll(""r"", ""2"");
    txt = txt.replaceAll(""l3"", ""L3"");
    // 2.0 only
    txt = txt.replaceAll(""l$"", ""3"");
    // txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
    txt = txt.replaceAll(""l"", ""2"");
    // txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
    // txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
    // txt = txt.replaceAll(""y"", ""2"");      // 1.0 only
    // 5. Handle removals
    txt = txt.replaceAll(""2"", """");
    // 2.0 only
    txt = txt.replaceAll(""3$"", ""A"");
    txt = txt.replaceAll(""3"", """");
    // 6. put ten 1s on the end
    // 1.0 only has 6 1s
    txt = txt + ""111111"" + ""1111"";
    // 1.0 truncates to 6
    return txt.substring(0, 10);
}"
423,Codec,1,jira,https://issues.apache.org/jira/browse/CODEC-65,High,src/java/org/apache/commons/codec/language/Metaphone.java,81,313,"/**
 * Find the metaphone value of a String. This is similar to the
 * soundex algorithm, but better at finding similar sounding words.
 * All input is converted to upper case.
 * Limitations: Input format is expected to be a single ASCII word
 * with only characters in the A - Z range, no punctuation or numbers.
 *
 * @param txt String to find the metaphone code for
 * @return A metaphone code corresponding to the String supplied
 */
public String metaphone(String txt) {
    boolean hard = false;
    if ((txt == null) || (txt.length() == 0)) {
        return """";
    }
    // single character is itself
    if (txt.length() == 1) {
        return txt.toUpperCase(java.util.Locale.ENGLISH);
    }
    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
    // manipulate
    StringBuffer local = new StringBuffer(40);
    // output
    StringBuffer code = new StringBuffer(10);
    // handle initial 2 characters exceptions
    switch(inwd[0]) {
        case 'K':
        case 'G':
        case 'P':
            /* looking for KN, etc*/
            if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A':
            /* looking for AE */
            if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W':
            /* looking for WR or WH */
            if (inwd[1] == 'R') {
                // WR -> R
                local.append(inwd, 1, inwd.length - 1);
                break;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                // WH -> W
                local.setCharAt(0, 'W');
            } else {
                local.append(inwd);
            }
            break;
        case 'X':
            /* initial X becomes S */
            inwd[0] = 'S';
            local.append(inwd);
            break;
        default:
            local.append(inwd);
    }
    // now local has working string with initials fixed
    int wdsz = local.length();
    int n = 0;
    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
        // max code size of 4 works well
        char symb = local.charAt(n);
        // remove duplicate letters except C
        if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
            n++;
        } else {
            // not dup
            switch(symb) {
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U':
                    if (n == 0) {
                        code.append(symb);
                    }
                    // only use vowel if leading char
                    break;
                case 'B':
                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
                        // B is silent if word ends in MB
                        break;
                    }
                    code.append(symb);
                    break;
                case // lots of C special cases
                'C':
                    /* discard if SCI, SCE or SCY */
                    if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) {
                        // ""CIA"" -> X
                        code.append('X');
                        break;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        code.append('S');
                        // CI,CE,CY -> S
                        break;
                    }
                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
                        // SCH->sk
                        code.append('K');
                        break;
                    }
                    if (isNextChar(local, n, 'H')) {
                        // detect CH
                        if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
                            // CH consonant -> K consonant
                            code.append('K');
                        } else {
                            // CHvowel -> X
                            code.append('X');
                        }
                    } else {
                        code.append('K');
                    }
                    break;
                case 'D':
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
                        // DGE DGI DGY -> J
                        code.append('J');
                        n += 2;
                    } else {
                        code.append('T');
                    }
                    break;
                case // GH silent at end or before consonant
                'G':
                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
                        break;
                    }
                    if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
                        // silent G
                        break;
                    }
                    if (isPreviousChar(local, n, 'G')) {
                        hard = true;
                    } else {
                        hard = false;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                        // terminal H
                        break;
                    }
                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
                        break;
                    }
                    if (isVowel(local, n + 1)) {
                        // Hvowel
                        code.append('H');
                    }
                    break;
                case 'F':
                case 'J':
                case 'L':
                case 'M':
                case 'N':
                case 'R':
                    code.append(symb);
                    break;
                case 'K':
                    if (n > 0) {
                        // not initial
                        if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                        // initial K
                        code.append(symb);
                    }
                    break;
                case 'P':
                    if (isNextChar(local, n, 'H')) {
                        // PH -> F
                        code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break;
                case 'Q':
                    code.append('K');
                    break;
                case 'S':
                    if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T':
                    if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
                        code.append('X');
                        break;
                    }
                    if (regionMatch(local, n, ""TCH"")) {
                        // Silent if in ""TCH""
                        break;
                    }
                    // substitute numeral 0 for TH (resembles theta after all)
                    if (regionMatch(local, n, ""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break;
                case 'V':
                    code.append('F');
                    break;
                case 'W':
                case // silent if not followed by vowel
                'Y':
                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
                        code.append(symb);
                    }
                    break;
                case 'X':
                    code.append('K');
                    code.append('S');
                    break;
                case 'Z':
                    code.append('S');
                    break;
            }
            // end switch
            n++;
        }
        // end else from symb != 'C'
        if (code.length() > this.getMaxCodeLen()) {
            code.setLength(this.getMaxCodeLen());
        }
    }
    return code.toString();
}"
424,Codec,1,jira,https://issues.apache.org/jira/browse/CODEC-65,High,src/java/org/apache/commons/codec/language/SoundexUtils.java,40,56,"/**
 *  Cleans up the input string before Soundex processing by only returning
 *  upper case letters.
 *
 *  @param str
 *                   The String to clean.
 *  @return A clean String.
 */
static String clean(String str) {
    if (str == null || str.length() == 0) {
        return str;
    }
    int len = str.length();
    char[] chars = new char[len];
    int count = 0;
    for (int i = 0; i < len; i++) {
        if (Character.isLetter(str.charAt(i))) {
            chars[count++] = str.charAt(i);
        }
    }
    if (count == len) {
        return str.toUpperCase(java.util.Locale.ENGLISH);
    }
    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);
}"
425,Codec,2,jira,https://issues.apache.org/jira/browse/CODEC-77,High,src/java/org/apache/commons/codec/binary/Base64.java,414,473,"/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes.
 * Must be called at least twice:  once with the data to encode, and once
 * with inAvail set to ""-1"" to alert encoder that EOF has been reached,
 * so flush last remaining bytes (if not multiple of 3).
 * </p><p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
 * and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in byte[] array of binary data to base64 encode.
 * @param inPos Position to start reading data from.
 * @param inAvail Amount of bytes available from input for encoding.
 */
void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // encoding.
    if (inAvail < 0) {
        eof = true;
        if (buf == null || buf.length - pos < encodeSize) {
            resizeBuf();
        }
        switch(modulus) {
            case 1:
                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buf[pos++] = PAD;
                    buf[pos++] = PAD;
                }
                break;
            case 2:
                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buf[pos++] = PAD;
                }
                break;
        }
        if (lineLength > 0 && pos > 0) {
            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buf == null || buf.length - pos < encodeSize) {
                resizeBuf();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            x = (x << 8) + b;
            if (0 == modulus) {
                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buf[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && lineLength <= currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}"
426,Codec,3,jira,https://issues.apache.org/jira/browse/CODEC-84,Low,src/java/org/apache/commons/codec/language/DoubleMetaphone.java,418,469,"/**
 * Handles 'G' cases
 */
private int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {
    if (charAt(value, index + 1) == 'H') {
        index = handleGH(value, result, index);
    } else if (charAt(value, index + 1) == 'N') {
        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {
            result.append(""KN"", ""N"");
        } else if (!contains(value, index + 2, 2, ""EY"") && charAt(value, index + 1) != 'Y' && !slavoGermanic) {
            result.append(""N"", ""KN"");
        } else {
            result.append(""KN"");
        }
        index = index + 2;
    } else if (contains(value, index + 1, 2, ""LI"") && !slavoGermanic) {
        result.append(""KL"", ""L"");
        index += 2;
    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {
        // -- -ges-, -gep-, -gel-, -gie- at beginning --//
        result.append('K', 'J');
        index += 2;
    } else if ((contains(value, index + 1, 2, ""ER"") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, ""DANGER"", ""RANGER"", ""MANGER"") && !contains(value, index - 1, 1, ""E"", ""I"") && !contains(value, index - 1, 3, ""RGY"", ""OGY"")) {
        // -- -ger-, -gy- --//
        result.append('K', 'J');
        index += 2;
    } else if (contains(value, index + 1, 1, ""E"", ""I"", ""Y"") || contains(value, index - 1, 4, ""AGGI"", ""OGGI"")) {
        // -- Italian ""biaggi"" --//
        if ((contains(value, 0, 4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"")) || contains(value, index + 1, 2, ""ET"")) {
            // -- obvious germanic --//
            result.append('K');
        } else if (contains(value, index + 1, 3, ""IER"")) {
            result.append('J');
        } else {
            result.append('J', 'K');
        }
        index += 2;
    } else if (charAt(value, index + 1) == 'G') {
        index += 2;
        result.append('K');
    } else {
        index++;
        result.append('K');
    }
    return index;
}"
427,Codec,5,jira,https://issues.apache.org/jira/browse/CODEC-98,Critical,src/java/org/apache/commons/codec/binary/Base64.java,550,602,"/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to base64 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */
void decode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    if (inAvail < 0) {
        eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        byte b = in[inPos++];
        if (b == PAD) {
            // We're done.
            eof = true;
            break;
        } else {
            if (b >= 0 && b < DECODE_TABLE.length) {
                int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }
    }
    // This approach makes the '=' padding characters completely optional.
    if (eof && modulus != 0) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        x = x << 6;
        switch(modulus) {
            case 2:
                x = x << 6;
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                break;
            case 3:
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                break;
        }
    }
}"
428,Codec,6,jira,https://issues.apache.org/jira/browse/CODEC-101,High,src/java/org/apache/commons/codec/binary/Base64InputStream.java,138,184,"/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */
public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                // when possible.
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}"
429,Codec,7,jira,https://issues.apache.org/jira/browse/CODEC-99,High,src/java/org/apache/commons/codec/binary/Base64.java,669,671,"/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */
public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false));
}"
430,Codec,8,jira,https://issues.apache.org/jira/browse/CODEC-105,High,src/java/org/apache/commons/codec/binary/Base64InputStream.java,138,179,"/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */
public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}"
431,Codec,9,jira,https://issues.apache.org/jira/browse/CODEC-112,Low,src/java/org/apache/commons/codec/binary/Base64.java,822,837,"/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */
public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}"
432,Codec,10,jira,https://issues.apache.org/jira/browse/CODEC-117,High,src/java/org/apache/commons/codec/language/Caverphone.java,50,142,"/**
 * Encodes the given String into a Caverphone value.
 *
 * @param txt String the source string
 * @return A caverphone code for the given String
 */
public String caverphone(String txt) {
    if (txt == null || txt.length() == 0) {
        return ""1111111111"";
    }
    // 1. Convert to lowercase
    txt = txt.toLowerCase(java.util.Locale.ENGLISH);
    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");
    // 2.5. Remove final e
    // 2.0 only
    txt = txt.replaceAll(""e$"", """");
    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    // 2.0 only
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    // 2.0 only - note the spec says ^enough here again, c+p error I assume
    txt = txt.replaceAll(""^trough"", ""trou2f"");
    txt = txt.replaceAll(""^gn"", ""2n"");
    // End
    txt = txt.replaceAll(""mb$"", ""m2"");
    // 4. Handle replacements
    txt = txt.replaceAll(""cq"", ""2q"");
    txt = txt.replaceAll(""ci"", ""si"");
    txt = txt.replaceAll(""ce"", ""se"");
    txt = txt.replaceAll(""cy"", ""sy"");
    txt = txt.replaceAll(""tch"", ""2ch"");
    txt = txt.replaceAll(""c"", ""k"");
    txt = txt.replaceAll(""q"", ""k"");
    txt = txt.replaceAll(""x"", ""k"");
    txt = txt.replaceAll(""v"", ""f"");
    txt = txt.replaceAll(""dg"", ""2g"");
    txt = txt.replaceAll(""tio"", ""sio"");
    txt = txt.replaceAll(""tia"", ""sia"");
    txt = txt.replaceAll(""d"", ""t"");
    txt = txt.replaceAll(""ph"", ""fh"");
    txt = txt.replaceAll(""b"", ""p"");
    txt = txt.replaceAll(""sh"", ""s2"");
    txt = txt.replaceAll(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    // 2.0 only
    txt = txt.replaceAll(""j"", ""y"");
    // 2.0 only
    txt = txt.replaceAll(""^y3"", ""Y3"");
    // 2.0 only
    txt = txt.replaceAll(""^y"", ""A"");
    // 2.0 only
    txt = txt.replaceAll(""y"", ""3"");
    txt = txt.replaceAll(""3gh3"", ""3kh3"");
    txt = txt.replaceAll(""gh"", ""22"");
    txt = txt.replaceAll(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replaceAll(""w3"", ""W3"");
    // txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
    txt = txt.replaceAll(""wh3"", ""Wh3"");
    // 2.0 only
    txt = txt.replaceAll(""w$"", ""3"");
    // txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
    txt = txt.replaceAll(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replaceAll(""h"", ""2"");
    txt = txt.replaceAll(""r3"", ""R3"");
    // 2.0 only
    txt = txt.replaceAll(""r$"", ""3"");
    // txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
    txt = txt.replaceAll(""r"", ""2"");
    txt = txt.replaceAll(""l3"", ""L3"");
    // 2.0 only
    txt = txt.replaceAll(""l$"", ""3"");
    // txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
    txt = txt.replaceAll(""l"", ""2"");
    // txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
    // txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
    // txt = txt.replaceAll(""y"", ""2"");      // 1.0 only
    // 5. Handle removals
    txt = txt.replaceAll(""2"", """");
    // 2.0 only
    txt = txt.replaceAll(""3$"", ""A"");
    txt = txt.replaceAll(""3"", """");
    // 6. put ten 1s on the end
    // 1.0 only has 6 1s
    txt = txt + ""111111"" + ""1111"";
    // 1.0 truncates to 6
    return txt.substring(0, 10);
}"
433,Codec,11,jira,https://issues.apache.org/jira/browse/CODEC-121,High,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,117,124,"/**
 * Encodes byte into its quoted-printable representation.
 *
 * @param b
 *            byte to encode
 * @param buffer
 *            the buffer to write to
 * @return The number of bytes written to the <code>buffer</code>
 */
private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
    buffer.write(ESCAPE_CHAR);
    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
    buffer.write(hex1);
    buffer.write(hex2);
    return 3;
}"
434,Codec,11,jira,https://issues.apache.org/jira/browse/CODEC-121,High,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,136,142,"/**
 * Return the byte at position <code>index</code> of the byte array and
 * make sure it is unsigned.
 *
 * @param index
 *                  position in the array
 * @param bytes
 *                  the byte array
 * @return the unsigned octet at position <code>index</code> from the array
 */
private static int getUnsignedOctet(final int index, final byte[] bytes) {
    int b = bytes[index];
    if (b < 0) {
        b = 256 + b;
    }
    return b;
}"
435,Codec,11,jira,https://issues.apache.org/jira/browse/CODEC-121,High,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,155,163,"/**
 * Write a byte to the buffer.
 *
 * @param b
 *                  byte to write
 * @param encode
 *                  indicates whether the octet shall be encoded
 * @param buffer
 *                  the buffer to write to
 * @return the number of bytes that have been written to the buffer
 */
private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer) {
    if (encode) {
        return encodeQuotedPrintable(b, buffer);
    } else {
        buffer.write(b);
        return 1;
    }
}"
436,Codec,11,jira,https://issues.apache.org/jira/browse/CODEC-121,High,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,172,174,"/**
 * Checks whether the given byte is whitespace.
 *
 * @param b
 *                  byte to be checked
 * @return <code>true</code> if the byte is either a space or tab character
 */
private static boolean isWhitespace(final int b) {
    return b == SPACE || b == TAB;
}"
437,Codec,11,jira,https://issues.apache.org/jira/browse/CODEC-121,High,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,190,240,"/**
 * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.
 *
 * <p>
 * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)
 * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.
 * </p>
 *
 * @param printable
 *                  bitset of characters deemed quoted-printable
 * @param bytes
 *                  array of bytes to be encoded
 * @return array of bytes containing quoted-printable data
 */
public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
    if (bytes == null) {
        return null;
    }
    if (printable == null) {
        printable = PRINTABLE_CHARS;
    }
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    int pos = 1;
    // separately for simplification of note #3
    for (int i = 0; i < bytes.length - 3; i++) {
        int b = getUnsignedOctet(i, bytes);
        if (pos < SAFE_LENGTH) {
            // up to this length it is safe to add any byte, encoded or not
            pos += encodeByte(b, !printable.get(b), buffer);
        } else {
            // rule #3: whitespace at the end of a line *must* be encoded
            encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
            // rule #5: soft line break
            buffer.write(ESCAPE_CHAR);
            buffer.write(CR);
            buffer.write(LF);
            pos = 1;
        }
    }
    // rule #3: whitespace at the end of a line *must* be encoded
    // if we would do a soft break line after this octet, encode whitespace
    int b = getUnsignedOctet(bytes.length - 3, bytes);
    boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
    pos += encodeByte(b, encode, buffer);
    // exactly 6 bytes space for the last 2 bytes
    if (pos > SAFE_LENGTH - 2) {
        buffer.write(ESCAPE_CHAR);
        buffer.write(CR);
        buffer.write(LF);
    }
    for (int i = bytes.length - 2; i < bytes.length; i++) {
        b = getUnsignedOctet(i, bytes);
        // rule #3: trailing whitespace shall be encoded
        encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
        encodeByte(b, encode, buffer);
    }
    return buffer.toByteArray();
}"
438,Codec,11,jira,https://issues.apache.org/jira/browse/CODEC-121,High,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,257,282,"/**
 * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are
 * converted back to their original representation.
 *
 * <p>
 * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as
 * defined in RFC 1521.
 * </p>
 *
 * @param bytes
 *                  array of quoted-printable characters
 * @return array of original bytes
 * @throws DecoderException
 *                  Thrown if quoted-printable decoding is unsuccessful
 */
public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    for (int i = 0; i < bytes.length; i++) {
        final int b = bytes[i];
        if (b == ESCAPE_CHAR) {
            try {
                // if the next octet is a CR we have found a soft line break
                if (bytes[++i] == CR) {
                    continue;
                }
                int u = Utils.digit16(bytes[i]);
                int l = Utils.digit16(bytes[++i]);
                buffer.write((char) ((u << 4) + l));
            } catch (ArrayIndexOutOfBoundsException e) {
                throw new DecoderException(""Invalid quoted-printable encoding"", e);
            }
        } else if (b != CR && b != LF) {
            // every other octet is appended except for CR & LF
            buffer.write(b);
        }
    }
    return buffer.toByteArray();
}"
439,Codec,12,jira,https://issues.apache.org/jira/browse/CODEC-130,Low,src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java,142,166,"/**
 * {@inheritDoc}
 *
 * @throws IllegalArgumentException if the provided skip length is negative
 */
@Override
public long skip(long n) throws IOException {
    if (n < 0) {
        throw new IllegalArgumentException(""Negative skip length"");
    }
    // skip in chunks of 512 bytes
    final byte[] b = new byte[512];
    final int max = (int) Math.min(n, Integer.MAX_VALUE);
    int total = 0;
    while (total < max) {
        int len = max - total;
        if (len > b.length) {
            len = b.length;
        }
        len = read(b, 0, len);
        if (len == EOF) {
            break;
        }
        total += len;
    }
    return total;
}"
440,Codec,12,jira,https://issues.apache.org/jira/browse/CODEC-130,Low,src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java,174,186,"/**
 * {@inheritDoc}
 *
 * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
 * <code>1</code> otherwise
 */
public int available() throws IOException {
    // use the EOF flag of the underlying codec instance
    if (baseNCodec.eof) {
        return 0;
    } else {
        return 1;
    }
}"
441,Codec,13,jira,https://issues.apache.org/jira/browse/CODEC-184,High,src/main/java/org/apache/commons/codec/binary/StringUtils.java,70,81,"/**
 * <p>
 * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal. The
 * comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be {@code null}
 * @param cs2
 *            the second CharSequence, may be {@code null}
 * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
 * @since 1.10
 */
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}"
442,Codec,13,jira,https://issues.apache.org/jira/browse/CODEC-184,High,src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java,244,246,"/**
 * Check if the Double Metaphone values of two <code>String</code> values
 * are equal, optionally using the alternate value.
 *
 * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
 * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
 * @param alternate use the alternate value if {@code true}.
 * @return {@code true} if the encoded <code>String</code>s are equal;
 *          {@code false} otherwise.
 */
public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
    return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));
}"
443,Codec,14,jira,https://issues.apache.org/jira/browse/CODEC-187,Low,src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java,329,374,"/**
 * Applies the final rules to convert from a language-specific phonetic representation to a
 * language-independent representation.
 *
 * @param phonemeBuilder the current phonemes
 * @param finalRules the final rules to apply
 * @return the resulting phonemes
 */
private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) {
    if (finalRules == null) {
        throw new NullPointerException(""finalRules can not be null"");
    }
    if (finalRules.isEmpty()) {
        return phonemeBuilder;
    }
    final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);
    for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
        PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
        final String phonemeText = phoneme.getPhonemeText().toString();
        for (int i = 0; i < phonemeText.length(); ) {
            final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
            final boolean found = rulesApplication.isFound();
            subBuilder = rulesApplication.getPhonemeBuilder();
            if (!found) {
                // not found, appending as-is
                subBuilder.append(phonemeText.subSequence(i, i + 1));
            }
            i = rulesApplication.getI();
        }
        // phonemes with the same text but different language set get lost
        for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
            if (phonemes.containsKey(newPhoneme)) {
                final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                phonemes.put(mergedPhoneme, mergedPhoneme);
            } else {
                phonemes.put(newPhoneme, newPhoneme);
            }
        }
    }
    return new PhonemeBuilder(phonemes.keySet());
}"
444,Codec,14,jira,https://issues.apache.org/jira/browse/CODEC-187,Low,src/main/java/org/apache/commons/codec/language/bm/Rule.java,158,160,"/**
 * Returns a new Phoneme with the same text but a union of its
 * current language set and the given one.
 *
 * @param lang the language set to merge
 * @return a new Phoneme
 */
public Phoneme mergeWithLanguage(final LanguageSet lang) {
    return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));
}"
445,Codec,15,jira,https://issues.apache.org/jira/browse/CODEC-199,High,src/main/java/org/apache/commons/codec/language/Soundex.java,183,199,"/**
 * Used internally by the Soundex algorithm.
 *
 * Consonants from the same code group separated by W or H are treated as one.
 *
 * @param str
 *                  the cleaned working string to encode (in upper case).
 * @param index
 *                  the character position to encode
 * @return Mapping code for a particular character
 * @throws IllegalArgumentException
 *                  if the character is not mapped
 */
private char getMappingCode(final String str, final int index) {
    // map() throws IllegalArgumentException
    final char mappedChar = this.map(str.charAt(index));
    // HW rule check
    if (index > 1 && mappedChar != '0') {
        for (int i = index - 1; i >= 0; i--) {
            final char prevChar = str.charAt(i);
            if (this.map(prevChar) == mappedChar) {
                return 0;
            }
            if ('H' != prevChar && 'W' != prevChar) {
                break;
            }
        }
    }
    return mappedChar;
}"
446,Codec,17,jira,https://issues.apache.org/jira/browse/CODEC-229,High,src/main/java/org/apache/commons/codec/binary/StringUtils.java,338,340,"/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */
public static String newStringIso8859_1(final byte[] bytes) {
    return newString(bytes, Charsets.ISO_8859_1);
}"
447,Codec,18,jira,https://issues.apache.org/jira/browse/CODEC-231,High,src/main/java/org/apache/commons/codec/binary/StringUtils.java,71,82,"/**
 * <p>
 * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.
 * The comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be <code>null</code>
 * @param cs2
 *            the second CharSequence, may be <code>null</code>
 * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>
 * @since 1.10
 */
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());
}"
448,Collections,25,jira,https://issues.apache.org/jira/browse/COLLECTIONS-566,High,src/main/java/org/apache/commons/collections4/IteratorUtils.java,602,608,"// Collated
// -----------------------------------------------------------------------
/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of ordered {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code>.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterator1  the first iterators to use, not null
 * @param iterator2  the first iterators to use, not null
 * @return a combination iterator over the iterators
 * @throws NullPointerException if either iterator is null
 */
public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {
    @SuppressWarnings(""unchecked"")
    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;
    return new CollatingIterator<E>(comp, iterator1, iterator2);
}"
449,Collections,25,jira,https://issues.apache.org/jira/browse/COLLECTIONS-566,High,src/main/java/org/apache/commons/collections4/IteratorUtils.java,626,631,"/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in an array of {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code> and so on.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterators  the iterators to use, not null or empty or contain nulls
 * @return a combination iterator over the iterators
 * @throws NullPointerException if iterators array is null or contains a null value
 */
public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {
    @SuppressWarnings(""unchecked"")
    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;
    return new CollatingIterator<E>(comp, iterators);
}"
450,Collections,25,jira,https://issues.apache.org/jira/browse/COLLECTIONS-566,High,src/main/java/org/apache/commons/collections4/IteratorUtils.java,650,655,"/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code> and so on.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterators  the iterators to use, not null or empty or contain nulls
 * @return a combination iterator over the iterators
 * @throws NullPointerException if iterators collection is null or contains a null
 * @throws ClassCastException if the iterators collection contains the wrong object type
 */
public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {
    @SuppressWarnings(""unchecked"")
    final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;
    return new CollatingIterator<E>(comp, iterators);
}"
451,Collections,26,jira,https://issues.apache.org/jira/browse/COLLECTIONS-576,High,src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java,277,280,"/**
 * Recalculate the hash code after deserialization. The hash code of some
 * keys might have change (hash codes based on the system hash code are
 * only stable for the same process).
 * @return the instance with recalculated hash code
 */
protected Object readResolve() {
    calculateHashCode(keys);
    return this;
}"
452,Collections,27,jira,https://issues.apache.org/jira/browse/COLLECTIONS-580,High,src/main/java/org/apache/commons/collections4/map/MultiValueMap.java,568,574,"private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {
    is.defaultReadObject();
    // ensure that the de-serialized class is a Collection, COLLECTIONS-580
    if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {
        throw new UnsupportedOperationException();
    }
}"
453,Collections,28,jira,https://issues.apache.org/jira/browse/COLLECTIONS-586,High,src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java,2262,2271,"@Override
public void clear() {
    Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
    Set<K> currentKeys = keySet();
    while (it.hasNext()) {
        if (currentKeys.contains(it.next().getKey())) {
            it.remove();
        }
    }
}"
454,Compress,1,jira,https://issues.apache.org/jira/browse/COMPRESS-28,High,src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java,344,350,"/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */
public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        super.close();
        this.closed = true;
    }
}"
455,Compress,2,jira,https://issues.apache.org/jira/browse/COMPRESS-11,High,src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java,61,133,"/**
 * Returns the next AR entry in this stream.
 *
 * @return the next AR entry.
 * @throws IOException
 *             if the entry could not be read
 */
public ArArchiveEntry getNextArEntry() throws IOException {
    if (currentEntry != null) {
        final long entryEnd = entryOffset + currentEntry.getLength();
        while (offset < entryEnd) {
            int x = read();
            if (x == -1) {
                // TODO: throw an exception instead?
                return null;
            }
        }
        currentEntry = null;
    }
    if (offset == 0) {
        final byte[] expected = ArArchiveEntry.HEADER.getBytes();
        final byte[] realized = new byte[expected.length];
        final int read = read(realized);
        if (read != expected.length) {
            throw new IOException(""failed to read header"");
        }
        for (int i = 0; i < expected.length; i++) {
            if (expected[i] != realized[i]) {
                throw new IOException(""invalid header "" + new String(realized));
            }
        }
    }
    if (offset % 2 != 0) {
        if (read() < 0) {
            // hit eof
            return null;
        }
    }
    if (input.available() == 0) {
        return null;
    }
    final byte[] name = new byte[16];
    final byte[] lastmodified = new byte[12];
    final byte[] userid = new byte[6];
    final byte[] groupid = new byte[6];
    final byte[] filemode = new byte[8];
    final byte[] length = new byte[10];
    read(name);
    read(lastmodified);
    read(userid);
    read(groupid);
    read(filemode);
    read(length);
    {
        final byte[] expected = ArArchiveEntry.TRAILER.getBytes();
        final byte[] realized = new byte[expected.length];
        final int read = read(realized);
        if (read != expected.length) {
            throw new IOException(""failed to read entry header"");
        }
        for (int i = 0; i < expected.length; i++) {
            if (expected[i] != realized[i]) {
                throw new IOException(""invalid entry header. not read the content?"");
            }
        }
    }
    entryOffset = offset;
    currentEntry = new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));
    return currentEntry;
}"
456,Compress,2,jira,https://issues.apache.org/jira/browse/COMPRESS-11,High,src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java,140,146,"public void close() throws IOException {
    if (!closed) {
        closed = true;
        input.close();
    }
    currentEntry = null;
}"
457,Compress,2,jira,https://issues.apache.org/jira/browse/COMPRESS-11,High,src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java,148,152,"public int read() throws IOException {
    byte[] single = new byte[1];
    int num = read(single, 0, 1);
    return num == -1 ? -1 : single[0] & 0xff;
}"
458,Compress,2,jira,https://issues.apache.org/jira/browse/COMPRESS-11,High,src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java,158,171,"public int read(byte[] b, final int off, final int len) throws IOException {
    int toRead = len;
    if (currentEntry != null) {
        final long entryEnd = entryOffset + currentEntry.getLength();
        if (len > 0 && entryEnd > offset) {
            toRead = (int) Math.min(len, entryEnd - offset);
        } else {
            return -1;
        }
    }
    final int ret = this.input.read(b, off, toRead);
    offset += (ret > 0 ? ret : 0);
    return ret;
}"
459,Compress,3,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,112,118,"/**
 * Ends the TAR archive without closing the underlying OutputStream.
 *
 * An archive consists of a series of file entries terminated by an
 * end-of-archive entry, which consists of two 512 blocks of zero bytes.
 * POSIX.1 requires two EOF records, like some other implementations.
 *
 * @throws IOException on error
 */
public void finish() throws IOException {
    if (haveUnclosedEntry) {
        throw new IOException(""This archives contains unclosed entries."");
    }
    writeEOFRecord();
    writeEOFRecord();
}"
460,Compress,3,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,157,192,"/**
 * Put an entry on the output stream. This writes the entry's
 * header record and positions the output stream for writing
 * the contents of the entry. Once this method is called, the
 * stream is ready for calls to write() to write the entry's
 * contents. Once the contents are written, closeArchiveEntry()
 * <B>MUST</B> be called to ensure that all buffered data
 * is completely written to the output stream.
 *
 * @param archiveEntry The TarEntry to be written to the archive.
 * @throws IOException on error
 * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry
 */
public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {
    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;
    if (entry.getName().length() >= TarConstants.NAMELEN) {
        if (longFileMode == LONGFILE_GNU) {
            // create a TarEntry for the LongLink, the contents
            // of which are the entry's name
            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);
            // TODO is it correct to use the default charset here?
            final byte[] nameBytes = entry.getName().getBytes();
            // +1 for NUL
            longLinkEntry.setSize(nameBytes.length + 1);
            putArchiveEntry(longLinkEntry);
            write(nameBytes);
            // NUL terminator
            write(0);
            closeArchiveEntry();
        } else if (longFileMode != LONGFILE_TRUNCATE) {
            throw new RuntimeException(""file name '"" + entry.getName() + ""' is too long ( > "" + TarConstants.NAMELEN + "" bytes)"");
        }
    }
    entry.writeEntryHeader(recordBuf);
    buffer.writeRecord(recordBuf);
    currBytes = 0;
    if (entry.isDirectory()) {
        currSize = 0;
    } else {
        currSize = entry.getSize();
    }
    currName = entry.getName();
    haveUnclosedEntry = true;
}"
461,Compress,3,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,204,223,"/**
 * Close an entry. This method MUST be called for all file
 * entries that contain data. The reason is that we must
 * buffer data written to the stream in order to satisfy
 * the buffer's record based writes. Thus, there may be
 * data fragments still being assembled that must be written
 * to the output stream before this entry is closed and the
 * next entry written.
 * @throws IOException on error
 */
public void closeArchiveEntry() throws IOException {
    if (assemLen > 0) {
        for (int i = assemLen; i < assemBuf.length; ++i) {
            assemBuf[i] = 0;
        }
        buffer.writeRecord(assemBuf);
        currBytes += assemLen;
        assemLen = 0;
    }
    if (currBytes < currSize) {
        throw new IOException(""entry '"" + currName + ""' closed at '"" + currBytes + ""' before the '"" + currSize + ""' bytes specified in the header were written"");
    }
    haveUnclosedEntry = false;
}"
462,Compress,4,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java,334,339,"/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */
public void close() throws IOException {
    if (!this.closed) {
        out.close();
        this.closed = true;
    }
}"
463,Compress,4,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,124,130,"/**
 * Closes the underlying OutputStream.
 * @throws IOException on error
 */
public void close() throws IOException {
    if (!closed) {
        buffer.close();
        out.close();
        closed = true;
    }
}"
464,Compress,4,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,529,536,"/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
public void close() throws IOException {
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}"
465,Compress,4,jira,https://issues.apache.org/jira/browse/COMPRESS-64,High,src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java,67,130,"/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */
public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    out.finish();
    return results;
}"
466,Compress,5,jira,https://issues.apache.org/jira/browse/COMPRESS-87,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,191,250,"public int read(byte[] buffer, int start, int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (inf.finished() || current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) {
        if (current.getMethod() == ZipArchiveOutputStream.STORED) {
            int csize = (int) current.getSize();
            if (readBytesOfEntry >= csize) {
                return -1;
            }
            if (offsetInBuffer >= lengthOfLastRead) {
                offsetInBuffer = 0;
                if ((lengthOfLastRead = in.read(buf)) == -1) {
                    return -1;
                }
                count(lengthOfLastRead);
                bytesReadFromStream += lengthOfLastRead;
            }
            int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length;
            if ((csize - readBytesOfEntry) < toRead) {
                toRead = csize - readBytesOfEntry;
            }
            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);
            offsetInBuffer += toRead;
            readBytesOfEntry += toRead;
            crc.update(buffer, start, toRead);
            return toRead;
        }
        if (inf.needsInput()) {
            fill();
            if (lengthOfLastRead > 0) {
                bytesReadFromStream += lengthOfLastRead;
            }
        }
        int read = 0;
        try {
            read = inf.inflate(buffer, start, length);
        } catch (DataFormatException e) {
            throw new ZipException(e.getMessage());
        }
        if (read == 0) {
            if (inf.finished()) {
                return -1;
            } else if (lengthOfLastRead == -1) {
                throw new IOException(""Truncated ZIP file"");
            }
        }
        crc.update(buffer, start, read);
        return read;
    }
    throw new ArrayIndexOutOfBoundsException();
}"
467,Compress,6,jira,https://issues.apache.org/jira/browse/COMPRESS-94,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java,455,473,"/* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    String myName = getName();
    String otherName = other.getName();
    if (myName == null) {
        if (otherName != null) {
            return false;
        }
    } else if (!myName.equals(otherName)) {
        return false;
    }
    return true;
}"
468,Compress,7,jira,https://issues.apache.org/jira/browse/COMPRESS-114,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,93,106,"/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */
public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}"
469,Compress,8,jira,https://issues.apache.org/jira/browse/COMPRESS-113,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,51,107,"/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}"
470,Compress,9,jira,https://issues.apache.org/jira/browse/COMPRESS-160,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,108,112,"@Deprecated
@Override
public int getCount() {
    return (int) getBytesWritten();
}"
471,Compress,9,jira,https://issues.apache.org/jira/browse/COMPRESS-160,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,114,117,"@Override
public long getBytesWritten() {
    return ((CountingOutputStream) out).getBytesWritten();
}"
472,Compress,9,jira,https://issues.apache.org/jira/browse/COMPRESS-160,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,275,339,"/**
 * Writes bytes to the current tar archive entry. This method
 * is aware of the current entry and will throw an exception if
 * you attempt to write bytes past the length specified for the
 * current entry. The method is also (painfully) aware of the
 * record buffering required by TarBuffer, and manages buffers
 * that are not a multiple of recordsize in length, including
 * assembling records from small buffers.
 *
 * @param wBuf The buffer to write to the archive.
 * @param wOffset The offset in the buffer from which to get bytes.
 * @param numToWrite The number of bytes to write.
 * @throws IOException on error
 */
@Override
public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
    if ((currBytes + numToWrite) > currSize) {
        throw new IOException(""request to write '"" + numToWrite + ""' bytes exceeds size in header of '"" + currSize + ""' bytes for entry '"" + currName + ""'"");
    // 
    // We have to deal with assembly!!!
    // The programmer can be writing little 32 byte chunks for all
    // we know, and we must assemble complete records for writing.
    // REVIEW Maybe this should be in TarBuffer? Could that help to
    // eliminate some of the buffer copying.
    // 
    }
    if (assemLen > 0) {
        if ((assemLen + numToWrite) >= recordBuf.length) {
            int aLen = recordBuf.length - assemLen;
            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);
            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);
            buffer.writeRecord(recordBuf);
            currBytes += recordBuf.length;
            wOffset += aLen;
            numToWrite -= aLen;
            assemLen = 0;
        } else {
            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);
            wOffset += numToWrite;
            assemLen += numToWrite;
            numToWrite = 0;
        }
    }
    // 
    while (numToWrite > 0) {
        if (numToWrite < recordBuf.length) {
            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);
            assemLen += numToWrite;
            break;
        }
        buffer.writeRecord(wBuf, wOffset);
        int num = recordBuf.length;
        currBytes += num;
        numToWrite -= num;
        wOffset += num;
    }
}"
473,Compress,10,jira,https://issues.apache.org/jira/browse/COMPRESS-164,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java,801,847,"/**
 * Walks through all recorded entries and adds the data available
 * from the local file header.
 *
 * <p>Also records the offsets for the data to read from the
 * entries.</p>
 */
private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {
    // changing the name of a ZipArchiveEntry is going to change
    // the hashcode - see COMPRESS-164
    // Map needs to be reconstructed in order to keep central
    // directory order
    Map<ZipArchiveEntry, OffsetEntry> origMap = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);
    entries.clear();
    for (ZipArchiveEntry ze : origMap.keySet()) {
        OffsetEntry offsetEntry = origMap.get(ze);
        long offset = offsetEntry.headerOffset;
        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
        byte[] b = new byte[SHORT];
        archive.readFully(b);
        int fileNameLen = ZipShort.getValue(b);
        archive.readFully(b);
        int extraFieldLen = ZipShort.getValue(b);
        int lenToSkip = fileNameLen;
        while (lenToSkip > 0) {
            int skipped = archive.skipBytes(lenToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip file name in"" + "" local file header"");
            }
            lenToSkip -= skipped;
        }
        byte[] localExtraData = new byte[extraFieldLen];
        archive.readFully(localExtraData);
        ze.setExtra(localExtraData);
        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen;
        if (entriesWithoutUTF8Flag.containsKey(ze)) {
            String orig = ze.getName();
            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);
            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);
            if (!orig.equals(ze.getName())) {
                nameMap.remove(orig);
                nameMap.put(ze.getName(), ze);
            }
        }
        entries.put(ze, offsetEntry);
    }
}"
474,Compress,11,jira,https://issues.apache.org/jira/browse/COMPRESS-171,High,src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java,197,256,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = in.read(signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            return new ZipArchiveInputStream(in);
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            return new JarArchiveInputStream(in);
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            return new CpioArchiveInputStream(in);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = in.read(dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = in.read(tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in);
        }
        // COMPRESS-117 - improve auto-recognition
        if (signatureLength >= 512) {
            try {
                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                tais.getNextEntry();
                return new TarArchiveInputStream(in);
            } catch (Exception e) {
            // NOPMD
            // can generate IllegalArgumentException as well as IOException
            // autodetection, simply not a TAR
            // ignored
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}"
475,Compress,12,jira,https://issues.apache.org/jira/browse/COMPRESS-178,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java,172,244,"/**
 * Get the next entry in this tar archive. This will skip
 * over any remaining data in the current entry, if there
 * is one, and place the input stream at the header of the
 * next entry, and read the header and instantiate a new
 * TarEntry from the header bytes and return that entry.
 * If there are no more entries in the archive, null will
 * be returned to indicate that the end of the archive has
 * been reached.
 *
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */
public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }
    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;
        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip current tar entry"");
            }
            numToSkip -= skipped;
        }
        readBuf = null;
    }
    byte[] headerBuf = getRecord();
    if (hasHitEOF) {
        currEntry = null;
        return null;
    }
    try {
        currEntry = new TarArchiveEntry(headerBuf);
    } catch (IllegalArgumentException e) {
        IOException ioe = new IOException(""Error detected parsing the header"");
        ioe.initCause(e);
        throw ioe;
    }
    entryOffset = 0;
    entrySize = currEntry.getSize();
    if (currEntry.isGNULongNameEntry()) {
        // read in the name
        StringBuffer longName = new StringBuffer();
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length = 0;
        while ((length = read(buf)) >= 0) {
            longName.append(new String(buf, 0, length));
        }
        getNextEntry();
        if (currEntry == null) {
            // Malformed tar file - long entry name not followed by entry
            return null;
        }
        // remove trailing null terminator
        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }
    if (currEntry.isPaxHeader()) {
        // Process Pax headers
        paxHeaders();
    }
    if (currEntry.isGNUSparse()) {
        // Process sparse files
        readGNUSparse();
    }
    // If the size of the next element in the archive has changed
    // due to a new size being reported in the posix header
    // information, we update entrySize here so that it contains
    // the correct value.
    entrySize = currEntry.getSize();
    return currEntry;
}"
476,Compress,13,jira,https://issues.apache.org/jira/browse/COMPRESS-176,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java,511,517,"/**
 * Set the name of the entry.
 * @param name the name to use
 */
protected void setName(String name) {
    if (name != null && getPlatform() == PLATFORM_FAT && name.indexOf(""/"") == -1) {
        name = name.replace('\\', '/');
    }
    this.name = name;
}"
477,Compress,14,jira,https://issues.apache.org/jira/browse/COMPRESS-181,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,56,105,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}"
478,Compress,15,jira,https://issues.apache.org/jira/browse/COMPRESS-187,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java,648,688,"/* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    String myName = getName();
    String otherName = other.getName();
    if (myName == null) {
        if (otherName != null) {
            return false;
        }
    } else if (!myName.equals(otherName)) {
        return false;
    }
    String myComment = getComment();
    String otherComment = other.getComment();
    if (myComment == null) {
        myComment = """";
    }
    if (otherComment == null) {
        otherComment = """";
    }
    return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb);
}"
479,Compress,16,jira,https://issues.apache.org/jira/browse/COMPRESS-191,Low,src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java,197,259,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = in.read(signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            return new ZipArchiveInputStream(in);
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            return new JarArchiveInputStream(in);
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            return new CpioArchiveInputStream(in);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = in.read(dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = in.read(tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in);
        }
        // COMPRESS-117 - improve auto-recognition
        if (signatureLength >= 512) {
            try {
                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                // COMPRESS-191 - verify the header checksum
                if (tais.getNextTarEntry().isCheckSumOK()) {
                    return new TarArchiveInputStream(in);
                }
            } catch (Exception e) {
            // NOPMD
            // can generate IllegalArgumentException as well
            // as IOException
            // autodetection, simply not a TAR
            // ignored
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}"
480,Compress,17,jira,https://issues.apache.org/jira/browse/COMPRESS-197,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,102,152,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NULs or spaces
    trailer = buffer[end - 1];
    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}"
481,Compress,18,jira,https://issues.apache.org/jira/browse/COMPRESS-203,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,454,494,"/**
 * Writes a PAX extended header with the given map as contents.
 * @since 1.4
 */
void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException {
    String name = ""./PaxHeaders.X/"" + stripTo7Bits(entryName);
    while (name.endsWith(""/"")) {
        // TarEntry's constructor would think this is a directory
        // and not allow any data to be written
        name = name.substring(0, name.length() - 1);
    }
    if (name.length() >= TarConstants.NAMELEN) {
        name = name.substring(0, TarConstants.NAMELEN - 1);
    }
    TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);
    StringWriter w = new StringWriter();
    for (Map.Entry<String, String> h : headers.entrySet()) {
        String key = h.getKey();
        String value = h.getValue();
        int len = key.length() + value.length() + 3 + /* blank, equals and newline */
        2;
        String line = len + "" "" + key + ""="" + value + ""\n"";
        int actualLength = line.getBytes(CharsetNames.UTF_8).length;
        while (len != actualLength) {
            // Adjust for cases where length < 10 or > 100
            // or where UTF-8 encoding isn't a single octet
            // per character.
            // Must be in loop as size may go from 99 to 100 in
            // first pass so we'd need a second.
            len = actualLength;
            line = len + "" "" + key + ""="" + value + ""\n"";
            actualLength = line.getBytes(CharsetNames.UTF_8).length;
        }
        w.write(line);
    }
    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);
    pex.setSize(data.length);
    putArchiveEntry(pex);
    write(data);
    closeArchiveEntry();
}"
482,Compress,19,jira,https://issues.apache.org/jira/browse/COMPRESS-228,High,src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java,249,287,"/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */
public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length < expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}"
483,Compress,20,jira,https://issues.apache.org/jira/browse/COMPRESS-236,High,src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java,320,353,"private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {
    CpioArchiveEntry ret;
    if (hasCrc) {
        ret = new CpioArchiveEntry(FORMAT_NEW_CRC);
    } else {
        ret = new CpioArchiveEntry(FORMAT_NEW);
    }
    ret.setInode(readAsciiLong(8, 16));
    long mode = readAsciiLong(8, 16);
    if (CpioUtil.fileType(mode) != 0) {
        // mode is initialised to 0
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(8, 16));
    ret.setGID(readAsciiLong(8, 16));
    ret.setNumberOfLinks(readAsciiLong(8, 16));
    ret.setTime(readAsciiLong(8, 16));
    ret.setSize(readAsciiLong(8, 16));
    ret.setDeviceMaj(readAsciiLong(8, 16));
    ret.setDeviceMin(readAsciiLong(8, 16));
    ret.setRemoteDeviceMaj(readAsciiLong(8, 16));
    ret.setRemoteDeviceMin(readAsciiLong(8, 16));
    long namesize = readAsciiLong(8, 16);
    ret.setChksum(readAsciiLong(8, 16));
    String name = readCString((int) namesize);
    ret.setName(name);
    if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry name: "" + name + "" Occured at byte: "" + getBytesRead());
    }
    skip(ret.getHeaderPadCount());
    return ret;
}"
484,Compress,20,jira,https://issues.apache.org/jira/browse/COMPRESS-236,High,src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java,355,378,"private CpioArchiveEntry readOldAsciiEntry() throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);
    ret.setDevice(readAsciiLong(6, 8));
    ret.setInode(readAsciiLong(6, 8));
    final long mode = readAsciiLong(6, 8);
    if (CpioUtil.fileType(mode) != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(6, 8));
    ret.setGID(readAsciiLong(6, 8));
    ret.setNumberOfLinks(readAsciiLong(6, 8));
    ret.setRemoteDevice(readAsciiLong(6, 8));
    ret.setTime(readAsciiLong(11, 8));
    long namesize = readAsciiLong(6, 8);
    ret.setSize(readAsciiLong(11, 8));
    final String name = readCString((int) namesize);
    ret.setName(name);
    if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + "" Occured at byte: "" + getBytesRead());
    }
    return ret;
}"
485,Compress,20,jira,https://issues.apache.org/jira/browse/COMPRESS-236,High,src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java,380,405,"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);
    ret.setDevice(readBinaryLong(2, swapHalfWord));
    ret.setInode(readBinaryLong(2, swapHalfWord));
    final long mode = readBinaryLong(2, swapHalfWord);
    if (CpioUtil.fileType(mode) != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readBinaryLong(2, swapHalfWord));
    ret.setGID(readBinaryLong(2, swapHalfWord));
    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));
    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));
    ret.setTime(readBinaryLong(4, swapHalfWord));
    long namesize = readBinaryLong(2, swapHalfWord);
    ret.setSize(readBinaryLong(4, swapHalfWord));
    final String name = readCString((int) namesize);
    ret.setName(name);
    if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + ""Occured at byte: "" + getBytesRead());
    }
    skip(ret.getHeaderPadCount());
    return ret;
}"
486,Compress,21,jira,https://issues.apache.org/jira/browse/COMPRESS-252,Critical,src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java,634,648,"private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {
    int cache = 0;
    int shift = 7;
    for (int i = 0; i < length; i++) {
        cache |= ((bits.get(i) ? 1 : 0) << shift);
        if (--shift < 0) {
            header.write(cache);
            shift = 7;
            cache = 0;
        }
    }
    if (shift != 7) {
        header.write(cache);
    }
}"
487,Compress,22,jira,https://issues.apache.org/jira/browse/COMPRESS-253,Low,src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,196,225,"private int read0() throws IOException {
    switch(currentState) {
        case EOF:
            return -1;
        case START_BLOCK_STATE:
            return setupBlock();
        case RAND_PART_A_STATE:
            throw new IllegalStateException();
        case RAND_PART_B_STATE:
            return setupRandPartB();
        case RAND_PART_C_STATE:
            return setupRandPartC();
        case NO_RAND_PART_A_STATE:
            throw new IllegalStateException();
        case NO_RAND_PART_B_STATE:
            return setupNoRandPartB();
        case NO_RAND_PART_C_STATE:
            return setupNoRandPartC();
        default:
            throw new IllegalStateException();
    }
}"
488,Compress,22,jira,https://issues.apache.org/jira/browse/COMPRESS-253,Low,src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,830,853,"private int setupRandPartA() throws IOException {
    if (this.su_i2 <= this.last) {
        this.su_chPrev = this.su_ch2;
        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
        this.su_tPos = this.data.tt[this.su_tPos];
        if (this.su_rNToGo == 0) {
            this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
            if (++this.su_rTPos == 512) {
                this.su_rTPos = 0;
            }
        } else {
            this.su_rNToGo--;
        }
        this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;
        this.su_i2++;
        this.currentState = RAND_PART_B_STATE;
        this.crc.updateCRC(su_ch2Shadow);
        return su_ch2Shadow;
    } else {
        endBlock();
        initBlock();
        return setupBlock();
    }
}"
489,Compress,22,jira,https://issues.apache.org/jira/browse/COMPRESS-253,Low,src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,855,871,"private int setupNoRandPartA() throws IOException {
    if (this.su_i2 <= this.last) {
        this.su_chPrev = this.su_ch2;
        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
        this.su_ch2 = su_ch2Shadow;
        this.su_tPos = this.data.tt[this.su_tPos];
        this.su_i2++;
        this.currentState = NO_RAND_PART_B_STATE;
        this.crc.updateCRC(su_ch2Shadow);
        return su_ch2Shadow;
    } else {
        this.currentState = NO_RAND_PART_A_STATE;
        endBlock();
        initBlock();
        return setupBlock();
    }
}"
490,Compress,22,jira,https://issues.apache.org/jira/browse/COMPRESS-253,Low,src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,901,912,"private int setupRandPartC() throws IOException {
    if (this.su_j2 < this.su_z) {
        this.crc.updateCRC(this.su_ch2);
        this.su_j2++;
        return this.su_ch2;
    } else {
        this.currentState = RAND_PART_A_STATE;
        this.su_i2++;
        this.su_count = 0;
        return setupRandPartA();
    }
}"
491,Compress,22,jira,https://issues.apache.org/jira/browse/COMPRESS-253,Low,src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,928,940,"private int setupNoRandPartC() throws IOException {
    if (this.su_j2 < this.su_z) {
        int su_ch2Shadow = this.su_ch2;
        this.crc.updateCRC(su_ch2Shadow);
        this.su_j2++;
        this.currentState = NO_RAND_PART_C_STATE;
        return su_ch2Shadow;
    } else {
        this.su_i2++;
        this.su_count = 0;
        return setupNoRandPartA();
    }
}"
492,Compress,23,jira,https://issues.apache.org/jira/browse/COMPRESS-256,Low,src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java,106,118,"@Override
InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {
    byte propsByte = coder.properties[0];
    long dictSize = coder.properties[1];
    for (int i = 1; i < 4; i++) {
        dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);
    }
    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
        throw new IOException(""Dictionary larger than 4GiB maximum size"");
    }
    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
}"
493,Compress,24,jira,https://issues.apache.org/jira/browse/COMPRESS-262,Critical,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,102,150,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}"
494,Compress,26,jira,https://issues.apache.org/jira/browse/COMPRESS-277,High,src/main/java/org/apache/commons/compress/utils/IOUtils.java,94,116,"/**
 * Skips the given number of bytes by repeatedly invoking skip on
 * the given input stream if necessary.
 *
 * <p>In a case where the stream's skip() method returns 0 before
 * the requested number of bytes has been skip this implementation
 * will fall back to using the read() method.</p>
 *
 * <p>This method will only skip less than the requested number of
 * bytes if the end of the input stream has been reached.</p>
 *
 * @param input stream to skip bytes in
 * @param numToSkip the number of bytes to skip
 * @return the number of bytes actually skipped
 * @throws IOException
 */
public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0) {
        long skipped = input.skip(numToSkip);
        if (skipped == 0) {
            break;
        }
        numToSkip -= skipped;
    }
    if (numToSkip > 0) {
        byte[] skipBuf = new byte[SKIP_BUF_SIZE];
        while (numToSkip > 0) {
            int read = readFully(input, skipBuf, 0, (int) Math.min(numToSkip, SKIP_BUF_SIZE));
            if (read < 1) {
                break;
            }
            numToSkip -= read;
        }
    }
    return available - numToSkip;
}"
495,Compress,27,jira,https://issues.apache.org/jira/browse/COMPRESS-278,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,102,146,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}"
496,Compress,28,jira,https://issues.apache.org/jira/browse/COMPRESS-279,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java,568,595,"/**
 * Reads bytes from the current tar archive entry.
 *
 * This method is aware of the boundaries of the current
 * entry in the archive and will deal with them as if they
 * were this stream's start and EOF.
 *
 * @param buf The buffer into which to place bytes read.
 * @param offset The offset at which to place bytes read.
 * @param numToRead The number of bytes to read.
 * @return The number of bytes read, or -1 at EOF.
 * @throws IOException on error
 */
@Override
public int read(byte[] buf, int offset, int numToRead) throws IOException {
    int totalRead = 0;
    if (hasHitEOF || entryOffset >= entrySize) {
        return -1;
    }
    if (currEntry == null) {
        throw new IllegalStateException(""No current tar entry"");
    }
    numToRead = Math.min(numToRead, available());
    totalRead = is.read(buf, offset, numToRead);
    if (totalRead == -1) {
        if (numToRead > 0) {
            throw new IOException(""Truncated TAR archive"");
        }
        hasHitEOF = true;
    } else {
        count(totalRead);
        entryOffset += totalRead;
    }
    return totalRead;
}"
497,Compress,29,jira,https://issues.apache.org/jira/browse/COMPRESS-306,High,src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java,269,314,"/**
 * Create an archive output stream from an archiver name and an output stream.
 *
 * @param archiverName the archive name,
 * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO}
 * @param out the output stream
 * @return the archive output stream
 * @throws ArchiveException if the archiver name is not known
 * @throws StreamingNotSupportedException if the format cannot be
 * written to a stream
 * @throws IllegalArgumentException if the archiver name or stream is null
 */
public ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out) throws ArchiveException {
    if (archiverName == null) {
        throw new IllegalArgumentException(""Archivername must not be null."");
    }
    if (out == null) {
        throw new IllegalArgumentException(""OutputStream must not be null."");
    }
    if (AR.equalsIgnoreCase(archiverName)) {
        return new ArArchiveOutputStream(out);
    }
    if (ZIP.equalsIgnoreCase(archiverName)) {
        ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
        if (entryEncoding != null) {
            zip.setEncoding(entryEncoding);
        }
        return zip;
    }
    if (TAR.equalsIgnoreCase(archiverName)) {
        if (entryEncoding != null) {
            return new TarArchiveOutputStream(out, entryEncoding);
        } else {
            return new TarArchiveOutputStream(out);
        }
    }
    if (JAR.equalsIgnoreCase(archiverName)) {
        if (entryEncoding != null) {
            return new JarArchiveOutputStream(out, entryEncoding);
        } else {
            return new JarArchiveOutputStream(out);
        }
    }
    if (CPIO.equalsIgnoreCase(archiverName)) {
        if (entryEncoding != null) {
            return new CpioArchiveOutputStream(out, entryEncoding);
        } else {
            return new CpioArchiveOutputStream(out);
        }
    }
    if (SEVEN_Z.equalsIgnoreCase(archiverName)) {
        throw new StreamingNotSupportedException(SEVEN_Z);
    }
    throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
}"
498,Compress,29,jira,https://issues.apache.org/jira/browse/COMPRESS-306,High,src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java,328,413,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws StreamingNotSupportedException if the format cannot be
 * read from a stream
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = IOUtils.readFully(in, signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new ZipArchiveInputStream(in, entryEncoding);
            } else {
                return new ZipArchiveInputStream(in);
            }
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new JarArchiveInputStream(in, entryEncoding);
            } else {
                return new JarArchiveInputStream(in);
            }
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new CpioArchiveInputStream(in, entryEncoding);
            } else {
                return new CpioArchiveInputStream(in);
            }
        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new ArjArchiveInputStream(in, entryEncoding);
            } else {
                return new ArjArchiveInputStream(in);
            }
        } else if (SevenZFile.matches(signature, signatureLength)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = IOUtils.readFully(in, dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in, entryEncoding);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = IOUtils.readFully(in, tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in, entryEncoding);
        }
        // COMPRESS-117 - improve auto-recognition
        if (signatureLength >= 512) {
            TarArchiveInputStream tais = null;
            try {
                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                // COMPRESS-191 - verify the header checksum
                if (tais.getNextTarEntry().isCheckSumOK()) {
                    return new TarArchiveInputStream(in, encoding);
                }
            } catch (Exception e) {
            // NOPMD
            // can generate IllegalArgumentException as well
            // as IOException
            // autodetection, simply not a TAR
            // ignored
            } finally {
                IOUtils.closeQuietly(tais);
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}"
499,Compress,30,jira,https://issues.apache.org/jira/browse/COMPRESS-309,High,src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,152,182,"/*
     * (non-Javadoc)
     * 
     * @see java.io.InputStream#read(byte[], int, int)
     */
@Override
public int read(final byte[] dest, final int offs, final int len) throws IOException {
    if (offs < 0) {
        throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
    }
    if (len < 0) {
        throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
    }
    if (offs + len > dest.length) {
        throw new IndexOutOfBoundsException(""offs("" + offs + "") + len("" + len + "") > dest.length("" + dest.length + "")."");
    }
    if (this.in == null) {
        throw new IOException(""stream closed"");
    }
    if (len == 0) {
        return 0;
    }
    final int hi = offs + len;
    int destOffs = offs;
    int b;
    while (destOffs < hi && ((b = read0()) >= 0)) {
        dest[destOffs++] = (byte) b;
        count(1);
    }
    int c = (destOffs == offs) ? -1 : (destOffs - offs);
    return c;
}"
500,Compress,31,jira,https://issues.apache.org/jira/browse/COMPRESS-301,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,101,145,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}"
501,Compress,32,jira,https://issues.apache.org/jira/browse/COMPRESS-314,Low,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java,481,518,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
    /*
         * The following headers are defined for Pax.
         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields
         * mtime
         * comment
         * gid, gname
         * linkpath
         * size
         * uid,uname
         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those
         */
    for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        if (""path"".equals(key)) {
            currEntry.setName(val);
        } else if (""linkpath"".equals(key)) {
            currEntry.setLinkName(val);
        } else if (""gid"".equals(key)) {
            currEntry.setGroupId(Long.parseLong(val));
        } else if (""gname"".equals(key)) {
            currEntry.setGroupName(val);
        } else if (""uid"".equals(key)) {
            currEntry.setUserId(Long.parseLong(val));
        } else if (""uname"".equals(key)) {
            currEntry.setUserName(val);
        } else if (""size"".equals(key)) {
            currEntry.setSize(Long.parseLong(val));
        } else if (""mtime"".equals(key)) {
            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
        } else if (""SCHILY.devminor"".equals(key)) {
            currEntry.setDevMinor(Integer.parseInt(val));
        } else if (""SCHILY.devmajor"".equals(key)) {
            currEntry.setDevMajor(Integer.parseInt(val));
        }
    }
}"
502,Compress,33,jira,https://issues.apache.org/jira/browse/COMPRESS-316,High,src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java,204,259,"/**
 * Create an compressor input stream from an input stream, autodetecting
 * the compressor type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the compressor input stream
 * @throws CompressorException if the compressor name is not known
 * @throws IllegalArgumentException if the stream is null or does not support mark
 * @since 1.1
 */
public CompressorInputStream createCompressorInputStream(final InputStream in) throws CompressorException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = IOUtils.readFully(in, signature);
        in.reset();
        if (BZip2CompressorInputStream.matches(signature, signatureLength)) {
            return new BZip2CompressorInputStream(in, decompressConcatenated);
        }
        if (GzipCompressorInputStream.matches(signature, signatureLength)) {
            return new GzipCompressorInputStream(in, decompressConcatenated);
        }
        if (Pack200CompressorInputStream.matches(signature, signatureLength)) {
            return new Pack200CompressorInputStream(in);
        }
        if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {
            return new FramedSnappyCompressorInputStream(in);
        }
        if (ZCompressorInputStream.matches(signature, signatureLength)) {
            return new ZCompressorInputStream(in);
        }
        if (DeflateCompressorInputStream.matches(signature, signatureLength)) {
            return new DeflateCompressorInputStream(in);
        }
        if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {
            return new XZCompressorInputStream(in, decompressConcatenated);
        }
        if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {
            return new LZMACompressorInputStream(in);
        }
    } catch (IOException e) {
        throw new CompressorException(""Failed to detect Compressor from InputStream."", e);
    }
    throw new CompressorException(""No Compressor found for the stream signature."");
}"
503,Compress,33,jira,https://issues.apache.org/jira/browse/COMPRESS-316,High,src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java,111,117,"/**
 * Checks if the signature matches what is expected for a zlib / deflated file
 *  with the zlib header.
 *
 * @param signature
 *            the bytes to check
 * @param length
 *            the number of bytes to check
 * @return true, if this stream is zlib / deflate compressed with a header
 * stream, false otherwise
 *
 * @since 1.9
 */
public static boolean matches(byte[] signature, int length) {
    return length > 3 && signature[0] == MAGIC_1 && (signature[1] == (byte) MAGIC_2a || signature[1] == (byte) MAGIC_2b || signature[1] == (byte) MAGIC_2c || signature[1] == (byte) MAGIC_2d);
}"
504,Compress,34,jira,https://issues.apache.org/jira/browse/COMPRESS-321,High,src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java,146,148,"/**
 * Length of the extra field in the central directory data - without
 * Header-ID or length specifier.
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */
public ZipShort getCentralDirectoryLength() {
    return ZERO;
}"
505,Compress,35,jira,https://issues.apache.org/jira/browse/COMPRESS-335,High,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,593,608,"/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */
public static boolean verifyCheckSum(byte[] header) {
    long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum;
}"
506,Compress,36,jira,https://issues.apache.org/jira/browse/COMPRESS-348,Low,src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java,901,919,"private InputStream getCurrentStream() throws IOException {
    if (archive.files[currentEntryIndex].getSize() == 0) {
        return new ByteArrayInputStream(new byte[0]);
    }
    if (deferredBlockStreams.isEmpty()) {
        throw new IllegalStateException(""No current 7z entry (call getNextEntry() first)."");
    }
    while (deferredBlockStreams.size() > 1) {
        // In solid compression mode we need to decompress all leading folder'
        // streams to get access to an entry. We defer this until really needed
        // so that entire blocks can be skipped without wasting time for decompression.
        final InputStream stream = deferredBlockStreams.remove(0);
        IOUtils.skip(stream, Long.MAX_VALUE);
        stream.close();
    }
    return deferredBlockStreams.get(0);
}"
507,Compress,37,jira,https://issues.apache.org/jira/browse/COMPRESS-355,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java,452,504,"// NOTE, using a Map here makes it impossible to ever support GNU
// sparse files using the PAX Format 0.0, see
// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188
Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {
    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
    // Format is ""length keyword=value\n"";
    while (true) {
        // get length
        int ch;
        int len = 0;
        int read = 0;
        while ((ch = i.read()) != -1) {
            read++;
            if (ch == '\n') {
                // blank line in header
                break;
            } else if (ch == ' ') {
                // End of length string
                // Get keyword
                final ByteArrayOutputStream coll = new ByteArrayOutputStream();
                while ((ch = i.read()) != -1) {
                    read++;
                    if (ch == '=') {
                        // end of keyword
                        final String keyword = coll.toString(CharsetNames.UTF_8);
                        // Get rest of entry
                        final int restLen = len - read;
                        if (restLen == 1) {
                            // only NL
                            headers.remove(keyword);
                        } else {
                            final byte[] rest = new byte[restLen];
                            final int got = IOUtils.readFully(i, rest);
                            if (got != restLen) {
                                throw new IOException(""Failed to read "" + ""Paxheader. Expected "" + restLen + "" bytes, read "" + got);
                            }
                            // Drop trailing NL
                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);
                            headers.put(keyword, value);
                        }
                        break;
                    }
                    coll.write((byte) ch);
                }
                // Processed single header
                break;
            }
            len *= 10;
            len += ch - '0';
        }
        if (ch == -1) {
            // EOF
            break;
        }
    }
    return headers;
}"
508,Compress,38,jira,https://issues.apache.org/jira/browse/COMPRESS-356,High,src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java,849,864,"/**
 * Return whether or not this entry represents a directory.
 *
 * @return True if this entry is a directory.
 */
@Override
public boolean isDirectory() {
    if (file != null) {
        return file.isDirectory();
    }
    if (linkFlag == LF_DIR) {
        return true;
    }
    if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(""/"")) {
        return true;
    }
    return false;
}"
509,Compress,39,jira,https://issues.apache.org/jira/browse/COMPRESS-351,High,src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java,273,295,"/**
 * Returns a ""sanitized"" version of the string given as arguments,
 * where sanitized means non-printable characters have been
 * replaced with a question mark and the outcome is not longer
 * than 255 chars.
 *
 * <p>This method is used to clean up file names when they are
 * used in exception messages as they may end up in log files or
 * as console output and may have been read from a corrupted
 * input.</p>
 *
 * @param s the string to sanitize
 * @return a sanitized version of the argument
 * @since Compress 1.12
 */
public static String sanitize(String s) {
    final char[] cs = s.toCharArray();
    final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH);
    if (cs.length > MAX_SANITIZED_NAME_LENGTH) {
        for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) {
            chars[i] = '.';
        }
    }
    final int len = chars.length;
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < len; i++) {
        final char c = chars[i];
        if (!Character.isISOControl(c)) {
            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
            if (block != null && block != Character.UnicodeBlock.SPECIALS) {
                sb.append(c);
                continue;
            }
        }
        sb.append('?');
    }
    return sb.toString();
}"
510,Compress,40,jira,https://issues.apache.org/jira/browse/COMPRESS-363,High,src/main/java/org/apache/commons/compress/utils/BitInputStream.java,81,136,"/**
 * Returns at most 63 bits read from the underlying stream.
 *
 * @param count the number of bits to read, must be a positive
 * number not bigger than 63.
 * @return the bits concatenated as a long using the stream's byte order.
 *         -1 if the end of the underlying stream has been reached before reading
 *         the requested number of bits
 * @throws IOException on error
 */
public long readBits(final int count) throws IOException {
    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
        throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
    }
    while (bitsCachedSize < count && bitsCachedSize < 57) {
        final long nextByte = in.read();
        if (nextByte < 0) {
            return nextByte;
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsCached |= (nextByte << bitsCachedSize);
        } else {
            bitsCached <<= 8;
            bitsCached |= nextByte;
        }
        bitsCachedSize += 8;
    }
    int overflowBits = 0;
    long overflow = 0l;
    if (bitsCachedSize < count) {
        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
        int bitsToAddCount = count - bitsCachedSize;
        overflowBits = 8 - bitsToAddCount;
        final long nextByte = in.read();
        if (nextByte < 0) {
            return nextByte;
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            long bitsToAdd = nextByte & MASKS[bitsToAddCount];
            bitsCached |= (bitsToAdd << bitsCachedSize);
            overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];
        } else {
            bitsCached <<= bitsToAddCount;
            long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];
            bitsCached |= bitsToAdd;
            overflow = nextByte & MASKS[overflowBits];
        }
        bitsCachedSize = count;
    }
    final long bitsOut;
    if (overflowBits == 0) {
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsOut = (bitsCached & MASKS[count]);
            bitsCached >>>= count;
        } else {
            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
        }
        bitsCachedSize -= count;
    } else {
        bitsOut = bitsCached & MASKS[count];
        bitsCached = overflow;
        bitsCachedSize = overflowBits;
    }
    return bitsOut;
}"
511,Compress,41,jira,https://issues.apache.org/jira/browse/COMPRESS-367,Low,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,219,325,"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        throw new ZipException(String.format(""Unexpected record signature: 0X%X"", sig.getValue()));
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;
        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;
        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        }
    }
    entriesRead++;
    return current.entry;
}"
512,Compress,42,jira,https://issues.apache.org/jira/browse/COMPRESS-379,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java,296,298,"/**
 * Returns true if this entry represents a unix symlink,
 * in which case the entry's content contains the target path
 * for the symlink.
 *
 * @since 1.5
 * @return true if the entry represents a unix symlink, false otherwise.
 */
public boolean isUnixSymlink() {
    return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;
}"
513,Compress,43,jira,https://issues.apache.org/jira/browse/COMPRESS-394,Low,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,1024,1038,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
    final boolean encodable = zipEncoding.canEncode(ze.getName());
    final ByteBuffer name = getName(ze);
    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
        addUnicodeExtraFields(ze, encodable, name);
    }
    final long localHeaderStart = streamCompressor.getTotalBytesWritten();
    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));
    // At crc offset
    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;
    writeCounted(localHeader);
    entry.dataStart = streamCompressor.getTotalBytesWritten();
}"
514,Compress,43,jira,https://issues.apache.org/jira/browse/COMPRESS-394,Low,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,1041,1127,"private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {
    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);
    if (oldAlignmentEx != null) {
        ze.removeExtraField(ResourceAlignmentExtraField.ID);
    }
    int alignment = ze.getAlignment();
    if (alignment <= 0 && oldAlignmentEx != null) {
        alignment = oldAlignmentEx.getAlignment();
    }
    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {
        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;
        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));
        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));
    }
    final byte[] extra = ze.getLocalFileDataExtra();
    final int nameLen = name.limit() - name.position();
    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;
    final byte[] buf = new byte[len];
    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);
    // store method in local variable to prevent multiple method calls
    final int zipMethod = ze.getMethod();
    final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);
    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);
    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);
    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);
    // compression method
    putShort(zipMethod, buf, LFH_METHOD_OFFSET);
    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);
    // CRC
    if (phased) {
        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
    } else if (zipMethod == DEFLATED || channel != null) {
        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);
    } else {
        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
    }
    // uncompressed length
    if (hasZip64Extra(entry.entry)) {
        // point to ZIP64 extended information extra field for
        // sizes, may get rewritten once sizes are known if
        // stream is seekable
        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);
        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);
    } else if (phased) {
        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
    } else if (zipMethod == DEFLATED || channel != null) {
        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);
        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);
    } else {
        // Stored
        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
    }
    // file name length
    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);
    // extra field length
    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);
    // file name
    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);
    // extra fields
    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);
    return buf;
}"
515,Compress,43,jira,https://issues.apache.org/jira/browse/COMPRESS-394,Low,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,1170,1183,"/**
 * Writes the data descriptor entry.
 * @param ze the entry to write
 * @throws IOException on error
 */
protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {
    if (!usesDataDescriptor(ze.getMethod(), false)) {
        return;
    }
    writeCounted(DD_SIG);
    writeCounted(ZipLong.getBytes(ze.getCrc()));
    if (!hasZip64Extra(ze)) {
        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));
        writeCounted(ZipLong.getBytes(ze.getSize()));
    } else {
        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));
        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));
    }
}"
516,Compress,43,jira,https://issues.apache.org/jira/browse/COMPRESS-394,Low,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,1492,1494,"private boolean usesDataDescriptor(final int zipMethod, boolean phased) {
    return !phased && zipMethod == DEFLATED && channel == null;
}"
517,Compress,45,jira,https://issues.apache.org/jira/browse/COMPRESS-411,Low,src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java,474,493,"/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */
public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    } else {
        formatBigIntegerBinary(value, buf, offset, length, negative);
    }
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}"
518,Compress,46,jira,https://issues.apache.org/jira/browse/COMPRESS-416,High,src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java,528,533,"private static ZipLong unixTimeToZipLong(long l) {
    if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""X5455 timestamps must fit in a signed 32 bit integer: "" + l);
    }
    return new ZipLong(l);
}"
519,Compress,47,jira,https://issues.apache.org/jira/browse/COMPRESS-436,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,410,419,"/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */
@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze);
    }
    return false;
}"
520,Compress,47,jira,https://issues.apache.org/jira/browse/COMPRESS-436,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,421,466,"@Override
public int read(final byte[] buffer, final int offset, final int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
    }
    if (!supportsCompressedSizeFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);
    }
    int read;
    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
        read = readStored(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
        read = readDeflated(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
        read = current.in.read(buffer, offset, length);
    } else {
        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
    }
    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }
    return read;
}"
521,Compress,47,jira,https://issues.apache.org/jira/browse/COMPRESS-436,High,src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,814,821,"/**
 * Whether the compressed size for the entry is either known or
 * not required by the compression method being used.
 */
private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {
    return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED);
}"
522,Csv,1,jira,https://issues.apache.org/jira/browse/CSV-75,High,src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java,55,63,"@Override
public int read() throws IOException {
    int current = super.read();
    if (current == '\r' || (current == '\n' && lastChar != '\r')) {
        lineCounter++;
    }
    lastChar = current;
    return lastChar;
}"
523,Csv,2,jira,https://issues.apache.org/jira/browse/CSV-96,High,src/main/java/org/apache/commons/csv/CSVRecord.java,79,93,"/**
 * Returns a value by name.
 *
 * @param name
 *            the name of the column to be retrieved.
 * @return the column value, or {@code null} if the column name is not found
 * @throws IllegalStateException
 *             if no header mapping was provided
 * @throws IllegalArgumentException
 *             if the record is inconsistent
 * @see #isConsistent()
 */
public String get(final String name) {
    if (mapping == null) {
        throw new IllegalStateException(""No header mapping was specified, the record values can't be accessed by name"");
    }
    final Integer index = mapping.get(name);
    try {
        return index != null ? values[index.intValue()] : null;
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new IllegalArgumentException(String.format(""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index.intValue(), values.length));
    }
}"
524,Csv,3,jira,https://issues.apache.org/jira/browse/CSV-58,High,src/main/java/org/apache/commons/csv/Lexer.java,87,117,"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {
                return c;
            }
            // indicate unexpected char - available from in.getLastChar()
            return END_OF_STREAM;
    }
}"
525,Csv,4,jira,https://issues.apache.org/jira/browse/CSV-100,High,src/main/java/org/apache/commons/csv/CSVParser.java,287,289,"/**
 * Returns a copy of the header map that iterates in column order.
 * <p>
 * The map keys are column names. The map values are 0-based indices.
 * </p>
 * @return a copy of the header map that iterates in column order.
 */
public Map<String, Integer> getHeaderMap() {
    return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);
}"
526,Csv,5,jira,https://issues.apache.org/jira/browse/CSV-106,High,src/main/java/org/apache/commons/csv/CSVPrinter.java,323,329,"/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    if (recordSeparator != null) {
        out.append(recordSeparator);
    }
    newRecord = true;
}"
527,Csv,6,jira,https://issues.apache.org/jira/browse/CSV-111,High,src/main/java/org/apache/commons/csv/CSVRecord.java,179,187,"/**
 * Puts all values of this record into the given Map.
 *
 * @param map The Map to populate.
 * @return the given map.
 */
<M extends Map<String, String>> M putIn(final M map) {
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue().intValue();
        if (col < values.length) {
            map.put(entry.getKey(), values[col]);
        }
    }
    return map;
}"
528,Csv,7,jira,https://issues.apache.org/jira/browse/CSV-112,High,src/main/java/org/apache/commons/csv/CSVParser.java,349,380,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] header = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                header = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            header = formatHeader;
        }
        // build the name to index mappings
        if (header != null) {
            for (int i = 0; i < header.length; i++) {
                if (hdrMap.containsKey(header[i])) {
                    throw new IllegalStateException(""The header contains duplicate names: "" + Arrays.toString(header));
                }
                hdrMap.put(header[i], Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}"
529,Csv,8,jira,https://issues.apache.org/jira/browse/CSV-114,High,src/main/java/org/apache/commons/csv/CSVFormat.java,641,671,"/**
 * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.
 *
 * @throws IllegalStateException
 */
void validate() throws IllegalStateException {
    if (quoteChar != null && delimiter == quoteChar.charValue()) {
        throw new IllegalStateException(""The quoteChar character and the delimiter cannot be the same ('"" + quoteChar + ""')"");
    }
    if (escape != null && delimiter == escape.charValue()) {
        throw new IllegalStateException(""The escape character and the delimiter cannot be the same ('"" + escape + ""')"");
    }
    if (commentStart != null && delimiter == commentStart.charValue()) {
        throw new IllegalStateException(""The comment start character and the delimiter cannot be the same ('"" + commentStart + ""')"");
    }
    if (quoteChar != null && quoteChar.equals(commentStart)) {
        throw new IllegalStateException(""The comment start character and the quoteChar cannot be the same ('"" + commentStart + ""')"");
    }
    if (escape != null && escape.equals(commentStart)) {
        throw new IllegalStateException(""The comment start and the escape character cannot be the same ('"" + commentStart + ""')"");
    }
    if (escape == null && quotePolicy == Quote.NONE) {
        throw new IllegalStateException(""No quotes mode set but no escape character is set"");
    }
}"
530,Csv,9,jira,https://issues.apache.org/jira/browse/CSV-118,High,src/main/java/org/apache/commons/csv/CSVRecord.java,179,190,"/**
 * Puts all values of this record into the given Map.
 *
 * @param map The Map to populate.
 * @return the given map.
 */
<M extends Map<String, String>> M putIn(final M map) {
    if (mapping == null) {
        return map;
    }
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue().intValue();
        if (col < values.length) {
            map.put(entry.getKey(), values[col]);
        }
    }
    return map;
}"
531,Csv,11,jira,https://issues.apache.org/jira/browse/CSV-122,High,src/main/java/org/apache/commons/csv/CSVParser.java,359,394,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 * @throws IOException if there is a problem reading the header or skipping the first record
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }
        // build the name to index mappings
        if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean containsHeader = hdrMap.containsKey(header);
                final boolean emptyHeader = header == null || header.trim().isEmpty();
                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header + ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}"
532,Csv,13,jira,https://issues.apache.org/jira/browse/CSV-168,Low,src/main/java/org/apache/commons/csv/CSVPrinter.java,134,150,"private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {
    if (!newRecord) {
        out.append(format.getDelimiter());
    }
    if (object == null) {
        out.append(value);
    } else if (format.isQuoteCharacterSet()) {
        // the original object is needed so can check for Number
        printAndQuote(object, value, offset, len);
    } else if (format.isEscapeCharacterSet()) {
        printAndEscape(value, offset, len);
    } else {
        out.append(value, offset, offset + len);
    }
    newRecord = false;
}"
533,Csv,14,jira,https://issues.apache.org/jira/browse/CSV-171,Low,src/main/java/org/apache/commons/csv/CSVFormat.java,1001,1106,"/*
     * Note: must only be called if quoting is enabled, otherwise will generate NPE
     */
// the original object is needed so can check for Number
private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;
    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = value.charAt(pos);
                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {
                    quote = true;
                } else if (c <= COMMENT) {
                    // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
        // no encapsulation needed - write out the original value
        out.append(value, start, end);
        return;
    }
    // we hit something that needed encapsulation
    out.append(quoteChar);
    // the need for encapsulation.
    while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
            // write out the chunk up until this point
            // add 1 to the length to write out the encapsulator also
            out.append(value, start, pos + 1);
            // put the next starting position on the encapsulator so we will
            // write it out again with the next string (effectively doubling it)
            start = pos;
        }
        pos++;
    }
    // write the last segment
    out.append(value, start, pos);
    out.append(quoteChar);
}"
534,Csv,15,jira,https://issues.apache.org/jira/browse/CSV-219,High,src/main/java/org/apache/commons/csv/CSVFormat.java,1151,1254,"/*
     * Note: must only be called if quoting is enabled, otherwise will generate NPE
     */
// the original object is needed so can check for Number
private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;
    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
        case ALL_NON_NULL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = value.charAt(pos);
                if (c <= COMMENT) {
                    // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
        // no encapsulation needed - write out the original value
        out.append(value, start, end);
        return;
    }
    // we hit something that needed encapsulation
    out.append(quoteChar);
    // the need for encapsulation.
    while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
            // write out the chunk up until this point
            // add 1 to the length to write out the encapsulator also
            out.append(value, start, pos + 1);
            // put the next starting position on the encapsulator so we will
            // write it out again with the next string (effectively doubling it)
            start = pos;
        }
        pos++;
    }
    // write the last segment
    out.append(value, start, pos);
    out.append(quoteChar);
}"
535,Csv,16,jira,https://issues.apache.org/jira/browse/CSV-224,Low,src/main/java/org/apache/commons/csv/CSVParser.java,523,526,"/**
 * Returns an iterator on the records.
 *
 * <p>
 * An {@link IOException} caught during the iteration are re-thrown as an
 * {@link IllegalStateException}.
 * </p>
 * <p>
 * If the parser is closed a call to {@link Iterator#next()} will throw a
 * {@link NoSuchElementException}.
 * </p>
 */
@Override
public Iterator<CSVRecord> iterator() {
    return csvRecordIterator;
}"
536,JxPath,1,jira,https://issues.apache.org/jira/browse/JXPATH-12,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,87,136,"public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    } else if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
    } else if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    } else if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}"
537,JxPath,1,jira,https://issues.apache.org/jira/browse/JXPATH-12,High,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,343,395,"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    } else if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS);
        }
    } else if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return (node instanceof Element) || (node instanceof Document);
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
        }
        return false;
    } else if (test instanceof ProcessingInstructionTest) {
        if (node instanceof ProcessingInstruction) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}"
538,JxPath,2,jira,https://issues.apache.org/jira/browse/JXPATH-50,High,src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,73,82,"public Iterator iterate(EvalContext context) {
    Object result = compute(context);
    if (result instanceof EvalContext) {
        return new ValueIterator((EvalContext) result);
    }
    if (result instanceof NodeSet) {
        return new ValueIterator(((NodeSet) result).getPointers().iterator());
    }
    return ValueUtils.iterate(result);
}"
539,JxPath,2,jira,https://issues.apache.org/jira/browse/JXPATH-50,High,src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,84,100,"public Iterator iteratePointers(EvalContext context) {
    Object result = compute(context);
    if (result == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (result instanceof EvalContext) {
        return (EvalContext) result;
    }
    if (result instanceof NodeSet) {
        return new PointerIterator(((NodeSet) result).getPointers().iterator(), new QName(null, ""value""), context.getRootContext().getCurrentNodePointer().getLocale());
    }
    return new PointerIterator(ValueUtils.iterate(result), new QName(null, ""value""), context.getRootContext().getCurrentNodePointer().getLocale());
}"
540,JxPath,3,jira,https://issues.apache.org/jira/browse/JXPATH-68,High,src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,105,133,"public NodePointer createPath(JXPathContext context) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        return newParent.createAttribute(context, getName());
    } else {
        if (parent instanceof NullPointer && parent.equals(newParent)) {
            throw createBadFactoryException(context.getFactory());
        }
        // non-property pointer expand the collection by itself.
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), getIndex());
    }
}"
541,JxPath,3,jira,https://issues.apache.org/jira/browse/JXPATH-68,High,src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,135,152,"public NodePointer createPath(JXPathContext context, Object value) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        NodePointer pointer = newParent.createAttribute(context, getName());
        pointer.setValue(value);
        return pointer;
    } else {
        if (parent instanceof NullPointer && parent.equals(newParent)) {
            throw createBadFactoryException(context.getFactory());
        }
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), index, value);
    }
}"
542,JxPath,3,jira,https://issues.apache.org/jira/browse/JXPATH-68,High,src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,233,237,"private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) {
    return new JXPathAbstractFactoryException(""Factory "" + factory + "" reported success creating object for path: "" + asPath() + "" but object was null.  Terminating to avoid stack recursion."");
}"
543,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,296,308,"protected static String findEnclosingAttribute(Node n, String attrName) {
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            Element e = (Element) n;
            String attr = e.getAttribute(attrName);
            if (attr != null && !attr.equals("""")) {
                return attr;
            }
        }
        n = n.getParentNode();
    }
    return null;
}"
544,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,310,312,"protected String getLanguage() {
    return findEnclosingAttribute(node, ""xml:lang"");
}"
545,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,633,639,"public Object getValue() {
    if (node.getNodeType() == Node.COMMENT_NODE) {
        String text = ((Comment) node).getData();
        return text == null ? """" : text.trim();
    }
    return stringValue(node);
}"
546,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,641,662,"private String stringValue(Node node) {
    int nodeType = node.getNodeType();
    if (nodeType == Node.COMMENT_NODE) {
        return """";
    }
    boolean trim = !""preserve"".equals(findEnclosingAttribute(node, ""xml:space""));
    if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {
        String text = node.getNodeValue();
        return text == null ? """" : trim ? text.trim() : text;
    }
    if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
        String text = ((ProcessingInstruction) node).getData();
        return text == null ? """" : trim ? text.trim() : text;
    }
    NodeList list = node.getChildNodes();
    StringBuffer buf = new StringBuffer(16);
    for (int i = 0; i < list.getLength(); i++) {
        Node child = list.item(i);
        buf.append(stringValue(child));
    }
    return buf.toString();
}"
547,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,238,265,"public Object getValue() {
    if (node instanceof Element) {
        StringBuffer buf = new StringBuffer();
        for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1); ) {
            NodePointer ptr = children.getNodePointer();
            if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {
                buf.append(ptr.getValue());
            }
        }
        return buf.toString();
    }
    if (node instanceof Comment) {
        String text = ((Comment) node).getText();
        if (text != null) {
            text = text.trim();
        }
        return text;
    }
    String result = null;
    if (node instanceof Text) {
        result = ((Text) node).getText();
    }
    if (node instanceof ProcessingInstruction) {
        result = ((ProcessingInstruction) node).getData();
    }
    boolean trim = !""preserve"".equals(findEnclosingAttribute(node, ""space"", Namespace.XML_NAMESPACE));
    return result != null && trim ? result.trim() : result;
}"
548,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,437,439,"protected String getLanguage() {
    return findEnclosingAttribute(node, ""lang"", Namespace.XML_NAMESPACE);
}"
549,JxPath,4,jira,https://issues.apache.org/jira/browse/JXPATH-83,High,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,441,453,"protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {
    while (n != null) {
        if (n instanceof Element) {
            Element e = (Element) n;
            String attr = e.getAttributeValue(attrName, ns);
            if (attr != null && !attr.equals("""")) {
                return attr;
            }
        }
        n = nodeParent(n);
    }
    return null;
}"
550,JxPath,5,jira,https://issues.apache.org/jira/browse/JXPATH-89,High,src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,642,673,"private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) {
    if (depth1 < depth2) {
        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);
        return r == 0 ? -1 : r;
    }
    if (depth1 > depth2) {
        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);
        return r == 0 ? 1 : r;
    }
    if (p1 == null && p2 == null) {
        return 0;
    }
    if (p1 != null && p1.equals(p2)) {
        return 0;
    }
    if (depth1 == 1) {
        return 0;
    }
    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);
    if (r != 0) {
        return r;
    }
    return p1.parent.compareChildNodePointers(p1, p2);
}"
551,JxPath,6,jira,https://issues.apache.org/jira/browse/JXPATH-94,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java,45,91,"/**
 * Compares two values
 */
protected boolean equal(EvalContext context, Expression left, Expression right) {
    Object l = left.compute(context);
    Object r = right.compute(context);
    if (l instanceof InitialContext) {
        ((EvalContext) l).reset();
    }
    if (l instanceof SelfContext) {
        l = ((EvalContext) l).getSingleNodePointer();
    }
    if (r instanceof InitialContext) {
        ((EvalContext) r).reset();
    }
    if (r instanceof SelfContext) {
        r = ((EvalContext) r).getSingleNodePointer();
    }
    if (l instanceof Collection) {
        l = ((Collection) l).iterator();
    }
    if (r instanceof Collection) {
        r = ((Collection) r).iterator();
    }
    if ((l instanceof Iterator) && !(r instanceof Iterator)) {
        return contains((Iterator) l, r);
    }
    if (!(l instanceof Iterator) && (r instanceof Iterator)) {
        return contains((Iterator) r, l);
    }
    if (l instanceof Iterator && r instanceof Iterator) {
        return findMatch((Iterator) l, (Iterator) r);
    }
    return equal(l, r);
}"
552,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java,31,33,"protected boolean evaluateCompare(int compare) {
    return compare > 0;
}"
553,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java,32,34,"protected boolean evaluateCompare(int compare) {
    return compare >= 0;
}"
554,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java,31,33,"protected boolean evaluateCompare(int compare) {
    return compare < 0;
}"
555,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java,32,34,"protected boolean evaluateCompare(int compare) {
    return compare <= 0;
}"
556,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,40,43,"public final Object computeValue(EvalContext context) {
    return compute(args[0].computeValue(context), args[1].computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
}"
557,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,53,53,protected abstract boolean evaluateCompare(int compare);
558,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,55,75,"private boolean compute(Object left, Object right) {
    left = reduce(left);
    right = reduce(right);
    if (left instanceof InitialContext) {
        ((InitialContext) left).reset();
    }
    if (right instanceof InitialContext) {
        ((InitialContext) right).reset();
    }
    if (left instanceof Iterator && right instanceof Iterator) {
        return findMatch((Iterator) left, (Iterator) right);
    }
    if (left instanceof Iterator) {
        return containsMatch((Iterator) left, right);
    }
    if (right instanceof Iterator) {
        return containsMatch((Iterator) right, left);
    }
    return evaluateCompare(compare(left, right));
}"
559,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,77,85,"private Object reduce(Object o) {
    if (o instanceof SelfContext) {
        o = ((EvalContext) o).getSingleNodePointer();
    }
    if (o instanceof Collection) {
        o = ((Collection) o).iterator();
    }
    return o;
}"
560,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,87,95,"private boolean containsMatch(Iterator it, Object value) {
    while (it.hasNext()) {
        Object element = it.next();
        if (evaluateCompare(compare(element, value))) {
            return true;
        }
    }
    return false;
}"
561,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,97,108,"private boolean findMatch(Iterator lit, Iterator rit) {
    HashSet left = new HashSet();
    while (lit.hasNext()) {
        left.add(lit.next());
    }
    while (rit.hasNext()) {
        if (containsMatch(left.iterator(), rit.next())) {
            return true;
        }
    }
    return false;
}"
562,JxPath,7,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,110,114,"private int compare(Object l, Object r) {
    double ld = InfoSetUtil.doubleValue(l);
    double rd = InfoSetUtil.doubleValue(r);
    return ld == rd ? 0 : ld < rd ? -1 : 1;
}"
563,JxPath,8,jira,https://issues.apache.org/jira/browse/JXPATH-95,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,56,84,"private boolean compute(Object left, Object right) {
    left = reduce(left);
    right = reduce(right);
    if (left instanceof InitialContext) {
        ((InitialContext) left).reset();
    }
    if (right instanceof InitialContext) {
        ((InitialContext) right).reset();
    }
    if (left instanceof Iterator && right instanceof Iterator) {
        return findMatch((Iterator) left, (Iterator) right);
    }
    if (left instanceof Iterator) {
        return containsMatch((Iterator) left, right);
    }
    if (right instanceof Iterator) {
        return containsMatch((Iterator) right, left);
    }
    double ld = InfoSetUtil.doubleValue(left);
    if (Double.isNaN(ld)) {
        return false;
    }
    double rd = InfoSetUtil.doubleValue(right);
    if (Double.isNaN(rd)) {
        return false;
    }
    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
}"
564,JxPath,9,jira,https://issues.apache.org/jira/browse/JXPATH-95,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java,48,50,"public Object computeValue(EvalContext context) {
    return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;
}"
565,JxPath,9,jira,https://issues.apache.org/jira/browse/JXPATH-95,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java,130,161,"protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }
    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }
    boolean result;
    if (l instanceof Boolean || r instanceof Boolean) {
        result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r);
    } else if (l instanceof Number || r instanceof Number) {
        // if either side is NaN, no comparison returns true:
        double ld = InfoSetUtil.doubleValue(l);
        if (Double.isNaN(ld)) {
            return false;
        }
        double rd = InfoSetUtil.doubleValue(r);
        if (Double.isNaN(rd)) {
            return false;
        }
        result = ld == rd;
    } else {
        if (l instanceof String || r instanceof String) {
            l = InfoSetUtil.stringValue(l);
            r = InfoSetUtil.stringValue(r);
        }
        result = l == r || l != null && l.equals(r);
    }
    return result ^ invert;
}"
566,JxPath,10,jira,https://issues.apache.org/jira/browse/JXPATH-93,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,41,44,"public final Object computeValue(EvalContext context) {
    return compute(args[0].compute(context), args[1].compute(context)) ? Boolean.TRUE : Boolean.FALSE;
}"
567,JxPath,11,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,107,136,"private Attr getAttribute(Element element, QName name) {
    String testPrefix = name.getPrefix();
    String testNS = null;
    if (testPrefix != null) {
        NamespaceResolver nsr = parent.getNamespaceResolver();
        testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix);
        testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS;
    }
    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }
        // This may mean that the parser does not support NS for
        // attributes, example - the version of Crimson bundled
        // with JDK 1.4.0
        NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr, name)) {
                return attr;
            }
        }
        return null;
    }
    return element.getAttributeNode(name.getName());
}"
568,JxPath,12,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,87,137,"public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}"
569,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java,47,64,"/**
 * Find the namespace prefix for the specified namespace URI and NodePointer.
 * @param pointer
 * @param namespaceURI
 * @return prefix if found
 * @since JXPath 1.3
 */
protected static String getPrefix(NodePointer pointer, String namespaceURI) {
    NodePointer currentPointer = pointer;
    while (currentPointer != null) {
        NodeIterator ni = currentPointer.namespaceIterator();
        for (int position = 1; ni != null && ni.setPosition(position); position++) {
            NodePointer nsPointer = ni.getNodePointer();
            String uri = nsPointer.getNamespaceURI();
            if (uri.equals(namespaceURI)) {
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    return prefix;
                }
            }
        }
        currentPointer = pointer.getParent();
    }
    return null;
}"
570,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java,125,129,"/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */
public synchronized String getNamespaceURI(String prefix) {
    String uri = getExternallyRegisteredNamespaceURI(prefix);
    return uri == null && pointer != null ? pointer.getNamespaceURI(prefix) : uri;
}"
571,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java,138,143,"/**
 * Given a prefix, returns an externally registered namespace URI.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 * @since JXPath 1.3
 */
protected synchronized String getExternallyRegisteredNamespaceURI(String prefix) {
    String uri = (String) namespaceMap.get(prefix);
    return uri == null && parent != null ? parent.getExternallyRegisteredNamespaceURI(prefix) : uri;
}"
572,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java,150,154,"/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */
public synchronized String getPrefix(String namespaceURI) {
    String prefix = getExternallyRegisteredPrefix(namespaceURI);
    return prefix == null && pointer != null ? getPrefix(pointer, namespaceURI) : prefix;
}"
573,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java,162,174,"/**
 * Get the nearest prefix found that matches an externally-registered namespace.
 * @param namespaceURI
 * @return String prefix if found.
 * @since JXPath 1.3
 */
protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {
    if (reverseMap == null) {
        reverseMap = new HashMap();
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    return prefix == null && parent != null ? parent.getExternallyRegisteredPrefix(namespaceURI) : prefix;
}"
574,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,191,197,"/* (non-Javadoc)
     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()
     */
public synchronized NamespaceResolver getNamespaceResolver() {
    if (localNamespaceResolver == null) {
        localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());
        localNamespaceResolver.setNamespaceContextPointer(this);
    }
    return localNamespaceResolver;
}"
575,JxPath,13,jira,https://issues.apache.org/jira/browse/JXPATH-97,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,417,443,"public NodePointer createAttribute(JXPathContext context, QName name) {
    if (!(node instanceof Element)) {
        return super.createAttribute(context, name);
    }
    Element element = (Element) node;
    String prefix = name.getPrefix();
    if (prefix != null) {
        String ns = null;
        NamespaceResolver nsr = getNamespaceResolver();
        if (nsr != null) {
            ns = nsr.getNamespaceURI(prefix);
        }
        if (ns == null) {
            throw new JXPathException(""Unknown namespace prefix: "" + prefix);
        }
        element.setAttributeNS(ns, name.toString(), """");
    } else {
        if (!element.hasAttribute(name.getName())) {
            element.setAttribute(name.getName(), """");
        }
    }
    NodeIterator it = attributeIterator(name);
    it.setPosition(1);
    return it.getNodePointer();
}"
576,JxPath,14,jira,https://issues.apache.org/jira/browse/JXPATH-102,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,653,660,"protected Object functionFloor(EvalContext context) {
    assertArgCount(1);
    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return new Double(v);
    }
    return new Double(Math.floor(v));
}"
577,JxPath,14,jira,https://issues.apache.org/jira/browse/JXPATH-102,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,662,669,"protected Object functionCeiling(EvalContext context) {
    assertArgCount(1);
    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return new Double(v);
    }
    return new Double(Math.ceil(v));
}"
578,JxPath,14,jira,https://issues.apache.org/jira/browse/JXPATH-102,High,src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,671,678,"protected Object functionRound(EvalContext context) {
    assertArgCount(1);
    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return new Double(v);
    }
    return new Double(Math.round(v));
}"
579,JxPath,15,jira,https://issues.apache.org/jira/browse/JXPATH-100,High,src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,47,70,"public boolean setPosition(int position) {
    if (!prepared) {
        prepared = true;
        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
        ArrayList pointers = new ArrayList();
        for (int i = 0; i < contexts.length; i++) {
            EvalContext ctx = (EvalContext) contexts[i];
            while (ctx.nextSet()) {
                while (ctx.nextNode()) {
                    NodePointer ptr = ctx.getCurrentNodePointer();
                    if (!pointers.contains(ptr)) {
                        pointers.add(ptr);
                    }
                }
            }
        }
        sortPointers(pointers);
        for (Iterator it = pointers.iterator(); it.hasNext(); ) {
            nodeSet.add((Pointer) it.next());
        }
    }
    return super.setPosition(position);
}"
580,JxPath,16,jira,https://issues.apache.org/jira/browse/JXPATH-114,Low,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,117,166,"/**
 * Test a Node.
 * @param node to test
 * @param test to execute
 * @return true if node passes test
 */
public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return true;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}"
581,JxPath,16,jira,https://issues.apache.org/jira/browse/JXPATH-114,Low,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,358,407,"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return true;
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
        String testPI = ((ProcessingInstructionTest) test).getTarget();
        String nodePI = ((ProcessingInstruction) node).getTarget();
        return testPI.equals(nodePI);
    }
    return false;
}"
582,JxPath,17,jira,https://issues.apache.org/jira/browse/JXPATH-109,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,68,94,"private boolean testAttr(Attr attr) {
    String nodePrefix = DOMNodePointer.getPrefix(attr);
    String nodeLocalName = DOMNodePointer.getLocalName(attr);
    if (nodePrefix != null && nodePrefix.equals(""xmlns"")) {
        return false;
    }
    if (nodePrefix == null && nodeLocalName.equals(""xmlns"")) {
        return false;
    }
    String testLocalName = name.getName();
    if (testLocalName.equals(""*"") || testLocalName.equals(nodeLocalName)) {
        String testPrefix = name.getPrefix();
        if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) {
            return true;
        }
        if (nodePrefix == null) {
            return false;
        }
        return equalStrings(parent.getNamespaceURI(testPrefix), parent.getNamespaceURI(nodePrefix));
    }
    return false;
}"
583,JxPath,18,jira,https://issues.apache.org/jira/browse/JXPATH-115,Low,src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,74,101,"public boolean nextNode() {
    super.setPosition(getCurrentPosition() + 1);
    if (!setStarted) {
        setStarted = true;
        NodeNameTest nodeNameTest = null;
        if (nodeTest instanceof NodeTypeTest) {
            if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {
                nodeNameTest = WILDCARD_TEST;
            }
        } else if (nodeTest instanceof NodeNameTest) {
            nodeNameTest = (NodeNameTest) nodeTest;
        }
        if (nodeNameTest == null) {
            return false;
        }
        iterator = parentContext.getCurrentNodePointer().attributeIterator(nodeNameTest.getNodeName());
    }
    if (iterator == null) {
        return false;
    }
    if (!iterator.setPosition(iterator.getPosition() + 1)) {
        return false;
    }
    currentNodePointer = iterator.getNodePointer();
    return true;
}"
584,JxPath,19,jira,https://issues.apache.org/jira/browse/JXPATH-125,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,556,566,"/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
private int getRelativePositionByQName() {
    int count = 1;
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) {
            count++;
        }
        n = n.getPreviousSibling();
    }
    return count;
}"
585,JxPath,19,jira,https://issues.apache.org/jira/browse/JXPATH-125,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,568,574,"private boolean matchesQName(Node n) {
    if (getNamespaceURI() != null) {
        return equalStrings(getNamespaceURI(n), getNamespaceURI()) && equalStrings(node.getLocalName(), n.getLocalName());
    }
    return equalStrings(node.getNodeName(), n.getNodeName());
}"
586,JxPath,19,jira,https://issues.apache.org/jira/browse/JXPATH-125,High,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,684,706,"/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
private int getRelativePositionByQName() {
    if (node instanceof Element) {
        Object parent = ((Element) node).getParent();
        if (!(parent instanceof Element)) {
            return 1;
        }
        List children = ((Element) parent).getContent();
        int count = 0;
        String name = ((Element) node).getQualifiedName();
        for (int i = 0; i < children.size(); i++) {
            Object child = children.get(i);
            if (child instanceof Element && matchesQName(((Element) child))) {
                count++;
            }
            if (child == node) {
                break;
            }
        }
        return count;
    }
    return 1;
}"
587,JxPath,19,jira,https://issues.apache.org/jira/browse/JXPATH-125,High,src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,708,716,"private boolean matchesQName(Element element) {
    if (getNamespaceURI() != null) {
        String ns = getNamespaceURI(element);
        if (ns == null || !ns.equals(getNamespaceURI())) {
            return false;
        }
    }
    return element.getName().equals(((Element) node).getName());
}"
588,JxPath,20,jira,https://issues.apache.org/jira/browse/JXPATH-149,Low,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,71,99,"/**
 * Compare left to right.
 * @param left left operand
 * @param right right operand
 * @return operation success/failure
 */
private boolean compute(Object left, Object right) {
    left = reduce(left);
    right = reduce(right);
    if (left instanceof InitialContext) {
        ((InitialContext) left).reset();
    }
    if (right instanceof InitialContext) {
        ((InitialContext) right).reset();
    }
    if (left instanceof Iterator && right instanceof Iterator) {
        return findMatch((Iterator) left, (Iterator) right);
    }
    if (left instanceof Iterator) {
        return containsMatch((Iterator) left, right);
    }
    if (right instanceof Iterator) {
        return containsMatch(left, (Iterator) right);
    }
    double ld = InfoSetUtil.doubleValue(left);
    if (Double.isNaN(ld)) {
        return false;
    }
    double rd = InfoSetUtil.doubleValue(right);
    if (Double.isNaN(rd)) {
        return false;
    }
    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
}"
589,JxPath,20,jira,https://issues.apache.org/jira/browse/JXPATH-149,Low,src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,138,146,"/**
 * Learn whether any element returned from an Iterator matches a given value.
 * @param it Iterator
 * @param value to look for
 * @return whether a match was found
 */
private boolean containsMatch(Object value, Iterator it) {
    while (it.hasNext()) {
        Object element = it.next();
        if (compute(value, element)) {
            return true;
        }
    }
    return false;
}"
590,JxPath,21,jira,https://issues.apache.org/jira/browse/JXPATH-151,Critical,src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,151,154,"/**
 * If the property contains a collection, then the length of that
 * collection, otherwise - 1.
 * @return int length
 */
public int getLength() {
    Object baseValue = getBaseValue();
    return baseValue == null ? 1 : ValueUtils.getLength(baseValue);
}"
591,JxPath,22,jira,https://issues.apache.org/jira/browse/JXPATH-154,High,src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,672,697,"/**
 * Get the ns uri of the specified node.
 * @param node Node to check
 * @return String ns uri
 */
public static String getNamespaceURI(Node node) {
    if (node instanceof Document) {
        node = ((Document) node).getDocumentElement();
    }
    Element element = (Element) node;
    String uri = element.getNamespaceURI();
    if (uri == null) {
        String prefix = getPrefix(node);
        String qname = prefix == null ? ""xmlns"" : ""xmlns:"" + prefix;
        Node aNode = node;
        while (aNode != null) {
            if (aNode.getNodeType() == Node.ELEMENT_NODE) {
                Attr attr = ((Element) aNode).getAttributeNode(qname);
                if (attr != null) {
                    uri = attr.getValue();
                    break;
                }
            }
            aNode = aNode.getParentNode();
        }
    }
    return """".equals(uri) ? null : uri;
}"
592,Lang,1,jira,https://issues.apache.org/jira/browse/LANG-747,High,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,450,623,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
 * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
 * prefix is more than 8 - or BigInteger if there are more than 16 digits.
 * </p>
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>
 * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
 * be Integer, Long or BigDecimal as appropriate.
 * </p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = { ""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#"" };
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) {
        // we have a hex number
        // strip leading zeroes
        char firstSigDigit = 0;
        for (int i = pfxLen; i < str.length(); i++) {
            firstSigDigit = str.charAt(i);
            if (firstSigDigit == '0') {
                // count leading zeroes
                pfxLen++;
            } else {
                break;
            }
        }
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) {
            // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    // assumes both not present
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
    // and the parsing which will detect if e or E appear in a number due to using the wrong offset
    // Check required precision (LANG-693)
    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1) {
            // there is an exponent
            if (expPos < decPos || expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    // small and go from there...
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) {
        // Must be an Integer, Long, Biginteger
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        return createBigInteger(str);
    }
    // Must be a Float, Double, BigDecimal
    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        if (numDecimals <= 7) {
            // If number has 7 or fewer digits past the decimal point then make it a float
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    try {
        if (numDecimals <= 16) {
            // If number has between 8 and 16 digits past the decimal point then make it a double
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    return createBigDecimal(str);
}"
593,Lang,3,jira,https://issues.apache.org/jira/browse/LANG-693,Low,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,450,614,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
 * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
 * prefix is more than 8 - or BigInteger if there are more than 16 digits.
 * </p>
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>
 * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
 * be Integer, Long or BigDecimal as appropriate.
 * </p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = { ""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#"" };
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) {
        // we have a hex number
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) {
            // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    // assumes both not present
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
    // and the parsing which will detect if e or E appear in a number due to using the wrong offset
    // Check required precision (LANG-693)
    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1) {
            // there is an exponent
            if (expPos < decPos || expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    // small and go from there...
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) {
        // Must be an Integer, Long, Biginteger
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        return createBigInteger(str);
    }
    // Must be a Float, Double, BigDecimal
    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        if (numDecimals <= 7) {
            // If number has 7 or fewer digits past the decimal point then make it a float
            final Float f = createFloat(str);
            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                return f;
            }
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    try {
        if (numDecimals <= 16) {
            // If number has between 8 and 16 digits past the decimal point then make it a double
            final Double d = createDouble(str);
            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                return d;
            }
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    return createBigDecimal(str);
}"
594,Lang,4,jira,https://issues.apache.org/jira/browse/LANG-882,High,src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java,68,84,"/**
 * {@inheritDoc}
 */
@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq.toString());
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}"
595,Lang,5,jira,https://issues.apache.org/jira/browse/LANG-865,High,src/main/java/org/apache/commons/lang3/LocaleUtils.java,88,149,"// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a Locale.</p>
 *
 * <p>This method takes the string format of a locale and creates the
 * locale object from it.</p>
 *
 * <pre>
 *   LocaleUtils.toLocale(""en"")         = new Locale(""en"", """")
 *   LocaleUtils.toLocale(""en_GB"")      = new Locale(""en"", ""GB"")
 *   LocaleUtils.toLocale(""en_GB_xxx"")  = new Locale(""en"", ""GB"", ""xxx"")   (#)
 * </pre>
 *
 * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.
 * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.
 * Thus, the result from getVariant() may vary depending on your JDK.</p>
 *
 * <p>This method validates the input strictly.
 * The language code must be lowercase.
 * The country code must be uppercase.
 * The separator must be an underscore.
 * The length must be correct.
 * </p>
 *
 * @param str  the locale String to convert, null returns null
 * @return a Locale, null if null input
 * @throws IllegalArgumentException if the string is an invalid format
 */
public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    if (ch0 == '_') {
        if (len < 3) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        final char ch1 = str.charAt(1);
        final char ch2 = str.charAt(2);
        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 3) {
            return new Locale("""", str.substring(1, 3));
        }
        if (len < 5) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (str.charAt(3) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        return new Locale("""", str.substring(1, 3), str.substring(4));
    } else {
        final char ch1 = str.charAt(1);
        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 2) {
            return new Locale(str);
        }
        if (len < 5) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        final char ch3 = str.charAt(3);
        if (ch3 == '_') {
            return new Locale(str.substring(0, 2), """", str.substring(4));
        }
        final char ch4 = str.charAt(4);
        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 5) {
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        }
        if (len < 7) {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (str.charAt(5) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
    }
}"
596,Lang,6,jira,https://issues.apache.org/jira/browse/LANG-857,Low,src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,75,98,"/**
 * Translate an input onto a Writer. This is intentionally final as its algorithm is
 * tightly coupled with the abstract method of this class.
 *
 * @param input CharSequence that is being translated
 * @param out Writer to translate the text to
 * @throws IOException if and only if the Writer produces an IOException
 */
public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
            continue;
        }
        // // and they just took care of a surrogate pair
        for (int pt = 0; pt < consumed; pt++) {
            pos += Character.charCount(Character.codePointAt(input, pt));
        }
    }
}"
597,Lang,7,jira,https://issues.apache.org/jira/browse/LANG-822,High,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,445,595,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it
 * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x
 * prefix is more than 8.
 * Values with leading <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        // drop 0x
        int hexDigits = str.length() - 2;
        if (str.startsWith(""-"")) {
            // drop -
            hexDigits--;
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}"
598,Lang,7,jira,https://issues.apache.org/jira/browse/LANG-822,High,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,710,726,"/**
 * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * @param str  a <code>String</code> to convert, may be null
 * @return converted <code>BigDecimal</code> (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static BigDecimal createBigDecimal(String str) {
    if (str == null) {
        return null;
    }
    // handle JDK1.3.1 bug where """" throws IndexOutOfBoundsException
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.trim().startsWith(""--"")) {
        // a wrong value.
        throw new NumberFormatException(str + "" is not a valid number."");
    }
    return new BigDecimal(str);
}"
599,Lang,8,jira,https://issues.apache.org/jira/browse/LANG-818,High,src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java,1130,1139,"/**
 * {@inheritDoc}
 */
@Override
public void appendTo(StringBuffer buffer, Calendar calendar) {
    TimeZone zone = calendar.getTimeZone();
    if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
        buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
    } else {
        buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
    }
}"
600,Lang,9,jira,https://issues.apache.org/jira/browse/LANG-832,High,src/main/java/org/apache/commons/lang3/time/FastDateParser.java,115,153,"/**
 * Initialize derived fields from defining fields.
 * This is called from constructor and from readObject (de-serialization)
 */
private void init() {
    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);
    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();
    StringBuilder regex = new StringBuilder();
    List<Strategy> collector = new ArrayList<Strategy>();
    Matcher patternMatcher = formatPattern.matcher(pattern);
    if (!patternMatcher.lookingAt()) {
        throw new IllegalArgumentException(""Invalid pattern"");
    }
    currentFormatField = patternMatcher.group();
    Strategy currentStrategy = getStrategy(currentFormatField);
    for (; ; ) {
        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
        if (!patternMatcher.lookingAt()) {
            nextStrategy = null;
            break;
        }
        String nextFormatField = patternMatcher.group();
        nextStrategy = getStrategy(nextFormatField);
        if (currentStrategy.addRegex(this, regex)) {
            collector.add(currentStrategy);
        }
        currentFormatField = nextFormatField;
        currentStrategy = nextStrategy;
    }
    if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
        throw new IllegalArgumentException(""Failed to parse \"""" + pattern + ""\"" ; gave up at index "" + patternMatcher.regionStart());
    }
    if (currentStrategy.addRegex(this, regex)) {
        collector.add(currentStrategy);
    }
    currentFormatField = null;
    strategies = collector.toArray(new Strategy[collector.size()]);
    parsePattern = Pattern.compile(regex.toString());
}"
601,Lang,10,jira,https://issues.apache.org/jira/browse/LANG-831,High,src/main/java/org/apache/commons/lang3/time/FastDateParser.java,303,334,"// Support for strategies
// -----------------------------------------------------------------------
/**
 * Escape constant fields into regular expression
 * @param regex The destination regex
 * @param value The source field
 * @param unquote If true, replace two success quotes ('') with single quote (')
 * @return The <code>StringBuilder</code>
 */
private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        switch(c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        return regex;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}"
602,Lang,11,jira,https://issues.apache.org/jira/browse/LANG-807,Low,src/main/java/org/apache/commons/lang3/RandomStringUtils.java,223,293,"/**
 * <p>Creates a random string based on a variety of options, using
 * supplied source of randomness.</p>
 *
 * <p>If start and end are both {@code 0}, start and end are set
 * to {@code ' '} and {@code 'z'}, the ASCII printable
 * characters, will be used, unless letters and numbers are both
 * {@code false}, in which case, start and end are set to
 * {@code 0} and {@code Integer.MAX_VALUE}.
 *
 * <p>If set is not {@code null}, characters between start and
 * end are chosen.</p>
 *
 * <p>This method accepts a user-supplied {@link Random}
 * instance to use as a source of randomness. By seeding a single
 * {@link Random} instance with a fixed seed and using it for each call,
 * the same random sequence of strings can be generated repeatedly
 * and predictably.</p>
 *
 * @param count  the length of random string to create
 * @param start  the position in set of chars to start at
 * @param end  the position in set of chars to end before
 * @param letters  only allow letters?
 * @param numbers  only allow numbers?
 * @param chars  the set of chars to choose randoms from, must not be empty.
 *  If {@code null}, then it will use the set of all chars.
 * @param random  a source of randomness.
 * @return the random string
 * @throws ArrayIndexOutOfBoundsException if there are not
 *  {@code (end - start) + 1} characters in the set array.
 * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.
 * @since 2.0
 */
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    } else {
        if (end <= start) {
            throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
        }
    }
    char[] buffer = new char[count];
    int gap = end - start;
    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }
        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 0) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[count] = ch;
                    count--;
                    buffer[count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 0) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[count] = (char) (56320 + random.nextInt(128));
                    count--;
                    buffer[count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}"
603,Lang,12,jira,https://issues.apache.org/jira/browse/LANG-805,Critical,src/main/java/org/apache/commons/lang3/RandomStringUtils.java,223,289,"/**
 * <p>Creates a random string based on a variety of options, using
 * supplied source of randomness.</p>
 *
 * <p>If start and end are both {@code 0}, start and end are set
 * to {@code ' '} and {@code 'z'}, the ASCII printable
 * characters, will be used, unless letters and numbers are both
 * {@code false}, in which case, start and end are set to
 * {@code 0} and {@code Integer.MAX_VALUE}.
 *
 * <p>If set is not {@code null}, characters between start and
 * end are chosen.</p>
 *
 * <p>This method accepts a user-supplied {@link Random}
 * instance to use as a source of randomness. By seeding a single
 * {@link Random} instance with a fixed seed and using it for each call,
 * the same random sequence of strings can be generated repeatedly
 * and predictably.</p>
 *
 * @param count  the length of random string to create
 * @param start  the position in set of chars to start at
 * @param end  the position in set of chars to end before
 * @param letters  only allow letters?
 * @param numbers  only allow numbers?
 * @param chars  the set of chars to choose randoms from, must not be empty.
 *  If {@code null}, then it will use the set of all chars.
 * @param random  a source of randomness.
 * @return the random string
 * @throws ArrayIndexOutOfBoundsException if there are not
 *  {@code (end - start) + 1} characters in the set array.
 * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.
 * @since 2.0
 */
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }
    char[] buffer = new char[count];
    int gap = end - start;
    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }
        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 0) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[count] = ch;
                    count--;
                    buffer[count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 0) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[count] = (char) (56320 + random.nextInt(128));
                    count--;
                    buffer[count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}"
604,Lang,13,jira,https://issues.apache.org/jira/browse/LANG-788,High,src/main/java/org/apache/commons/lang3/SerializationUtils.java,273,289,"/**
 * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
 * of the current <code>Thread</code> to resolve the class.
 * @param desc An instance of class <code>ObjectStreamClass</code>.
 * @return A <code>Class</code> object corresponding to <code>desc</code>.
 * @throws IOException Any of the usual Input/Output exceptions.
 * @throws ClassNotFoundException If class of a serialized object cannot be found.
 */
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
    String name = desc.getName();
    try {
        return Class.forName(name, false, classLoader);
    } catch (ClassNotFoundException ex) {
        try {
            return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
        } catch (ClassNotFoundException cnfe) {
            Class<?> cls = primitiveTypes.get(name);
            if (cls != null)
                return cls;
            else
                throw cnfe;
        }
    }
}"
605,Lang,14,jira,https://issues.apache.org/jira/browse/LANG-786,High,src/main/java/org/apache/commons/lang3/StringUtils.java,781,792,"// Equals
// -----------------------------------------------------------------------
/**
 * <p>Compares two CharSequences, returning {@code true} if they represent
 * equal sequences of characters.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * @see java.lang.CharSequence#equals(Object)
 * @param cs1  the first CharSequence, may be {@code null}
 * @param cs2  the second CharSequence, may be {@code null}
 * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
 * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)
 */
public static boolean equals(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}"
606,Lang,15,jira,https://issues.apache.org/jira/browse/LANG-775,High,src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java,179,235,"/**
 * <p> Checks if the subject type may be implicitly cast to the target
 * parameterized type following the Java generics rules. </p>
 *
 * @param type the subject type to be assigned to the target type
 * @param toParameterizedType the target parameterized type
 * @param typeVarAssigns a map with type variables
 * @return true if <code>type</code> is assignable to <code>toType</code>.
 */
private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {
    if (type == null) {
        return true;
    }
    // would have cause the previous to return true
    if (toParameterizedType == null) {
        return false;
    }
    // all types are assignable to themselves
    if (toParameterizedType.equals(type)) {
        return true;
    }
    // get the target type's raw type
    Class<?> toClass = getRawType(toParameterizedType);
    // get the subject type's type arguments including owner type arguments
    // and supertype arguments up to and including the target class.
    Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);
    // null means the two types are not compatible
    if (fromTypeVarAssigns == null) {
        return false;
    }
    // to parameterized types.
    if (fromTypeVarAssigns.isEmpty()) {
        return true;
    }
    // get the target type's type arguments including owner type arguments
    Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);
    // now to check each type argument
    for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
        Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
        Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
        // parameters of the target type.
        if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {
            return false;
        }
    }
    return true;
}"
607,Lang,15,jira,https://issues.apache.org/jira/browse/LANG-775,High,src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java,650,681,"/**
 * <p> Return a map of the type arguments of a class in the context of <code>toClass</code>. </p>
 *
 * @param cls the class in question
 * @param toClass the context class
 * @param subtypeVarAssigns a map with type variables
 * @return the map with type arguments
 */
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {
    // make sure they're assignable
    if (!isAssignable(cls, toClass)) {
        return null;
    }
    // can't work with primitives
    if (cls.isPrimitive()) {
        // both classes are primitives?
        if (toClass.isPrimitive()) {
            // harvested with these two types.
            return new HashMap<TypeVariable<?>, Type>();
        }
        // work with wrapper the wrapper class instead of the primitive
        cls = ClassUtils.primitiveToWrapper(cls);
    }
    // create a copy of the incoming map, or an empty one if it's null
    HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
    // has target class been reached?
    if (toClass.equals(cls)) {
        return typeVarAssigns;
    }
    // walk the inheritance hierarchy until the target class is reached
    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);
}"
608,Lang,16,jira,https://issues.apache.org/jira/browse/LANG-746,High,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,444,594,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}"
609,Lang,17,jira,https://issues.apache.org/jira/browse/LANG-720,High,src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,75,98,"/**
 * Translate an input onto a Writer. This is intentionally final as its algorithm is
 * tightly coupled with the abstract method of this class.
 *
 * @param input CharSequence that is being translated
 * @param out Writer to translate the text to
 * @throws IOException if and only if the Writer produces an IOException
 */
public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
            continue;
        }
        // // and they just took care of a surrogate pair
        for (int pt = 0; pt < consumed; pt++) {
            pos += Character.charCount(Character.codePointAt(input, pos));
        }
    }
}"
610,Lang,18,jira,https://issues.apache.org/jira/browse/LANG-719,High,src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,463,584,"// Parse the pattern
// -----------------------------------------------------------------------
/**
 * <p>Returns a list of Rules given a pattern.</p>
 *
 * @return a {@code List} of Rule objects
 * @throws IllegalArgumentException if pattern is invalid
 */
protected List<Rule> parsePattern() {
    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
    List<Rule> rules = new ArrayList<Rule>();
    String[] ERAs = symbols.getEras();
    String[] months = symbols.getMonths();
    String[] shortMonths = symbols.getShortMonths();
    String[] weekdays = symbols.getWeekdays();
    String[] shortWeekdays = symbols.getShortWeekdays();
    String[] AmPmStrings = symbols.getAmPmStrings();
    int length = mPattern.length();
    int[] indexRef = new int[1];
    for (int i = 0; i < length; i++) {
        indexRef[0] = i;
        String token = parseToken(mPattern, indexRef);
        i = indexRef[0];
        int tokenLen = token.length();
        if (tokenLen == 0) {
            break;
        }
        Rule rule;
        char c = token.charAt(0);
        switch(c) {
            case // era designator (text)
            'G':
                rule = new TextField(Calendar.ERA, ERAs);
                break;
            case // year (number)
            'y':
                if (tokenLen == 2) {
                    rule = TwoDigitYearField.INSTANCE;
                } else {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
                }
                break;
            case // month in year (text and number)
            'M':
                if (tokenLen >= 4) {
                    rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    rule = TwoDigitMonthField.INSTANCE;
                } else {
                    rule = UnpaddedMonthField.INSTANCE;
                }
                break;
            case // day in month (number)
            'd':
                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
                break;
            case // hour in am/pm (number, 1..12)
            'h':
                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
                break;
            case // hour in day (number, 0..23)
            'H':
                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
                break;
            case // minute in hour (number)
            'm':
                rule = selectNumberRule(Calendar.MINUTE, tokenLen);
                break;
            case // second in minute (number)
            's':
                rule = selectNumberRule(Calendar.SECOND, tokenLen);
                break;
            case // millisecond (number)
            'S':
                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
                break;
            case // day in week (text)
            'E':
                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                break;
            case // day in year (number)
            'D':
                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                break;
            case // day of week in month (number)
            'F':
                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
                break;
            case // week in year (number)
            'w':
                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
                break;
            case // week in month (number)
            'W':
                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
                break;
            case // am/pm marker (text)
            'a':
                rule = new TextField(Calendar.AM_PM, AmPmStrings);
                break;
            case // hour in day (1..24)
            'k':
                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
                break;
            case // hour in am/pm (0..11)
            'K':
                rule = selectNumberRule(Calendar.HOUR, tokenLen);
                break;
            case // time zone (text)
            'z':
                if (tokenLen >= 4) {
                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);
                } else {
                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);
                }
                break;
            case // time zone (value)
            'Z':
                if (tokenLen == 1) {
                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
                } else {
                    rule = TimeZoneNumberRule.INSTANCE_COLON;
                }
                break;
            case // literal text
            '\'':
                String sub = token.substring(1);
                if (sub.length() == 1) {
                    rule = new CharacterLiteral(sub.charAt(0));
                } else {
                    rule = new StringLiteral(sub);
                }
                break;
            default:
                throw new IllegalArgumentException(""Illegal pattern component: "" + token);
        }
        rules.add(rule);
    }
    return rules;
}"
611,Lang,19,jira,https://issues.apache.org/jira/browse/LANG-710,Low,src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java,36,89,"/**
 * {@inheritDoc}
 */
@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
            if (start == seqEnd) {
                return 0;
            }
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (end < seqEnd && ((input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F'))) {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
        return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
    }
    return 0;
}"
612,Lang,20,jira,https://issues.apache.org/jira/browse/LANG-703,High,src/main/java/org/apache/commons/lang3/StringUtils.java,3289,3309,"/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */
public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder(noOfItems * 16);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}"
613,Lang,20,jira,https://issues.apache.org/jira/browse/LANG-703,High,src/main/java/org/apache/commons/lang3/StringUtils.java,3368,3394,"/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */
public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    // (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder(noOfItems * 16);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}"
614,Lang,21,jira,https://issues.apache.org/jira/browse/LANG-677,High,src/main/java/org/apache/commons/lang3/time/DateUtils.java,258,270,"// -----------------------------------------------------------------------
/**
 * <p>Checks if two calendar objects represent the same local time.</p>
 *
 * <p>This method compares the values of the fields of the two objects.
 * In addition, both calendars must be the same of the same type.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());
}"
615,Lang,22,jira,https://issues.apache.org/jira/browse/LANG-662,Low,src/main/java/org/apache/commons/lang3/math/Fraction.java,581,630,"/**
 * <p>Gets the greatest common divisor of the absolute value of
 * two numbers, using the ""binary gcd"" method which avoids
 * division and modulo operations.  See Knuth 4.5.2 algorithm B.
 * This algorithm is due to Josef Stein (1961).</p>
 *
 * @param u  a non-zero number
 * @param v  a non-zero number
 * @return the greatest common divisor, never zero
 */
private static int greatestCommonDivisor(int u, int v) {
    // From Commons Math:
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        return Math.abs(u) + Math.abs(v);
    }
    // if either operand is abs 1, return 1:
    if (Math.abs(u) == 1 || Math.abs(v) == 1) {
        return 1;
    }
    // make u negative
    if (u > 0) {
        u = -u;
    }
    // make v negative
    if (v > 0) {
        v = -v;
    }
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are both even...
        // cast out twos.
        u /= 2;
        // cast out twos.
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}"
616,Lang,23,jira,https://issues.apache.org/jira/browse/LANG-636,High,src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java,264,286,"/**
 * Check if this extended message format is equal to another object.
 *
 * @param obj the object to compare to
 * @return true if this object equals the other, otherwise false
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
        return false;
    }
    ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;
    if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
        return false;
    }
    if (ObjectUtils.notEqual(registry, rhs.registry)) {
        return false;
    }
    return true;
}"
617,Lang,23,jira,https://issues.apache.org/jira/browse/LANG-636,High,src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java,293,299,"/**
 * Return the hashcode.
 *
 * @return the hashcode
 */
@Override
public int hashCode() {
    int result = super.hashCode();
    result = HASH_SEED * result + ObjectUtils.hashCode(registry);
    result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
    return result;
}"
618,Lang,24,jira,https://issues.apache.org/jira/browse/LANG-664,High,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,1319,1421,"/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                // str == ""0x""
                return false;
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    // don't want to loop to the last char, check it afterwords
    sz--;
    // for type qualifiers
    int i = start;
    // make a valid number (e.g. chars[0..5] = ""1234E"")
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            // we've already taken care of hex.
            if (hasExp) {
                // two E's
                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            // we need a digit after the E
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            // no type qualifier, OK
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            // can't have an E at the last byte
            return false;
        }
        if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            // single trailing decimal point after non-exponent is ok
            return foundDigit;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            // not allowing L with an exponent or decimal point
            return foundDigit && !hasExp && !hasDecPoint;
        }
        // last character is illegal
        return false;
    }
    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
    return !allowSigns && foundDigit;
}"
619,Lang,26,jira,https://issues.apache.org/jira/browse/LANG-645,High,src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,819,823,"/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */
public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}"
620,Lang,27,jira,https://issues.apache.org/jira/browse/LANG-638,High,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,452,602,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}"
621,Lang,28,jira,https://issues.apache.org/jira/browse/LANG-617,Low,src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java,34,73,"/**
 * {@inheritDoc}
 */
@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    // TODO: Protect from ArrayIndexOutOfBounds
    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        }
        int end = start;
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}"
622,Lang,29,jira,https://issues.apache.org/jira/browse/LANG-624,High,src/main/java/org/apache/commons/lang3/SystemUtils.java,1672,1674,"/**
 * <p>
 * Converts the given Java version string to an <code>int</code>.
 * </p>
 *
 * <p>
 * Example return values:
 * </p>
 * <ul>
 * <li><code>120</code> for Java 1.2</li>
 * <li><code>131</code> for Java 1.3.1</li>
 * <li><code>160</code> for Java 1.6.0_20</li>
 * </ul>
 *
 * <p>
 * Patch releases are not reported.
 * </p>
 * <p>
 * This method is package private instead of private to support unit test invocation.
 * </p>
 *
 * @return the version, for example 131 for Java 1.3.1
 */
static int toJavaVersionInt(String version) {
    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
}"
623,Lang,30,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1371,1395,"// IndexOfAny chars
// -----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
624,Lang,30,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1451,1479,"// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(String cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}"
625,Lang,30,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1508,1513,"/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return
 * <code>false</code>.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(String cs, String searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, searchChars.toCharArray());
}"
626,Lang,30,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1539,1564,"// IndexOfAnyBut chars
// -----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)           = -1
 * StringUtils.indexOfAnyBut("""", *)             = -1
 * StringUtils.indexOfAnyBut(*, null)           = -1
 * StringUtils.indexOfAnyBut(*, [])             = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"",'za') = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", '')  = 0
 * StringUtils.indexOfAnyBut(""aba"", 'ab')       = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}"
627,Lang,30,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1588,1608,"/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        boolean chFound = searchChars.indexOf(ch) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            char ch2 = str.charAt(i + 1);
            if (chFound && searchChars.indexOf(ch2) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
628,Lang,30,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1700,1728,"// ContainsNone
// -----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */
public static boolean containsNone(CharSequence cs, char[] searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}"
629,Lang,31,jira,https://issues.apache.org/jira/browse/LANG-607,Low,src/main/java/org/apache/commons/lang3/StringUtils.java,1440,1465,"// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLastIndex = csLength - 1;
    int searchLastIndex = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}"
630,Lang,32,jira,https://issues.apache.org/jira/browse/LANG-586,High,src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,146,149,"/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid
 * infinite loops.
 * </p>
 *
 * @param value
 *            The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given object.
 * @since 2.3
 */
static boolean isRegistered(Object value) {
    Set<IDKey> registry = getRegistry();
    return registry != null && registry.contains(new IDKey(value));
}"
631,Lang,32,jira,https://issues.apache.org/jira/browse/LANG-586,High,src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,517,524,"/**
 * <p>
 * Registers the given object. Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *            The object to register.
 */
static void register(Object value) {
    synchronized (HashCodeBuilder.class) {
        if (getRegistry() == null) {
            REGISTRY.set(new HashSet<IDKey>());
        }
    }
    getRegistry().add(new IDKey(value));
}"
632,Lang,32,jira,https://issues.apache.org/jira/browse/LANG-586,High,src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,538,548,"/**
 * <p>
 * Unregisters the given object.
 * </p>
 *
 * <p>
 * Used by the reflection methods to avoid infinite loops.
 *
 * @param value
 *            The object to unregister.
 * @since 2.3
 */
static void unregister(Object value) {
    Set<IDKey> s = getRegistry();
    if (s != null) {
        s.remove(new IDKey(value));
        synchronized (HashCodeBuilder.class) {
            if (s.isEmpty()) {
                REGISTRY.remove();
            }
        }
    }
}"
633,Lang,33,jira,https://issues.apache.org/jira/browse/LANG-587,High,src/main/java/org/apache/commons/lang3/ClassUtils.java,902,913,"/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.
 * If any of these objects is null, a null element will be inserted into the array.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */
public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i] == null ? null : array[i].getClass();
    }
    return classes;
}"
634,Lang,34,jira,https://issues.apache.org/jira/browse/LANG-586,High,src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java,147,149,"/**
 * <p>
 * Returns the registry of objects being traversed by the <code>reflectionToString</code>
 * methods in the current thread.
 * </p>
 *
 * @return Set the registry of objects being traversed
 */
static Map<Object, Object> getRegistry() {
    return REGISTRY.get();
}"
635,Lang,34,jira,https://issues.apache.org/jira/browse/LANG-586,High,src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java,162,165,"/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object.
 * Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *                  The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given
 *             object.
 */
static boolean isRegistered(Object value) {
    Map<Object, Object> m = getRegistry();
    return m != null && m.containsKey(value);
}"
636,Lang,35,jira,https://issues.apache.org/jira/browse/LANG-571,High,src/main/java/org/apache/commons/lang3/ArrayUtils.java,3288,3301,"/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element, unless the element itself is null,
 *  in which case the return type is Object[]</p>
 *
 * <pre>
 * ArrayUtils.add(null, null)      = [null]
 * ArrayUtils.add(null, ""a"")       = [""a""]
 * ArrayUtils.add([""a""], null)     = [""a"", null]
 * ArrayUtils.add([""a""], ""b"")      = [""a"", ""b""]
 * ArrayUtils.add([""a"", ""b""], ""c"") = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param array  the array to ""add"" the element to, may be <code>null</code>
 * @param element  the object to add, may be <code>null</code>
 * @return A new array containing the existing elements plus the new element
 * The returned array type will be that of the input array (unless null),
 * in which case it will have the same type as the element.
 * If both are null, an IllegalArgumentException is thrown
 * @since 2.1
 * @throws IllegalArgumentException if both arguments are null
 */
public static <T> T[] add(T[] array, T element) {
    Class<?> type;
    if (array != null) {
        type = array.getClass();
    } else if (element != null) {
        type = element.getClass();
    } else {
        throw new IllegalArgumentException(""Arguments cannot both be null"");
    }
    // type must be T
    @SuppressWarnings(""unchecked"")
    T[] newArray = (T[]) copyArrayGrow1(array, type);
    newArray[newArray.length - 1] = element;
    return newArray;
}"
637,Lang,35,jira,https://issues.apache.org/jira/browse/LANG-571,High,src/main/java/org/apache/commons/lang3/ArrayUtils.java,3567,3579,"/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, null)      = [null]
 * ArrayUtils.add(null, 0, ""a"")       = [""a""]
 * ArrayUtils.add([""a""], 1, null)     = [""a"", null]
 * ArrayUtils.add([""a""], 1, ""b"")      = [""a"", ""b""]
 * ArrayUtils.add([""a"", ""b""], 3, ""c"") = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 * @throws IllegalArgumentException if both array and element are null
 */
public static <T> T[] add(T[] array, int index, T element) {
    Class<?> clss = null;
    if (array != null) {
        clss = array.getClass().getComponentType();
    } else if (element != null) {
        clss = element.getClass();
    } else {
        throw new IllegalArgumentException(""Array and element cannot both be null"");
    }
    // the add method creates an array of type clss, which is type T
    @SuppressWarnings(""unchecked"")
    final T[] newArray = (T[]) add(array, index, element, clss);
    return newArray;
}"
638,Lang,36,jira,https://issues.apache.org/jira/browse/LANG-521,Low,src/java/org/apache/commons/lang3/math/NumberUtils.java,448,595,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}"
639,Lang,36,jira,https://issues.apache.org/jira/browse/LANG-521,Low,src/java/org/apache/commons/lang3/math/NumberUtils.java,1312,1414,"/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                // str == ""0x""
                return false;
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    // don't want to loop to the last char, check it afterwords
    sz--;
    // for type qualifiers
    int i = start;
    // make a valid number (e.g. chars[0..5] = ""1234E"")
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            // we've already taken care of hex.
            if (hasExp) {
                // two E's
                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            // we need a digit after the E
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            // no type qualifier, OK
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            // can't have an E at the last byte
            return false;
        }
        if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            // single trailing decimal point after non-exponent is ok
            return foundDigit;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            // not allowing L with an exponent
            return foundDigit && !hasExp;
        }
        // last character is illegal
        return false;
    }
    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
    return !allowSigns && foundDigit;
}"
640,Lang,37,jira,https://issues.apache.org/jira/browse/LANG-567,High,src/java/org/apache/commons/lang3/ArrayUtils.java,2952,2973,"/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(null, null)     = null
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * ArrayUtils.addAll([null], [null]) = [null, null]
 * ArrayUtils.addAll([""a"", ""b"", ""c""], [""1"", ""2"", ""3""]) = [""a"", ""b"", ""c"", ""1"", ""2"", ""3""]
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array, may be <code>null</code>
 * @param array2  the second array whose elements are added to the new array, may be <code>null</code>
 * @return The new array, <code>null</code> if both arrays are <code>null</code>.
 *      The type of the new array is the type of the first array,
 *      unless the first array is null, in which case the type is the same as the second array.
 * @since 2.1
 */
@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    try {
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    } catch (ArrayStoreException ase) {
        // Check if problem is incompatible types
        final Class<?> type2 = array2.getClass().getComponentType();
        if (!type1.isAssignableFrom(type2)) {
            throw new IllegalArgumentException(""Cannot store "" + type2.getName() + "" in an array of "" + type1.getName());
        }
        // No, so rethrow original
        throw ase;
    }
    return joinedArray;
}"
641,Lang,38,jira,https://issues.apache.org/jira/browse/LANG-538,High,src/java/org/apache/commons/lang3/time/FastDateFormat.java,870,877,"/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */
public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        // / LANG-538
        calendar.getTime();
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}"
642,Lang,39,jira,https://issues.apache.org/jira/browse/LANG-552,High,src/java/org/apache/commons/lang3/StringUtils.java,3605,3734,"/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, *) = IllegalArgumentException
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {
    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {
        return text;
    }
    // if recursing, this shouldnt be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }
    int searchLength = searchList.length;
    int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: "" + searchLength + "" vs "" + replacementLength);
    }
    // keep track of which still have matches
    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}"
643,Lang,40,jira,https://issues.apache.org/jira/browse/LANG-432,High,src/java/org/apache/commons/lang/StringUtils.java,1044,1056,"/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */
public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (str.regionMatches(true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}"
644,Lang,41,jira,https://issues.apache.org/jira/browse/LANG-535,Low,src/java/org/apache/commons/lang/ClassUtils.java,183,217,"/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */
public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuffer arrayPrefix = new StringBuffer();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}"
645,Lang,41,jira,https://issues.apache.org/jira/browse/LANG-535,Low,src/java/org/apache/commons/lang/ClassUtils.java,257,276,"/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */
public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}"
646,Lang,42,jira,https://issues.apache.org/jira/browse/LANG-480,Low,src/java/org/apache/commons/lang/Entities.java,825,849,"/**
 * <p>
 * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>
 * passed.
 * </p>
 *
 * @param writer
 *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.
 * @param str
 *            The <code>String</code> to escape. Assumed to be a non-null value.
 * @throws IOException
 *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}
 *             methods.
 *
 * @see #escape(String)
 * @see Writer
 */
public void escape(Writer writer, String str) throws IOException {
    int len = str.length();
    for (int i = 0; i < len; i++) {
        int c = Character.codePointAt(str, i);
        String entityName = this.entityName(c);
        if (entityName == null) {
            if (c >= 0x010000 && i < len - 1) {
                writer.write(""&#"");
                writer.write(Integer.toString(c, 10));
                writer.write(';');
                i++;
            } else if (c > 0x7F) {
                writer.write(""&#"");
                writer.write(Integer.toString(c, 10));
                writer.write(';');
            } else {
                writer.write(c);
            }
        } else {
            writer.write('&');
            writer.write(entityName);
            writer.write(';');
        }
    }
}"
647,Lang,43,jira,https://issues.apache.org/jira/browse/LANG-477,High,src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java,417,445,"/**
 * Consume a quoted string, adding it to <code>appendTo</code> if
 * specified.
 *
 * @param pattern pattern to parse
 * @param pos current parse position
 * @param appendTo optional StringBuffer to append
 * @param escapingOn whether to process escaped quotes
 * @return <code>appendTo</code>
 */
private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {
    int start = pos.getIndex();
    char[] c = pattern.toCharArray();
    if (escapingOn && c[start] == QUOTE) {
        next(pos);
        return appendTo == null ? null : appendTo.append(QUOTE);
    }
    int lastHold = start;
    for (int i = pos.getIndex(); i < pattern.length(); i++) {
        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);
            pos.setIndex(i + ESCAPED_QUOTE.length());
            lastHold = pos.getIndex();
            continue;
        }
        switch(c[pos.getIndex()]) {
            case QUOTE:
                next(pos);
                return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);
            default:
                next(pos);
        }
    }
    throw new IllegalArgumentException(""Unterminated quoted string at position "" + start);
}"
648,Lang,44,jira,https://issues.apache.org/jira/browse/LANG-457,High,src/java/org/apache/commons/lang/NumberUtils.java,138,289,"// --------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
        throw new NumberFormatException(val + "" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // empty catch
                }
            // Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            return createBigInteger(val);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // empty catch
            }
            return createBigDecimal(val);
        }
    }
}"
649,Lang,45,jira,https://issues.apache.org/jira/browse/LANG-419,Low,src/java/org/apache/commons/lang/WordUtils.java,605,645,"// -----------------------------------------------------------------------
/**
 * Abbreviates a string nicely.
 *
 * This method searches for the first space after the lower limit and abbreviates
 * the String there. It will also append any String passed as a parameter
 * to the end of the String. The upper limit can be specified to forcibly
 * abbreviate a String.
 *
 * @param str         the string to be abbreviated. If null is passed, null is returned.
 *                    If the empty String is passed, the empty string is returned.
 * @param lower       the lower limit.
 * @param upper       the upper limit; specify -1 if no limit is desired.
 *                    If the upper limit is lower than the lower limit, it will be
 *                    adjusted to be the same as the lower limit.
 * @param appendToEnd String to be appended to the end of the abbreviated string.
 *                    This is appended ONLY if the string was indeed abbreviated.
 *                    The append does not count towards the lower or upper limits.
 * @return the abbreviated String.
 * @since 2.4
 */
public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
    // initial parameter checks
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return StringUtils.EMPTY;
    }
    // set to the length of the string
    if (lower > str.length()) {
        lower = str.length();
    }
    // than the length of the string, set to the length of the string
    if (upper == -1 || upper > str.length()) {
        upper = str.length();
    }
    // if upper is less than lower, raise it to lower
    if (upper < lower) {
        upper = lower;
    }
    StringBuffer result = new StringBuffer();
    int index = StringUtils.indexOf(str, "" "", lower);
    if (index == -1) {
        result.append(str.substring(0, upper));
        // only if abbreviation has occured do we append the appendToEnd value
        if (upper != str.length()) {
            result.append(StringUtils.defaultString(appendToEnd));
        }
    } else if (index > upper) {
        result.append(str.substring(0, upper));
        result.append(StringUtils.defaultString(appendToEnd));
    } else {
        result.append(str.substring(0, index));
        result.append(StringUtils.defaultString(appendToEnd));
    }
    return result.toString();
}"
650,Lang,46,jira,https://issues.apache.org/jira/browse/LANG-421,Critical,src/java/org/apache/commons/lang/StringEscapeUtils.java,85,87,"// Java and JavaScript
// --------------------------------------------------------------------------
/**
 * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>
 *
 * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn't say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
public static String escapeJava(String str) {
    return escapeJavaStyleString(str, false, false);
}"
651,Lang,46,jira,https://issues.apache.org/jira/browse/LANG-421,Critical,src/java/org/apache/commons/lang/StringEscapeUtils.java,101,103,"/**
 * <p>Escapes the characters in a <code>String</code> using Java String rules to
 * a <code>Writer</code>.</p>
 *
 * <p>A <code>null</code> string input has no effect.</p>
 *
 * @see #escapeJava(java.lang.String)
 * @param out  Writer to write escaped string into
 * @param str  String to escape values in, may be null
 * @throws IllegalArgumentException if the Writer is <code>null</code>
 * @throws IOException if error occurs on underlying Writer
 */
public static void escapeJava(Writer out, String str) throws IOException {
    escapeJavaStyleString(out, str, false, false);
}"
652,Lang,46,jira,https://issues.apache.org/jira/browse/LANG-421,Critical,src/java/org/apache/commons/lang/StringEscapeUtils.java,126,128,"/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>
 * <p>Escapes any values it finds into their JavaScript String form.
 * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn\'t say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
public static String escapeJavaScript(String str) {
    return escapeJavaStyleString(str, true, true);
}"
653,Lang,46,jira,https://issues.apache.org/jira/browse/LANG-421,Critical,src/java/org/apache/commons/lang/StringEscapeUtils.java,142,144,"/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules
 * to a <code>Writer</code>.</p>
 *
 * <p>A <code>null</code> string input has no effect.</p>
 *
 * @see #escapeJavaScript(java.lang.String)
 * @param out  Writer to write escaped string into
 * @param str  String to escape values in, may be null
 * @throws IllegalArgumentException if the Writer is <code>null</code>
 * @throws IOException if error occurs on underlying Writer
 */
public static void escapeJavaScript(Writer out, String str) throws IOException {
    escapeJavaStyleString(out, str, true, true);
}"
654,Lang,46,jira,https://issues.apache.org/jira/browse/LANG-421,Critical,src/java/org/apache/commons/lang/StringEscapeUtils.java,154,167,"/**
 * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>
 *
 * @param str String to escape values in, may be null
 * @param escapeSingleQuotes escapes single quotes if <code>true</code>
 * @param escapeForwardSlash TODO
 * @return the escaped string
 */
private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
    if (str == null) {
        return null;
    }
    try {
        StringWriter writer = new StringWriter(str.length() * 2);
        escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
        return writer.toString();
    } catch (IOException ioe) {
        // this should never ever happen while writing to a StringWriter
        ioe.printStackTrace();
        return null;
    }
}"
655,Lang,46,jira,https://issues.apache.org/jira/browse/LANG-421,Critical,src/java/org/apache/commons/lang/StringEscapeUtils.java,178,256,"/**
 * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>
 *
 * @param out write to receieve the escaped string
 * @param str String to escape values in, may be null
 * @param escapeSingleQuote escapes single quotes if <code>true</code>
 * @param escapeForwardSlash TODO
 * @throws IOException if an IOException occurs
 */
private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, boolean escapeForwardSlash) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz;
    sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);
        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + hex(ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + hex(ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + hex(ch));
        } else if (ch < 32) {
            switch(ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    if (ch > 0xf) {
                        out.write(""\\u00"" + hex(ch));
                    } else {
                        out.write(""\\u000"" + hex(ch));
                    }
                    break;
            }
        } else {
            switch(ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                case '/':
                    if (escapeForwardSlash) {
                        out.write('\\');
                    }
                    out.write('/');
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}"
656,Lang,47,jira,https://issues.apache.org/jira/browse/LANG-412,High,src/java/org/apache/commons/lang/text/StrBuilder.java,1182,1202,"// -----------------------------------------------------------------------
/**
 * Appends an object to the builder padding on the left to a fixed width.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the left hand side is lost.
 * If the object is null, the null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */
public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        if (str == null) {
            str = """";
        }
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(strLen - width, strLen, buffer, size);
        } else {
            int padLen = width - strLen;
            for (int i = 0; i < padLen; i++) {
                buffer[size + i] = padChar;
            }
            str.getChars(0, strLen, buffer, size + padLen);
        }
        size += width;
    }
    return this;
}"
657,Lang,47,jira,https://issues.apache.org/jira/browse/LANG-412,High,src/java/org/apache/commons/lang/text/StrBuilder.java,1229,1249,"/**
 * Appends an object to the builder padding on the right to a fixed length.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the right hand side is lost.
 * If the object is null, null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */
public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        if (str == null) {
            str = """";
        }
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}"
658,Lang,48,jira,https://issues.apache.org/jira/browse/LANG-393,Low,src/java/org/apache/commons/lang/builder/EqualsBuilder.java,367,413,"// -------------------------------------------------------------------------
/**
 * <p>Test if two <code>Object</code>s are equal using their
 * <code>equals</code> method.</p>
 *
 * @param lhs  the left hand object
 * @param rhs  the right hand object
 * @return EqualsBuilder - used to chain calls.
 */
public EqualsBuilder append(Object lhs, Object rhs) {
    if (isEquals == false) {
        return this;
    }
    if (lhs == rhs) {
        return this;
    }
    if (lhs == null || rhs == null) {
        this.setEquals(false);
        return this;
    }
    Class lhsClass = lhs.getClass();
    if (!lhsClass.isArray()) {
        if (lhs instanceof java.math.BigDecimal) {
            isEquals = (((java.math.BigDecimal) lhs).compareTo(rhs) == 0);
        } else {
            // The simple case, not an array, just test the element
            isEquals = lhs.equals(rhs);
        }
    } else if (lhs.getClass() != rhs.getClass()) {
        // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]
        this.setEquals(false);
    } else // This handles multi dimensional arrays of the same depth
    if (lhs instanceof long[]) {
        append((long[]) lhs, (long[]) rhs);
    } else if (lhs instanceof int[]) {
        append((int[]) lhs, (int[]) rhs);
    } else if (lhs instanceof short[]) {
        append((short[]) lhs, (short[]) rhs);
    } else if (lhs instanceof char[]) {
        append((char[]) lhs, (char[]) rhs);
    } else if (lhs instanceof byte[]) {
        append((byte[]) lhs, (byte[]) rhs);
    } else if (lhs instanceof double[]) {
        append((double[]) lhs, (double[]) rhs);
    } else if (lhs instanceof float[]) {
        append((float[]) lhs, (float[]) rhs);
    } else if (lhs instanceof boolean[]) {
        append((boolean[]) lhs, (boolean[]) rhs);
    } else {
        // Not an array of primitives
        append((Object[]) lhs, (Object[]) rhs);
    }
    return this;
}"
659,Lang,49,jira,https://issues.apache.org/jira/browse/LANG-380,High,src/java/org/apache/commons/lang/math/Fraction.java,465,474,"// Calculations
// -------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    if (numerator == 0) {
        return equals(ZERO) ? this : ZERO;
    }
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}"
660,Lang,50,jira,https://issues.apache.org/jira/browse/LANG-368,High,src/java/org/apache/commons/lang/time/FastDateFormat.java,279,304,"/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */
public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}"
661,Lang,50,jira,https://issues.apache.org/jira/browse/LANG-368,High,src/java/org/apache/commons/lang/time/FastDateFormat.java,456,482,"/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */
public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}"
662,Lang,51,jira,https://issues.apache.org/jira/browse/LANG-365,High,src/java/org/apache/commons/lang/BooleanUtils.java,649,701,"// String to boolean methods
// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a boolean (optimised for performance).</p>
 *
 * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>
 * (case insensitive) will return <code>true</code>. Otherwise,
 * <code>false</code> is returned.</p>
 *
 * <p>This method performs 4 times faster (JDK1.4) than
 * <code>Boolean.valueOf(String)</code>. However, this method accepts
 * 'on' and 'yes' as true values.
 *
 * <pre>
 *   BooleanUtils.toBoolean(null)    = false
 *   BooleanUtils.toBoolean(""true"")  = true
 *   BooleanUtils.toBoolean(""TRUE"")  = true
 *   BooleanUtils.toBoolean(""tRUe"")  = true
 *   BooleanUtils.toBoolean(""on"")    = true
 *   BooleanUtils.toBoolean(""yes"")   = true
 *   BooleanUtils.toBoolean(""false"") = false
 *   BooleanUtils.toBoolean(""x gti"") = false
 * </pre>
 *
 * @param str  the String to check
 * @return the boolean value of the string, <code>false</code> if no match
 */
public static boolean toBoolean(String str) {
    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
    if (str == ""true"") {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch(str.length()) {
        case 2:
            {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');
            }
        case 3:
            {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
                }
                return false;
            }
        case 4:
            {
                char ch = str.charAt(0);
                if (ch == 't') {
                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
    }
    return false;
}"
663,Lang,52,jira,https://issues.apache.org/jira/browse/LANG-363,Low,src/java/org/apache/commons/lang/StringEscapeUtils.java,171,246,"/**
 * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>
 *
 * @param out write to receieve the escaped string
 * @param str String to escape values in, may be null
 * @param escapeSingleQuote escapes single quotes if <code>true</code>
 * @throws IOException if an IOException occurs
 */
private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (str == null) {
        return;
    }
    int sz;
    sz = str.length();
    for (int i = 0; i < sz; i++) {
        char ch = str.charAt(i);
        // handle unicode
        if (ch > 0xfff) {
            out.write(""\\u"" + hex(ch));
        } else if (ch > 0xff) {
            out.write(""\\u0"" + hex(ch));
        } else if (ch > 0x7f) {
            out.write(""\\u00"" + hex(ch));
        } else if (ch < 32) {
            switch(ch) {
                case '\b':
                    out.write('\\');
                    out.write('b');
                    break;
                case '\n':
                    out.write('\\');
                    out.write('n');
                    break;
                case '\t':
                    out.write('\\');
                    out.write('t');
                    break;
                case '\f':
                    out.write('\\');
                    out.write('f');
                    break;
                case '\r':
                    out.write('\\');
                    out.write('r');
                    break;
                default:
                    if (ch > 0xf) {
                        out.write(""\\u00"" + hex(ch));
                    } else {
                        out.write(""\\u000"" + hex(ch));
                    }
                    break;
            }
        } else {
            switch(ch) {
                case '\'':
                    if (escapeSingleQuote) {
                        out.write('\\');
                    }
                    out.write('\'');
                    break;
                case '""':
                    out.write('\\');
                    out.write('""');
                    break;
                case '\\':
                    out.write('\\');
                    out.write('\\');
                    break;
                case '/':
                    out.write('\\');
                    out.write('/');
                    break;
                default:
                    out.write(ch);
                    break;
            }
        }
    }
}"
664,Lang,53,jira,https://issues.apache.org/jira/browse/LANG-346,High,src/java/org/apache/commons/lang/time/DateUtils.java,620,744,"// -----------------------------------------------------------------------
/**
 * <p>Internal calculation method.</p>
 *
 * @param val  the calendar
 * @param field  the field constant
 * @param round  true to round, false to truncate
 * @throws ArithmeticException if the year is over 280 million
 */
private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }
    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    // see http://issues.apache.org/jira/browse/LANG-59
    // 
    // Manually truncate milliseconds, seconds and minutes, rather than using
    // Calendar methods.
    Date date = val.getTime();
    long time = date.getTime();
    boolean done = false;
    // truncate milliseconds
    int millisecs = val.get(Calendar.MILLISECOND);
    if (!round || millisecs < 500) {
        time = time - millisecs;
    }
    if (field == Calendar.SECOND) {
        done = true;
    }
    // truncate seconds
    int seconds = val.get(Calendar.SECOND);
    if (!done && (!round || seconds < 30)) {
        time = time - (seconds * 1000L);
    }
    if (field == Calendar.MINUTE) {
        done = true;
    }
    // truncate minutes
    int minutes = val.get(Calendar.MINUTE);
    if (!done && (!round || minutes < 30)) {
        time = time - (minutes * 60000L);
    }
    // reset time
    if (date.getTime() != time) {
        date.setTime(time);
        val.setTime(date);
    }
    // ----------------- Fix for LANG-59 ----------------------- END ----------------
    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                // This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        // we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        // We need at add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        // We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        // These are special types of fields that require different rounding rules
        switch(field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    // If we're going to drop the DATE field's value,
                    // we want to do this our own way.
                    // We need to subtrace 1 since the date has a minimum of 1
                    offset = val.get(Calendar.DATE) - 1;
                    // bottom half of the month and should stay accordingly.
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    // Record whether we're in the top or bottom half of that range
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    // If we're going to drop the HOUR field's value,
                    // we want to do this our own way.
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            // Calculate the offset from the minimum allowed value
            offset = val.get(fields[i][0]) - min;
            // Set roundUp if this is more than half way between the minimum and maximum
            roundUp = offset > ((max - min) / 2);
        }
        // We need to remove this field
        if (offset != 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}"
665,Lang,54,jira,https://issues.apache.org/jira/browse/LANG-328,High,src/java/org/apache/commons/lang/LocaleUtils.java,94,130,"// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a Locale.</p>
 *
 * <p>This method takes the string format of a locale and creates the
 * locale object from it.</p>
 *
 * <pre>
 *   LocaleUtils.toLocale(""en"")         = new Locale(""en"", """")
 *   LocaleUtils.toLocale(""en_GB"")      = new Locale(""en"", ""GB"")
 *   LocaleUtils.toLocale(""en_GB_xxx"")  = new Locale(""en"", ""GB"", ""xxx"")   (#)
 * </pre>
 *
 * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.
 * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.
 * Thus, the result from getVariant() may vary depending on your JDK.</p>
 *
 * <p>This method validates the input strictly.
 * The language code must be lowercase.
 * The country code must be uppercase.
 * The separator must be an underscore.
 * The length must be correct.
 * </p>
 *
 * @param str  the locale String to convert, null returns null
 * @return a Locale, null if null input
 * @throws IllegalArgumentException if the string is an invalid format
 */
public static Locale toLocale(String str) {
    if (str == null) {
        return null;
    }
    int len = str.length();
    if (len != 2 && len != 5 && len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    char ch0 = str.charAt(0);
    char ch1 = str.charAt(1);
    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str, """");
    } else {
        if (str.charAt(2) != '_') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        char ch3 = str.charAt(3);
        if (ch3 == '_') {
            return new Locale(str.substring(0, 2), """", str.substring(4));
        }
        char ch4 = str.charAt(4);
        if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
            throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
        if (len == 5) {
            return new Locale(str.substring(0, 2), str.substring(3, 5));
        } else {
            if (str.charAt(5) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
    }
}"
666,Lang,55,jira,https://issues.apache.org/jira/browse/LANG-315,High,src/java/org/apache/commons/lang/time/StopWatch.java,114,122,"/**
 * <p>Stop the stopwatch.</p>
 *
 * <p>This method ends a new timing session, allowing the time to be retrieved.</p>
 *
 * @throws IllegalStateException if the StopWatch is not running.
 */
public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch is not running. "");
    }
    if (this.runningState == STATE_RUNNING) {
        stopTime = System.currentTimeMillis();
    }
    this.runningState = STATE_STOPPED;
}"
667,Lang,56,jira,https://issues.apache.org/jira/browse/LANG-303,High,src/java/org/apache/commons/lang/time/FastDateFormat.java,1022,1025,"// Serializing
// -----------------------------------------------------------------------
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    init();
}"
668,Lang,57,jira,https://issues.apache.org/jira/browse/LANG-304,High,src/java/org/apache/commons/lang/LocaleUtils.java,222,224,"// -----------------------------------------------------------------------
/**
 * <p>Checks if the locale specified is in the list of available locales.</p>
 *
 * @param locale the Locale object to check if it is available
 * @return true if the locale is a known locale
 */
public static boolean isAvailableLocale(Locale locale) {
    return availableLocaleList().contains(locale);
}"
669,Lang,58,jira,https://issues.apache.org/jira/browse/LANG-300,High,src/java/org/apache/commons/lang/math/NumberUtils.java,397,544,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // Fall through
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}"
670,Lang,59,jira,https://issues.apache.org/jira/browse/LANG-299,High,src/java/org/apache/commons/lang/text/StrBuilder.java,878,895,"/**
 * Appends an object to the builder padding on the right to a fixed length.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the right hand side is lost.
 * If the object is null, null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */
public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}"
671,Lang,60,jira,https://issues.apache.org/jira/browse/LANG-295,High,src/java/org/apache/commons/lang/text/StrBuilder.java,1671,1679,"// -----------------------------------------------------------------------
/**
 * Checks if the string builder contains the specified char.
 *
 * @param ch  the character to find
 * @return true if the builder contains the character
 */
public boolean contains(char ch) {
    char[] thisBuf = buffer;
    for (int i = 0; i < this.size; i++) {
        if (thisBuf[i] == ch) {
            return true;
        }
    }
    return false;
}"
672,Lang,60,jira,https://issues.apache.org/jira/browse/LANG-295,High,src/java/org/apache/commons/lang/text/StrBuilder.java,1724,1736,"/**
 * Searches the string builder to find the first reference to the specified char.
 *
 * @param ch  the character to find
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the first index of the character, or -1 if not found
 */
public int indexOf(char ch, int startIndex) {
    startIndex = (startIndex < 0 ? 0 : startIndex);
    if (startIndex >= size) {
        return -1;
    }
    char[] thisBuf = buffer;
    for (int i = startIndex; i < size; i++) {
        if (thisBuf[i] == ch) {
            return i;
        }
    }
    return -1;
}"
673,Lang,61,jira,https://issues.apache.org/jira/browse/LANG-294,High,src/java/org/apache/commons/lang/text/StrBuilder.java,1760,1787,"/**
 * Searches the string builder to find the first reference to the specified
 * string starting searching from the given index.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the first index of the string, or -1 if not found
 */
public int indexOf(String str, int startIndex) {
    startIndex = (startIndex < 0 ? 0 : startIndex);
    if (str == null || startIndex >= size) {
        return -1;
    }
    int strLen = str.length();
    if (strLen == 1) {
        return indexOf(str.charAt(0), startIndex);
    }
    if (strLen == 0) {
        return startIndex;
    }
    if (strLen > size) {
        return -1;
    }
    char[] thisBuf = buffer;
    int len = size - strLen + 1;
    outer: for (int i = startIndex; i < len; i++) {
        for (int j = 0; j < strLen; j++) {
            if (str.charAt(j) != thisBuf[i + j]) {
                continue outer;
            }
        }
        return i;
    }
    return -1;
}"
674,Lang,62,jira,https://issues.apache.org/jira/browse/LANG-292,Low,src/java/org/apache/commons/lang/Entities.java,813,873,"/**
 * <p>Unescapes the entities in a <code>String</code>.</p>
 *
 * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),
 * unescape(&quot;&amp;foo;&quot;) will return &quot;\u00A1&quot;</p>
 *
 * @param str The <code>String</code> to escape.
 * @return A new escaped <code>String</code>.
 */
public String unescape(String str) {
    int firstAmp = str.indexOf('&');
    if (firstAmp < 0) {
        return str;
    }
    StringBuffer buf = new StringBuffer(str.length());
    buf.append(str.substring(0, firstAmp));
    for (int i = firstAmp; i < str.length(); ++i) {
        char ch = str.charAt(i);
        if (ch == '&') {
            int semi = str.indexOf(';', i + 1);
            if (semi == -1) {
                buf.append(ch);
                continue;
            }
            int amph = str.indexOf('&', i + 1);
            if (amph != -1 && amph < semi) {
                // Then the text looks like &...&...;
                buf.append(ch);
                continue;
            }
            String entityName = str.substring(i + 1, semi);
            int entityValue;
            if (entityName.length() == 0) {
                entityValue = -1;
            } else if (entityName.charAt(0) == '#') {
                if (entityName.length() == 1) {
                    entityValue = -1;
                } else {
                    char charAt1 = entityName.charAt(1);
                    try {
                        if (charAt1 == 'x' || charAt1 == 'X') {
                            entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();
                        } else {
                            entityValue = Integer.parseInt(entityName.substring(1));
                        }
                        if (entityValue > 0xFFFF) {
                            entityValue = -1;
                        }
                    } catch (NumberFormatException ex) {
                        entityValue = -1;
                    }
                }
            } else {
                entityValue = this.entityValue(entityName);
            }
            if (entityValue == -1) {
                buf.append('&');
                buf.append(entityName);
                buf.append(';');
            } else {
                buf.append((char) (entityValue));
            }
            i = semi;
        } else {
            buf.append(ch);
        }
    }
    return buf.toString();
}"
675,Lang,62,jira,https://issues.apache.org/jira/browse/LANG-292,Low,src/java/org/apache/commons/lang/Entities.java,887,953,"/**
 * <p>Unescapes the escaped entities in the <code>String</code> passed and
 * writes the result to the <code>Writer</code> passed.</p>
 *
 * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.
 * @param string The <code>String</code> to write the results to; assumed to be non-null.
 * @throws IOException when <code>Writer</code> passed throws the exception from
 *                                       calls to the {@link Writer#write(int)} methods.
 *
 * @see #escape(String)
 * @see Writer
 */
public void unescape(Writer writer, String string) throws IOException {
    int firstAmp = string.indexOf('&');
    if (firstAmp < 0) {
        writer.write(string);
        return;
    }
    writer.write(string, 0, firstAmp);
    int len = string.length();
    for (int i = firstAmp; i < len; i++) {
        char c = string.charAt(i);
        if (c == '&') {
            int nextIdx = i + 1;
            int semiColonIdx = string.indexOf(';', nextIdx);
            if (semiColonIdx == -1) {
                writer.write(c);
                continue;
            }
            int amphersandIdx = string.indexOf('&', i + 1);
            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {
                // Then the text looks like &...&...;
                writer.write(c);
                continue;
            }
            String entityContent = string.substring(nextIdx, semiColonIdx);
            int entityValue = -1;
            int entityContentLen = entityContent.length();
            if (entityContentLen > 0) {
                if (entityContent.charAt(0) == '#') {
                    // escaped value content is an integer (decimal or hexidecimal)
                    if (entityContentLen > 1) {
                        char isHexChar = entityContent.charAt(1);
                        try {
                            switch(isHexChar) {
                                case 'X':
                                case 'x':
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                        break;
                                    }
                                default:
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                    }
                            }
                            if (entityValue > 0xFFFF) {
                                entityValue = -1;
                            }
                        } catch (NumberFormatException e) {
                            entityValue = -1;
                        }
                    }
                } else {
                    // escaped value content is an entity name
                    entityValue = this.entityValue(entityContent);
                }
            }
            if (entityValue == -1) {
                writer.write('&');
                writer.write(entityContent);
                writer.write(';');
            } else {
                writer.write(entityValue);
            }
            // move index up to the semi-colon
            i = semiColonIdx;
        } else {
            writer.write(c);
        }
    }
}"
676,Lang,63,jira,https://issues.apache.org/jira/browse/LANG-281,High,src/java/org/apache/commons/lang/time/DurationFormatUtils.java,262,356,"/**
 * <p>Formats the time gap as a string, using the specified format.
 * Padding the left hand side of numbers with zeroes is optional and
 * the timezone may be specified.
 *
 * @param startMillis  the start of the duration
 * @param endMillis  the end of the duration
 * @param format  the way in which to format the duration
 * @param padWithZeros whether to pad the left hand side of numbers with 0's
 * @param timezone the millis are defined in
 * @return the time as a String
 */
public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
    long millis = endMillis - startMillis;
    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
        return formatDuration(millis, format, padWithZeros);
    }
    Token[] tokens = lexx(format);
    // timezones get funky around 0, so normalizing everything to GMT
    // stops the hours being off
    Calendar start = Calendar.getInstance(timezone);
    start.setTime(new Date(startMillis));
    Calendar end = Calendar.getInstance(timezone);
    end.setTime(new Date(endMillis));
    // initial estimates
    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);
    // each initial estimate is adjusted in case it is under 0
    while (milliseconds < 0) {
        milliseconds += 1000;
        seconds -= 1;
    }
    while (seconds < 0) {
        seconds += 60;
        minutes -= 1;
    }
    while (minutes < 0) {
        minutes += 60;
        hours -= 1;
    }
    while (hours < 0) {
        hours += 24;
        days -= 1;
    }
    while (days < 0) {
        end.add(Calendar.MONTH, -1);
        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
        // days += 31; // TODO: Need tests to show this is bad and the new code is good.
        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is
        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
        // Also it's contextual - if asked for no M in the format then I should probably
        // be doing no calculating here.
        months -= 1;
        end.add(Calendar.MONTH, 1);
    }
    while (months < 0) {
        months += 12;
        years -= 1;
    }
    // number of months and get the real count and not just 0->11.
    if (!Token.containsTokenWithValue(tokens, y)) {
        if (Token.containsTokenWithValue(tokens, M)) {
            months += 12 * years;
            years = 0;
        } else {
            // TODO: this is a bit weak, needs work to know about leap years
            days += 365 * years;
            years = 0;
        }
    }
    if (!Token.containsTokenWithValue(tokens, M)) {
        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        months = 0;
    }
    if (!Token.containsTokenWithValue(tokens, d)) {
        hours += 24 * days;
        days = 0;
    }
    if (!Token.containsTokenWithValue(tokens, H)) {
        minutes += 60 * hours;
        hours = 0;
    }
    if (!Token.containsTokenWithValue(tokens, m)) {
        seconds += 60 * minutes;
        minutes = 0;
    }
    if (!Token.containsTokenWithValue(tokens, s)) {
        milliseconds += 1000 * seconds;
        seconds = 0;
    }
    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
}"
677,Lang,64,jira,https://issues.apache.org/jira/browse/LANG-259,High,src/java/org/apache/commons/lang/enums/ValuedEnum.java,182,194,"/**
 * <p>Tests for order.</p>
 *
 * <p>The default ordering is numeric by value, but this
 * can be overridden by subclasses.</p>
 *
 * <p>NOTE: From v2.2 the enums must be of the same type.
 * If the parameter is in a different class loader than this instance,
 * reflection is used to compare the values.</p>
 *
 * @see java.lang.Comparable#compareTo(Object)
 * @param other  the other object to compare to
 * @return -ve if this is less than the other object, +ve if greater than,
 *  <code>0</code> of equal
 * @throws ClassCastException if other is not an <code>Enum</code>
 * @throws NullPointerException if other is <code>null</code>
 */
public int compareTo(Object other) {
    if (other == this) {
        return 0;
    }
    if (other.getClass() != this.getClass()) {
        if (other.getClass().getName().equals(this.getClass().getName())) {
            return iValue - getValueInOtherClassLoader(other);
        }
        throw new ClassCastException(""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
    }
    return iValue - ((ValuedEnum) other).iValue;
}"
678,Lang,64,jira,https://issues.apache.org/jira/browse/LANG-259,High,src/java/org/apache/commons/lang/enums/ValuedEnum.java,202,215,"/**
 * <p>Use reflection to return an objects value.</p>
 *
 * @param other  the object to determine the value for
 * @return the value
 */
private int getValueInOtherClassLoader(Object other) {
    try {
        Method mth = other.getClass().getMethod(""getValue"", null);
        Integer value = (Integer) mth.invoke(other, null);
        return value.intValue();
    } catch (NoSuchMethodException e) {
    // ignore - should never happen
    } catch (IllegalAccessException e) {
    // ignore - should never happen
    } catch (InvocationTargetException e) {
    // ignore - should never happen
    }
    throw new IllegalStateException(""This should not happen"");
}"
679,Lang,65,jira,https://issues.apache.org/jira/browse/LANG-59,High,src/java/org/apache/commons/lang/time/DateUtils.java,619,743,"// -----------------------------------------------------------------------
/**
 * <p>Internal calculation method.</p>
 *
 * @param val  the calendar
 * @param field  the field constant
 * @param round  true to round, false to truncate
 * @throws ArithmeticException if the year is over 280 million
 */
private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    if (field == Calendar.MILLISECOND) {
        return;
    }
    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    // see http://issues.apache.org/jira/browse/LANG-59
    // 
    // Manually truncate milliseconds, seconds and minutes, rather than using
    // Calendar methods.
    Date date = val.getTime();
    long time = date.getTime();
    boolean done = false;
    // truncate milliseconds
    int millisecs = val.get(Calendar.MILLISECOND);
    if (!round || millisecs < 500) {
        time = time - millisecs;
        if (field == Calendar.SECOND) {
            done = true;
        }
    }
    // truncate seconds
    int seconds = val.get(Calendar.SECOND);
    if (!done && (!round || seconds < 30)) {
        time = time - (seconds * 1000L);
        if (field == Calendar.MINUTE) {
            done = true;
        }
    }
    // truncate minutes
    int minutes = val.get(Calendar.MINUTE);
    if (!done && (!round || minutes < 30)) {
        time = time - (minutes * 60000L);
    }
    // reset time
    if (date.getTime() != time) {
        date.setTime(time);
        val.setTime(date);
    }
    // ----------------- Fix for LANG-59 ----------------------- END ----------------
    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                // This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        // we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        // We need at add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        // We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        // These are special types of fields that require different rounding rules
        switch(field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    // If we're going to drop the DATE field's value,
                    // we want to do this our own way.
                    // We need to subtrace 1 since the date has a minimum of 1
                    offset = val.get(Calendar.DATE) - 1;
                    // bottom half of the month and should stay accordingly.
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    // Record whether we're in the top or bottom half of that range
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    // If we're going to drop the HOUR field's value,
                    // we want to do this our own way.
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            // Calculate the offset from the minimum allowed value
            offset = val.get(fields[i][0]) - min;
            // Set roundUp if this is more than half way between the minimum and maximum
            roundUp = offset > ((max - min) / 2);
        }
        // We need to remove this field
        if (offset != 0) {
            val.set(fields[i][0], val.get(fields[i][0]) - offset);
        }
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}"
680,Math,2,jira,https://issues.apache.org/jira/browse/MATH-1021,High,src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,267,269,"/**
 * {@inheritDoc}
 *
 * For population size {@code N}, number of successes {@code m}, and sample
 * size {@code n}, the mean is {@code n * m / N}.
 */
public double getNumericalMean() {
    return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
}"
681,Math,3,jira,https://issues.apache.org/jira/browse/MATH-1005,High,src/main/java/org/apache/commons/math3/util/MathArrays.java,814,875,"/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */
public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    if (len == 1) {
        // Revert to scalar multiplication.
        return a[0] * b[0];
    }
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}"
682,Math,4,jira,https://issues.apache.org/jira/browse/MATH-988,High,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java,110,130,"/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    if (v1D == null) {
        return null;
    }
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}"
683,Math,4,jira,https://issues.apache.org/jira/browse/MATH-988,High,src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java,110,134,"/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    if (v2D == null) {
        return null;
    }
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}"
684,Math,5,jira,https://issues.apache.org/jira/browse/MATH-934,Low,src/main/java/org/apache/commons/math3/complex/Complex.java,299,321,"/**
 * {@inheritDoc}
 */
public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return INF;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}"
685,Math,6,jira,https://issues.apache.org/jira/browse/MATH-949,High,src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java,191,287,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    final double[] point = getStartPoint();
    final GoalType goal = getGoalType();
    final int n = point.length;
    double[] r = computeObjectiveGradient(point);
    if (goal == GoalType.MINIMIZE) {
        for (int i = 0; i < n; i++) {
            r[i] = -r[i];
        }
    }
    // Initial search direction.
    double[] steepestDescent = preconditioner.precondition(point, r);
    double[] searchDirection = steepestDescent.clone();
    double delta = 0;
    for (int i = 0; i < n; ++i) {
        delta += r[i] * searchDirection[i];
    }
    PointValuePair current = null;
    int maxEval = getMaxEvaluations();
    while (true) {
        incrementIterationCount();
        final double objective = computeObjectiveValue(point);
        PointValuePair previous = current;
        current = new PointValuePair(point, objective);
        if (previous != null) {
            if (checker.converged(getIterations(), previous, current)) {
                // We have found an optimum.
                return current;
            }
        }
        // Find the optimal step in the search direction.
        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
        final double uB = findUpperBound(lsf, 0, initialStep);
        // XXX Last parameters is set to a value close to zero in order to
        // work around the divergence problem in the ""testCircleFitting""
        // unit test (see MATH-439).
        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
        // Subtract used up evaluations.
        maxEval -= solver.getEvaluations();
        // Validate new point.
        for (int i = 0; i < point.length; ++i) {
            point[i] += step * searchDirection[i];
        }
        r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; ++i) {
                r[i] = -r[i];
            }
        }
        // Compute beta.
        final double deltaOld = delta;
        final double[] newSteepestDescent = preconditioner.precondition(point, r);
        delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * newSteepestDescent[i];
        }
        final double beta;
        switch(updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        steepestDescent = newSteepestDescent;
        // Compute conjugate search direction.
        if (getIterations() % n == 0 || beta < 0) {
            // Break conjugation: reset search direction.
            searchDirection = steepestDescent.clone();
        } else {
            // Compute new conjugate search direction.
            for (int i = 0; i < n; ++i) {
                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
            }
        }
    }
}"
686,Math,6,jira,https://issues.apache.org/jira/browse/MATH-949,High,src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java,367,516,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        incrementIterationCount();
        // Generate and evaluate lambda offspring
        final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        final int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}"
687,Math,6,jira,https://issues.apache.org/jira/browse/MATH-949,High,src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java,172,267,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    while (true) {
        incrementIterationCount();
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
        // Default convergence check.
        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
            // User-defined stopping criteria.
            if (checker != null) {
                stop = checker.converged(getIterations(), previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}"
688,Math,6,jira,https://issues.apache.org/jira/browse/MATH-949,High,src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java,126,177,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (getIterations() > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        incrementIterationCount();
    }
}"
689,Math,6,jira,https://issues.apache.org/jira/browse/MATH-949,High,src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java,79,168,"/**
 * {@inheritDoc}
 */
@Override
public PointVectorValuePair doOptimize() {
    checkParameters();
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    // Computation will be useless without a checker (see ""for-loop"").
    if (checker == null) {
        throw new NullArgumentException();
    }
    final double[] targetValues = getTarget();
    // Number of observed data.
    final int nR = targetValues.length;
    final RealMatrix weightMatrix = getWeight();
    // Diagonal of the weight matrix.
    final double[] residualsWeights = new double[nR];
    for (int i = 0; i < nR; i++) {
        residualsWeights[i] = weightMatrix.getEntry(i, i);
    }
    final double[] currentPoint = getStartPoint();
    final int nC = currentPoint.length;
    // iterate until convergence is reached
    PointVectorValuePair current = null;
    for (boolean converged = false; !converged; ) {
        incrementIterationCount();
        // evaluate the objective function and its jacobian
        PointVectorValuePair previous = current;
        // Value of the objective function at ""currentPoint"".
        final double[] currentObjective = computeObjectiveValue(currentPoint);
        final double[] currentResiduals = computeResiduals(currentObjective);
        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
        current = new PointVectorValuePair(currentPoint, currentObjective);
        // build the linear problem
        final double[] b = new double[nC];
        final double[][] a = new double[nC][nC];
        for (int i = 0; i < nR; ++i) {
            final double[] grad = weightedJacobian.getRow(i);
            final double weight = residualsWeights[i];
            final double residual = currentResiduals[i];
            // compute the normal equation
            final double wr = weight * residual;
            for (int j = 0; j < nC; ++j) {
                b[j] += wr * grad[j];
            }
            // build the contribution matrix for measurement i
            for (int k = 0; k < nC; ++k) {
                double[] ak = a[k];
                double wgk = weight * grad[k];
                for (int l = 0; l < nC; ++l) {
                    ak[l] += wgk * grad[l];
                }
            }
        }
        try {
            // solve the linearized least squares problem
            RealMatrix mA = new BlockRealMatrix(a);
            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();
            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
            // update the estimated parameters
            for (int i = 0; i < nC; ++i) {
                currentPoint[i] += dX[i];
            }
        } catch (SingularMatrixException e) {
            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
        }
        // Check convergence.
        if (previous != null) {
            converged = checker.converged(getIterations(), previous, current);
            if (converged) {
                setCost(computeCost(currentResiduals));
                return current;
            }
        }
    }
    // Must never happen.
    throw new MathInternalError();
}"
690,Math,6,jira,https://issues.apache.org/jira/browse/MATH-949,High,src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java,283,534,"/**
 * {@inheritDoc}
 */
@Override
protected PointVectorValuePair doOptimize() {
    checkParameters();
    // Number of observed data.
    final int nR = getTarget().length;
    final double[] currentPoint = getStartPoint();
    // Number of parameters.
    final int nC = currentPoint.length;
    // arrays shared with the other private methods
    solvedCols = FastMath.min(nR, nC);
    diagR = new double[nC];
    jacNorm = new double[nC];
    beta = new double[nC];
    permutation = new int[nC];
    lmDir = new double[nC];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] oldObj = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();
    // Evaluate the function at the starting point and calculate its norm.
    double[] currentObjective = computeObjectiveValue(currentPoint);
    double[] currentResiduals = computeResiduals(currentObjective);
    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);
    double currentCost = computeCost(currentResiduals);
    // Outer loop.
    lmPar = 0;
    boolean firstIteration = true;
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    while (true) {
        incrementIterationCount();
        final PointVectorValuePair previous = current;
        // QR decomposition of the jacobian matrix
        qrDecomposition(computeWeightedJacobian(currentPoint));
        weightedResidual = weightMatrixSqrt.operate(currentResiduals);
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
        // compute Qt.res
        qTy(qtf);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // Convergence has been reached.
            setCost(currentCost);
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
        // Inner loop.
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
            tmpVec = currentObjective;
            currentObjective = oldObj;
            oldObj = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(qtf, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
            // Evaluate the function at x + p and calculate its norm.
            currentObjective = computeObjectiveValue(currentPoint);
            currentResiduals = computeResiduals(currentObjective);
            current = new PointVectorValuePair(currentPoint, currentObjective);
            currentCost = computeCost(currentResiduals);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                // tests for convergence.
                if (checker != null) {
                    // we use the vectorial convergence checker
                    if (checker.converged(getIterations(), previous, current)) {
                        setCost(currentCost);
                        return current;
                    }
                }
            } else {
                // failed iteration, reset the previous values
                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                tmpVec = currentObjective;
                currentObjective = oldObj;
                oldObj = tmpVec;
                // Reset ""current"" to previous values.
                current = new PointVectorValuePair(currentPoint, currentObjective);
            }
            // Default convergence criteria.
            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                setCost(currentCost);
                return current;
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}"
691,Math,7,jira,https://issues.apache.org/jira/browse/MATH-950,Critical,src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,296,404,"/**
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an event
 * asks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded
 * @exception NoBracketingException if the location of an event cannot be bracketed
 * @exception DimensionMismatchException if arrays dimensions do not match equations settings
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {
    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    // initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }
    // search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

        /**
         * {@inheritDoc}
         */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });
    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(state);
        }
    }
    while (!occuringEvents.isEmpty()) {
        // handle the chronologically first event
        final Iterator<EventState> iterator = occuringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();
        // restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);
        // get state at event time
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState().clone();
        // advance all event states to current time
        for (final EventState state : eventsStates) {
            state.stepAccepted(eventT, eventY);
            isLastStep = isLastStep || state.stop();
        }
        // handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }
        if (isLastStep) {
            // the event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }
        boolean needReset = false;
        for (final EventState state : eventsStates) {
            needReset = needReset || state.reset(eventT, eventY);
        }
        if (needReset) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }
        // prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);
        // check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(currentEvent);
        }
    }
    // last part of the step, after the last event
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);
    // handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }
    return currentT;
}"
692,Math,8,jira,https://issues.apache.org/jira/browse/MATH-942,High,src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java,181,195,"/**
 * Generate a random sample from the distribution.
 *
 * @param sampleSize the number of random values to generate.
 * @return an array representing the random sample.
 * @throws NotStrictlyPositiveException if {@code sampleSize} is not
 * positive.
 */
public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
    if (sampleSize <= 0) {
        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
    }
    final Object[] out = new Object[sampleSize];
    for (int i = 0; i < sampleSize; i++) {
        out[i] = sample();
    }
    return out;
}"
693,Math,9,jira,https://issues.apache.org/jira/browse/MATH-938,High,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java,86,90,"/**
 * Get a line with reversed direction.
 * @return a new instance, with reversed direction
 */
public Line revert() {
    final Line reverted = new Line(this);
    reverted.direction = reverted.direction.negate();
    return reverted;
}"
694,Math,10,jira,https://issues.apache.org/jira/browse/MATH-935,Low,src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,1382,1421,"/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */
public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    // x^2
    multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
    // y^2
    multiply(y, yOffset, y, yOffset, tmp2, 0);
    // x^2 + y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);
    // r = sqrt(x^2 + y^2)
    rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        // r + x
        add(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r + x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r + x))
        atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
            // 2 * atan(y / (r + x))
            result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        // r - x
        subtract(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r - x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r - x))
        atan(tmp1, 0, tmp2, 0);
        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))
        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
            // +/-pi - 2 * atan(y / (r - x))
            result[resultOffset + i] = -2 * tmp2[i];
        }
    }
    // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
    result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
}"
695,Math,11,jira,https://issues.apache.org/jira/browse/MATH-929,Critical,src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java,177,186,"/**
 * {@inheritDoc}
 */
public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }
    return FastMath.pow(2 * FastMath.PI, -0.5 * dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
}"
696,Math,13,jira,https://issues.apache.org/jira/browse/MATH-924,Critical,src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,561,573,"/**
 * Computes the square-root of the weight matrix.
 *
 * @param m Symmetric, positive-definite (weight) matrix.
 * @return the square-root of the weight matrix.
 */
private RealMatrix squareRoot(RealMatrix m) {
    if (m instanceof DiagonalMatrix) {
        final int dim = m.getRowDimension();
        final RealMatrix sqrtM = new DiagonalMatrix(dim);
        for (int i = 0; i < dim; i++) {
            sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
        }
        return sqrtM;
    } else {
        final EigenDecomposition dec = new EigenDecomposition(m);
        return dec.getSquareRoot();
    }
}"
697,Math,14,jira,https://issues.apache.org/jira/browse/MATH-924,Critical,src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java,266,278,"/**
 * Computes the square-root of the weight matrix.
 *
 * @param m Symmetric, positive-definite (weight) matrix.
 * @return the square-root of the weight matrix.
 */
private RealMatrix squareRoot(RealMatrix m) {
    if (m instanceof DiagonalMatrix) {
        final int dim = m.getRowDimension();
        final RealMatrix sqrtM = new DiagonalMatrix(dim);
        for (int i = 0; i < dim; i++) {
            sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
        }
        return sqrtM;
    } else {
        final EigenDecomposition dec = new EigenDecomposition(m);
        return dec.getSquareRoot();
    }
}"
698,Math,15,jira,https://issues.apache.org/jira/browse/MATH-904,High,src/main/java/org/apache/commons/math3/util/FastMath.java,1442,1600,"/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */
public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * HEX_40000000;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
        yb = y - ya;
    }
    /* Compute ln(x) */
    final double lores = log(x, lns);
    if (Double.isInfinite(lores)) {
        // don't allow this to be converted to NaN
        return lores;
    }
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * HEX_40000000;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    // result = result + result * z;
    return result;
}"
699,Math,16,jira,https://issues.apache.org/jira/browse/MATH-905,High,src/main/java/org/apache/commons/math3/util/FastMath.java,384,447,"/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */
public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            // Avoid overflow (MATH-905).
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            // Avoid overflow (MATH-905).
            final double t = exp(-0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(-x);
        }
    }
    final double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * HEX_40000000;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * HEX_40000000;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}"
700,Math,16,jira,https://issues.apache.org/jira/browse/MATH-905,High,src/main/java/org/apache/commons/math3/util/FastMath.java,453,572,"/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */
public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            // Avoid overflow (MATH-905).
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            // Avoid overflow (MATH-905).
            final double t = exp(-0.5 * x);
            return (-0.5 * t) * t;
        } else {
            return -0.5 * exp(-x);
        }
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * HEX_40000000;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * HEX_40000000;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * HEX_40000000;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * HEX_40000000;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}"
701,Math,17,jira,https://issues.apache.org/jira/browse/MATH-778,High,src/main/java/org/apache/commons/math3/dfp/Dfp.java,1602,1608,"/**
 * Multiply this by a single digit x.
 * @param x multiplicand
 * @return product of this and x
 */
public Dfp multiply(final int x) {
    if (x >= 0 && x < RADIX) {
        return multiplyFast(x);
    } else {
        return multiply(newInstance(x));
    }
}"
702,Math,18,jira,https://issues.apache.org/jira/browse/MATH-867,High,src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,925,935,"/**
 * @param x Original objective variables.
 * @return the normalized objective variables.
 */
public double[] encode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        res[i] = x[i] / diff;
    }
    return res;
}"
703,Math,18,jira,https://issues.apache.org/jira/browse/MATH-867,High,src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,951,961,"/**
 * @param x Normalized objective variables.
 * @return the original objective variables.
 */
public double[] decode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        res[i] = diff * x[i];
    }
    return res;
}"
704,Math,18,jira,https://issues.apache.org/jira/browse/MATH-867,High,src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,985,1002,"/**
 * @param x Normalized objective variables.
 * @return {@code true} if in bounds.
 */
public boolean isFeasible(final double[] x) {
    if (boundaries == null) {
        return true;
    }
    final double[] bLoEnc = encode(boundaries[0]);
    final double[] bHiEnc = encode(boundaries[1]);
    for (int i = 0; i < x.length; i++) {
        if (x[i] < bLoEnc[i]) {
            return false;
        }
        if (x[i] > bHiEnc[i]) {
            return false;
        }
    }
    return true;
}"
705,Math,19,jira,https://issues.apache.org/jira/browse/MATH-865,High,src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,504,574,"/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
            // because mixed cases are not supported by the current code.
            throw new MathUnsupportedOperationException();
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
            // Abort early if the normalization will overflow (cf. ""encode"" method).
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
                    final double max = Double.MAX_VALUE + boundaries[0][i];
                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);
                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);
                    e.getContext().addMessage(LocalizedFormats.INDEX, i);
                    throw e;
                }
            }
        }
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}"
706,Math,20,jira,https://issues.apache.org/jira/browse/MATH-864,High,src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,920,924,"/**
 * @param x Normalized objective variables.
 * @return the original objective variables, possibly repaired.
 */
public double[] repairAndDecode(final double[] x) {
    return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x);
}"
707,Math,22,jira,https://issues.apache.org/jira/browse/MATH-859,High,src/main/java/org/apache/commons/math3/distribution/FDistribution.java,274,276,"/**
 * {@inheritDoc}
 */
public boolean isSupportLowerBoundInclusive() {
    return false;
}"
708,Math,22,jira,https://issues.apache.org/jira/browse/MATH-859,High,src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java,183,185,"/**
 * {@inheritDoc}
 */
public boolean isSupportUpperBoundInclusive() {
    return true;
}"
709,Math,23,jira,https://issues.apache.org/jira/browse/MATH-855,Low,src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,114,288,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).
    UnivariatePointValuePair best = current;
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            best = best(best, best(current, previous, isMinim), isMinim);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best;
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(best, best(current, previous, isMinim), isMinim);
        }
        ++iter;
    }
}"
710,Math,24,jira,https://issues.apache.org/jira/browse/MATH-855,Low,src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,108,271,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}"
711,Math,25,jira,https://issues.apache.org/jira/browse/MATH-844,Low,src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java,257,332,"/**
 * Estimate a first guess of the amplitude and angular frequency.
 * This method assumes that the {@link #sortObservations()} method
 * has been called previously.
 *
 * @throws ZeroException if the abscissa range is zero.
 * @throws MathIllegalStateException when the guessing procedure cannot
 * produce sensible results.
 */
private void guessAOmega() {
    // initialize the sums for the linear model between the two integrals
    double sx2 = 0;
    double sy2 = 0;
    double sxy = 0;
    double sxz = 0;
    double syz = 0;
    double currentX = observations[0].getX();
    double currentY = observations[0].getY();
    double f2Integral = 0;
    double fPrime2Integral = 0;
    final double startX = currentX;
    for (int i = 1; i < observations.length; ++i) {
        // one step forward
        final double previousX = currentX;
        final double previousY = currentY;
        currentX = observations[i].getX();
        currentY = observations[i].getY();
        // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
        // considering a linear model for f (and therefore constant f')
        final double dx = currentX - previousX;
        final double dy = currentY - previousY;
        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
        final double fPrime2StepIntegral = dy * dy / dx;
        final double x = currentX - startX;
        f2Integral += f2StepIntegral;
        fPrime2Integral += fPrime2StepIntegral;
        sx2 += x * x;
        sy2 += f2Integral * f2Integral;
        sxy += x * f2Integral;
        sxz += x * fPrime2Integral;
        syz += f2Integral * fPrime2Integral;
    }
    // compute the amplitude and pulsation coefficients
    double c1 = sy2 * sxz - sxy * syz;
    double c2 = sxy * sxz - sx2 * syz;
    double c3 = sx2 * sy2 - sxy * sxy;
    if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
        final int last = observations.length - 1;
        // Range of the observations, assuming that the
        // observations are sorted.
        final double xRange = observations[last].getX() - observations[0].getX();
        if (xRange == 0) {
            throw new ZeroException();
        }
        omega = 2 * Math.PI / xRange;
        double yMin = Double.POSITIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (int i = 1; i < observations.length; ++i) {
            final double y = observations[i].getY();
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        a = 0.5 * (yMax - yMin);
    } else {
        if (c2 == 0) {
            // procedure cannot produce sensible results.
            throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
        }
        a = FastMath.sqrt(c1 / c2);
        omega = FastMath.sqrt(c2 / c3);
    }
}"
712,Math,27,jira,https://issues.apache.org/jira/browse/MATH-835,Low,src/main/java/org/apache/commons/math3/fraction/Fraction.java,596,598,"/**
 * <p>
 * Gets the fraction percentage as a <tt>double</tt>. This calculates the
 * fraction as the numerator divided by denominator multiplied by 100.
 * </p>
 *
 * @return the fraction percentage as a <tt>double</tt>.
 */
public double percentageValue() {
    return 100 * doubleValue();
}"
713,Math,28,jira,https://issues.apache.org/jira/browse/MATH-828,High,src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,90,158,"/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(SimplexTableau tableau, final int col) {
    // create a list of all the rows that tie for the lowest score in the minimum ratio test
    List<Integer> minRatioPositions = new ArrayList<Integer>();
    double minRatio = Double.MAX_VALUE;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            final double ratio = rhs / entry;
            // check if the entry is strictly equal to the current min ratio
            // do not use a ulp/epsilon check
            final int cmp = Double.compare(ratio, minRatio);
            if (cmp == 0) {
                minRatioPositions.add(i);
            } else if (cmp < 0) {
                minRatio = ratio;
                minRatioPositions = new ArrayList<Integer>();
                minRatioPositions.add(i);
            }
        }
    }
    if (minRatioPositions.size() == 0) {
        return null;
    } else if (minRatioPositions.size() > 1) {
        // 1. check if there's an artificial variable that can be forced out of the basis
        if (tableau.getNumArtificialVariables() > 0) {
            for (Integer row : minRatioPositions) {
                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                    int column = i + tableau.getArtificialVariableOffset();
                    final double entry = tableau.getEntry(row, column);
                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                        return row;
                    }
                }
            }
        }
        // This heuristic is based on empirical data gathered while investigating MATH-828.
        if (getIterations() < getMaxIterations() / 2) {
            Integer minRow = null;
            int minIndex = tableau.getWidth();
            for (Integer row : minRatioPositions) {
                int i = tableau.getNumObjectiveFunctions();
                for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
                    if (row == tableau.getBasicRow(i)) {
                        if (i < minIndex) {
                            minIndex = i;
                            minRow = row;
                        }
                    }
                }
            }
            return minRow;
        }
    }
    return minRatioPositions.get(0);
}"
714,Math,29,jira,https://issues.apache.org/jira/browse/MATH-803,High,src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java,340,354,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    /*
         * MATH-803: it is not sufficient to loop through non zero entries of
         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
         * this[i] / v[i] = NaN, and not 0d.
         */
    final int n = getDimension();
    for (int i = 0; i < n; i++) {
        res.setEntry(i, this.getEntry(i) / v.getEntry(i));
    }
    return res;
}"
715,Math,29,jira,https://issues.apache.org/jira/browse/MATH-803,High,src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java,357,386,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    /*
         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
         * which allows to consider only the non-zero entries of this. However,
         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
         *
         * These special cases are handled below.
         */
    if (v.isNaN() || v.isInfinite()) {
        final int n = getDimension();
        for (int i = 0; i < n; i++) {
            final double y = v.getEntry(i);
            if (Double.isNaN(y)) {
                res.setEntry(i, Double.NaN);
            } else if (Double.isInfinite(y)) {
                final double x = this.getEntry(i);
                res.setEntry(i, x * y);
            }
        }
    }
    return res;
}"
716,Math,30,jira,https://issues.apache.org/jira/browse/MATH-790,Low,src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,168,184,"/**
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computed
 * due to a convergence error
 * @throws MaxCountExceededException if the maximum number of
 * iterations is exceeded
 */
private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException {
    final double n1n2prod = n1 * n2;
    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
    final double EU = n1n2prod / 2.0;
    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;
    final double z = (Umin - EU) / FastMath.sqrt(VarU);
    final NormalDistribution standardNormal = new NormalDistribution(0, 1);
    return 2 * standardNormal.cumulativeProbability(z);
}"
717,Math,31,jira,https://issues.apache.org/jira/browse/MATH-718,High,src/main/java/org/apache/commons/math3/util/ContinuedFraction.java,123,179,"/**
 * <p>
 * Evaluates the continued fraction at the value x.
 * </p>
 *
 * <p>
 * The implementation of this method is based on the modified Lentz algorithm as described
 * on page 18 ff. in:
 * <ul>
 * <li>
 *   I. J. Thompson,  A. R. Barnett. ""Coulomb and Bessel Functions of Complex Arguments and Order.""
 *   <a target=""_blank"" href=""http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf"">
 *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>
 * </li>
 * </ul>
 * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in
 * <a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">Continued Fraction / MathWorld</a>.
 * </p>
 *
 * @param x the evaluation point.
 * @param epsilon maximum error allowed.
 * @param maxIterations maximum number of convergents
 * @return the value of the continued fraction evaluated at x.
 * @throws ConvergenceException if the algorithm fails to converge.
 */
public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);
    // use the value of small as epsilon criteria for zero checks
    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }
    int n = 1;
    double dPrev = 0.0;
    double cPrev = hPrev;
    double hN = hPrev;
    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);
        double dN = a + b * dPrev;
        if (Precision.equals(dN, 0.0, small)) {
            dN = small;
        }
        double cN = a + b / cPrev;
        if (Precision.equals(cN, 0.0, small)) {
            cN = small;
        }
        dN = 1 / dN;
        final double deltaN = cN * dN;
        hN = hPrev * deltaN;
        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }
        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }
        dPrev = dN;
        cPrev = cN;
        hPrev = hN;
        n++;
    }
    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }
    return hN;
}"
718,Math,32,jira,https://issues.apache.org/jira/browse/MATH-780,High,src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java,129,181,"/**
 * {@inheritDoc}
 */
@Override
protected void computeGeometricalProperties() {
    final Vector2D[][] v = getVertices();
    if (v.length == 0) {
        final BSPTree<Euclidean2D> tree = getTree(false);
        if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
            // the instance covers the whole space
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(0);
            setBarycenter(new Vector2D(0, 0));
        }
    } else if (v[0][0] == null) {
        // there is at least one open-loop: the polygon is infinite
        setSize(Double.POSITIVE_INFINITY);
        setBarycenter(Vector2D.NaN);
    } else {
        // all loops are closed, we compute some integrals around the shape
        double sum = 0;
        double sumX = 0;
        double sumY = 0;
        for (Vector2D[] loop : v) {
            double x1 = loop[loop.length - 1].getX();
            double y1 = loop[loop.length - 1].getY();
            for (final Vector2D point : loop) {
                final double x0 = x1;
                final double y0 = y1;
                x1 = point.getX();
                y1 = point.getY();
                final double factor = x0 * y1 - y0 * x1;
                sum += factor;
                sumX += factor * (x0 + x1);
                sumY += factor * (y0 + y1);
            }
        }
        if (sum < 0) {
            // the polygon as a finite outside surrounded by an infinite inside
            setSize(Double.POSITIVE_INFINITY);
            setBarycenter(Vector2D.NaN);
        } else {
            setSize(sum / 2);
            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
        }
    }
}"
719,Math,33,jira,https://issues.apache.org/jira/browse/MATH-781,High,src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,327,367,"/**
 * Removes the phase 1 objective function, positive cost non-artificial variables,
 * and the non-basic artificial variables from this tableau.
 */
protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }
    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);
    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, epsilon) > 0) {
            columnsToDrop.add(i);
        }
    }
    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }
    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }
    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}"
720,Math,34,jira,https://issues.apache.org/jira/browse/MATH-779,High,src/main/java/org/apache/commons/math3/genetics/ListPopulation.java,208,210,"/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
public Iterator<Chromosome> iterator() {
    return getChromosomes().iterator();
}"
721,Math,36,jira,https://issues.apache.org/jira/browse/MATH-744,High,src/main/java/org/apache/commons/math/fraction/BigFraction.java,683,695,"/**
 * <p>
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * </p>
 *
 * @return the fraction as a <tt>double</tt>
 * @see java.lang.Number#doubleValue()
 */
@Override
public double doubleValue() {
    double result = numerator.doubleValue() / denominator.doubleValue();
    if (Double.isNaN(result)) {
        // Numerator and/or denominator must be out of range:
        // Calculate how far to shift them to put them in range.
        int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Double.MAX_EXPONENT;
        result = numerator.shiftRight(shift).doubleValue() / denominator.shiftRight(shift).doubleValue();
    }
    return result;
}"
722,Math,36,jira,https://issues.apache.org/jira/browse/MATH-744,High,src/main/java/org/apache/commons/math/fraction/BigFraction.java,736,748,"/**
 * <p>
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * </p>
 *
 * @return the fraction as a <tt>float</tt>.
 * @see java.lang.Number#floatValue()
 */
@Override
public float floatValue() {
    float result = numerator.floatValue() / denominator.floatValue();
    if (Double.isNaN(result)) {
        // Numerator and/or denominator must be out of range:
        // Calculate how far to shift them to put them in range.
        int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Float.MAX_EXPONENT;
        result = numerator.shiftRight(shift).floatValue() / denominator.shiftRight(shift).floatValue();
    }
    return result;
}"
723,Math,37,jira,https://issues.apache.org/jira/browse/MATH-722,Low,src/main/java/org/apache/commons/math/complex/Complex.java,1017,1034,"/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i
 *   tan(&plusmn;INFINITY + bi) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */
public Complex tan() {
    if (isNaN || Double.isInfinite(real)) {
        return NaN;
    }
    if (imaginary > 20.0) {
        return createComplex(0.0, 1.0);
    }
    if (imaginary < -20.0) {
        return createComplex(0.0, -1.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}"
724,Math,37,jira,https://issues.apache.org/jira/browse/MATH-722,Low,src/main/java/org/apache/commons/math/complex/Complex.java,1068,1084,"/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(a &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */
public Complex tanh() {
    if (isNaN || Double.isInfinite(imaginary)) {
        return NaN;
    }
    if (real > 20.0) {
        return createComplex(1.0, 0.0);
    }
    if (real < -20.0) {
        return createComplex(-1.0, 0.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}"
725,Math,38,jira,https://issues.apache.org/jira/browse/MATH-728,High,src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,1582,1755,"// altmov
// ----------------------------------------------------------------------------------------
/**
 *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
 *     BMAT and ZMAT for the first iteration, and it maintains the values of
 *     NF and KOPT. The vector X is also changed by PRELIM.
 *
 *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the
 *       same as the corresponding arguments in SUBROUTINE BOBYQA.
 *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU
 *       are the same as the corresponding arguments in BOBYQB, the elements
 *       of SL and SU being set in BOBYQA.
 *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but
 *       it is set by PRELIM to the gradient of the quadratic model at XBASE.
 *       If XOPT is nonzero, BOBYQB will change it to its usual value later.
 *     NF is maintaned as the number of calls of CALFUN so far.
 *     KOPT will be such that the least calculated value of F so far is at
 *       the point XPT(KOPT,.)+XBASE in the space of the variables.
 *
 * @param lowerBound Lower bounds.
 * @param upperBound Upper bounds.
 */
private void prelim(double[] lowerBound, double[] upperBound) {
    // XXX
    printMethod();
    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();
    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;
    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }
    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).
    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    do {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                    // XXX
                    throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                    // XXX
                    throw new PathIsExploredException();
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                    // XXX
                    throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
            // throw new PathIsExploredException(); // XXX
            }
            final int iptMinus1 = ipt - 1;
            final int jptMinus1 = jpt - 1;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }
        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }
        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        // nfm + 1
        final int numEval = getEvaluations();
        fAtInterpolationPoints.setEntry(nfm, f);
        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }
        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                    // XXX
                    throw new PathIsExploredException();
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }
        // Set the off-diagonal second derivatives of the Lagrange functions and
        // the initial quadratic model.
        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);
            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
        // throw new PathIsExploredException(); // XXX
        }
    } while (getEvaluations() < npt);
}"
726,Math,39,jira,https://issues.apache.org/jira/browse/MATH-727,High,src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,190,337,"/**
 * {@inheritDoc}
 */
@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            if (forward) {
                if (stepStart + stepSize >= t) {
                    stepSize = t - stepStart;
                }
            } else {
                if (stepStart + stepSize <= t) {
                    stepSize = t - stepStart;
                }
            }
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}"
727,Math,40,jira,https://issues.apache.org/jira/browse/MATH-716,Low,src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java,142,351,"/**
 * {@inheritDoc}
 */
@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            final int p = agingA - MAXIMAL_AGING;
            final double weightA = (1 << p) - 1;
            final double weightB = p + 1;
            targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            final int p = agingB - MAXIMAL_AGING;
            final double weightA = p + 1;
            final double weightB = (1 << p) - 1;
            targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        // (by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}"
728,Math,41,jira,https://issues.apache.org/jira/browse/MATH-704,High,src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java,501,532,"/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = begin; i < begin + length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}"
729,Math,42,jira,https://issues.apache.org/jira/browse/MATH-713,High,src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,396,427,"/**
 * Get the current solution.
 *
 * @return current solution
 */
protected RealPointValuePair getSolution() {
    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
    Set<Integer> basicRows = new HashSet<Integer>();
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    for (int i = 0; i < coefficients.length; i++) {
        int colIndex = columnLabels.indexOf(""x"" + i);
        if (colIndex < 0) {
            coefficients[i] = 0;
            continue;
        }
        Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRow == 0) {
            // if the basic row is found to be the objective function row
            // set the coefficient to 0 -> this case handles unconstrained
            // variables that are still part of the objective function
            coefficients[i] = 0;
        } else if (basicRows.contains(basicRow)) {
            // if multiple variables can take a given value
            // then we choose the first and set the rest equal to 0
            coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
        } else {
            basicRows.add(basicRow);
            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
730,Math,43,jira,https://issues.apache.org/jira/browse/MATH-691,Low,src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,149,168,"/**
 * Add a value to the data
 * @param value the value to add
 */
public void addValue(double value) {
    sumImpl.increment(value);
    sumsqImpl.increment(value);
    minImpl.increment(value);
    maxImpl.increment(value);
    sumLogImpl.increment(value);
    secondMoment.increment(value);
    // need to increment these
    if (meanImpl != mean) {
        meanImpl.increment(value);
    }
    if (varianceImpl != variance) {
        varianceImpl.increment(value);
    }
    if (geoMeanImpl != geoMean) {
        geoMeanImpl.increment(value);
    }
    n++;
}"
731,Math,44,jira,https://issues.apache.org/jira/browse/MATH-695,High,src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,274,379,"/**
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an event
 * asks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MathIllegalStateException if the value of one event state cannot be evaluated
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {
    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    // initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }
    // search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

        /**
         * {@inheritDoc}
         */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });
    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(state);
        }
    }
    while (!occuringEvents.isEmpty()) {
        // handle the chronologically first event
        final Iterator<EventState> iterator = occuringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();
        // restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);
        // trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();
        // handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }
        if (isLastStep) {
            // the event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            for (final EventState remaining : occuringEvents) {
                remaining.stepAccepted(eventT, eventY);
            }
            return eventT;
        }
        if (currentEvent.reset(eventT, eventY)) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            for (final EventState remaining : occuringEvents) {
                remaining.stepAccepted(eventT, eventY);
            }
            return eventT;
        }
        // prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);
        // check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(currentEvent);
        }
    }
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);
    // handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }
    return currentT;
}"
732,Math,46,jira,https://issues.apache.org/jira/browse/MATH-657,Low,src/main/java/org/apache/commons/math/complex/Complex.java,251,281,"/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */
public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.isZero) {
        // return isZero ? NaN : INF; // See MATH-657
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}"
733,Math,46,jira,https://issues.apache.org/jira/browse/MATH-657,Low,src/main/java/org/apache/commons/math/complex/Complex.java,291,304,"/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */
public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        // return isZero ? NaN : INF; // See MATH-657
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}"
734,Math,47,jira,https://issues.apache.org/jira/browse/MATH-657,Low,src/main/java/org/apache/commons/math/complex/Complex.java,251,280,"/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */
public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.isZero) {
        return isZero ? NaN : INF;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}"
735,Math,47,jira,https://issues.apache.org/jira/browse/MATH-657,Low,src/main/java/org/apache/commons/math/complex/Complex.java,290,302,"/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */
public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}"
736,Math,48,jira,https://issues.apache.org/jira/browse/MATH-631,High,src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,129,254,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // for the maximum number of iterations to be exceeded.
                    if (x == x1) {
                        throw new ConvergenceException();
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}"
737,Math,49,jira,https://issues.apache.org/jira/browse/MATH-645,High,src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,342,351,"/**
 * {@inheritDoc}
 */
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}"
738,Math,49,jira,https://issues.apache.org/jira/browse/MATH-645,High,src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,354,364,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeDivide(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v[iter.key()]);
    }
    return res;
}"
739,Math,49,jira,https://issues.apache.org/jira/browse/MATH-645,High,src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,367,376,"/**
 * {@inheritDoc}
 */
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}"
740,Math,49,jira,https://issues.apache.org/jira/browse/MATH-645,High,src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,379,389,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}"
741,Math,50,jira,https://issues.apache.org/jira/browse/MATH-631,High,src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,128,249,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Nothing.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}"
742,Math,51,jira,https://issues.apache.org/jira/browse/MATH-631,High,src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,128,256,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (x == x1) {
                        final double delta = FastMath.max(rtol * FastMath.abs(x1), atol);
                        // Update formula cannot make any progress: Update the
                        // search interval.
                        x0 = 0.5 * (x0 + x1 - delta);
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}"
743,Math,53,jira,https://issues.apache.org/jira/browse/MATH-618,High,src/main/java/org/apache/commons/math/complex/Complex.java,150,158,"/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    if (isNaN || rhs.isNaN) {
        return NaN;
    }
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}"
744,Math,54,jira,https://issues.apache.org/jira/browse/MATH-567,Low,src/main/java/org/apache/commons/math/dfp/Dfp.java,2306,2390,"/**
 * Convert the instance into a double.
 * @return a double approximating the instance
 * @see #toSplitDouble()
 */
public double toDouble() {
    if (isInfinite()) {
        if (lessThan(getZero())) {
            return Double.NEGATIVE_INFINITY;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (isNaN()) {
        return Double.NaN;
    }
    Dfp y = this;
    boolean negate = false;
    int cmp0 = compare(this, getZero());
    if (cmp0 == 0) {
        return sign < 0 ? -0.0 : +0.0;
    } else if (cmp0 < 0) {
        y = negate();
        negate = true;
    }
    /* Find the exponent, first estimate by integer log10, then adjust.
         Should be faster than doing a natural logarithm.  */
    int exponent = (int) (y.log10() * 3.32);
    if (exponent < 0) {
        exponent--;
    }
    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
        tempDfp = tempDfp.multiply(2);
        exponent++;
    }
    exponent--;
    /* We have the exponent, now work on the mantissa */
    y = y.divide(DfpMath.pow(getTwo(), exponent));
    if (exponent > -1023) {
        y = y.subtract(getOne());
    }
    if (exponent < -1074) {
        return 0;
    }
    if (exponent > 1023) {
        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
    }
    y = y.multiply(newInstance(4503599627370496l)).rint();
    String str = y.toString();
    str = str.substring(0, str.length() - 1);
    long mantissa = Long.parseLong(str);
    if (mantissa == 4503599627370496L) {
        // Handle special case where we round up to next power of two
        mantissa = 0;
        exponent++;
    }
    /* Its going to be subnormal, so make adjustments */
    if (exponent <= -1023) {
        exponent--;
    }
    while (exponent < -1023) {
        exponent++;
        mantissa >>>= 1;
    }
    long bits = mantissa | ((exponent + 1023L) << 52);
    double x = Double.longBitsToDouble(bits);
    if (negate) {
        x = -x;
    }
    return x;
}"
745,Math,55,jira,https://issues.apache.org/jira/browse/MATH-554,High,src/main/java/org/apache/commons/math/geometry/Vector3D.java,457,492,"/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    final double n1 = v1.getNormSq();
    final double n2 = v2.getNormSq();
    if ((n1 * n2) < MathUtils.SAFE_MIN) {
        return ZERO;
    }
    // rescale both vectors without losing precision,
    // to ensure their norm are the same order of magnitude
    final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
    final double x1 = FastMath.scalb(v1.x, -deltaExp);
    final double y1 = FastMath.scalb(v1.y, -deltaExp);
    final double z1 = FastMath.scalb(v1.z, -deltaExp);
    final double x2 = FastMath.scalb(v2.x, deltaExp);
    final double y2 = FastMath.scalb(v2.y, deltaExp);
    final double z2 = FastMath.scalb(v2.z, deltaExp);
    // we reduce cancellation errors by preconditioning,
    // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
    // v3 without loss of precision. See Kahan lecture
    // ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
    // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
    // compute rho as an 8 bits approximation of v1.v2 / v2.v2
    final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
    final double rho = FastMath.rint(256 * ratio) / 256;
    final double x3 = x1 - rho * x2;
    final double y3 = y1 - rho * y2;
    final double z3 = z1 - rho * z2;
    // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
}"
746,Math,56,jira,https://issues.apache.org/jira/browse/MATH-552,Low,src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,216,240,"/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */
public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    indices[last] = index - count;
    return indices;
}"
747,Math,57,jira,https://issues.apache.org/jira/browse/MATH-546,Low,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,161,198,"/**
 * Use K-means++ to choose the initial centers.
 *
 * @param <T> type of the points to cluster
 * @param points the points to choose the initial centers from
 * @param k the number of centers to choose
 * @param random random generator to use
 * @return the initial centers
 */
private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {
    final List<T> pointSet = new ArrayList<T>(points);
    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();
    // Choose one center uniformly at random from among the data points.
    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
    resultSet.add(new Cluster<T>(firstPoint));
    final double[] dx2 = new double[pointSet.size()];
    while (resultSet.size() < k) {
        // For each data point x, compute D(x), the distance between x and
        // the nearest center that has already been chosen.
        double sum = 0;
        for (int i = 0; i < pointSet.size(); i++) {
            final T p = pointSet.get(i);
            final Cluster<T> nearest = getNearestCluster(resultSet, p);
            final double d = p.distanceFrom(nearest.getCenter());
            sum += d * d;
            dx2[i] = sum;
        }
        // Add one new data point as a center. Each point x is chosen with
        // probability proportional to D(x)2
        final double r = random.nextDouble() * sum;
        for (int i = 0; i < dx2.length; i++) {
            if (dx2[i] >= r) {
                final T p = pointSet.remove(i);
                resultSet.add(new Cluster<T>(p));
                break;
            }
        }
    }
    return resultSet;
}"
748,Math,58,jira,https://issues.apache.org/jira/browse/MATH-519,High,src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java,119,122,"/**
 * Fits a Gaussian function to the observed points.
 *
 * @return the parameters of the Gaussian function that best fits the
 * observed points (in the same order as above).
 */
public double[] fit() {
    final double[] guess = (new ParameterGuesser(getObservations())).guess();
    return fit(guess);
}"
749,Math,59,jira,https://issues.apache.org/jira/browse/MATH-482,High,src/main/java/org/apache/commons/math/util/FastMath.java,3481,3483,"/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */
public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
}"
750,Math,60,jira,https://issues.apache.org/jira/browse/MATH-414,Low,src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,124,131,"/**
 * For this distribution, {@code X}, this method returns {@code P(X < x)}.
 * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,
 * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.
 *
 * @param x Value at which the CDF is evaluated.
 * @return CDF evaluated at {@code x}.
 * @throws MathException if the algorithm fails to converge
 */
public double cumulativeProbability(double x) throws MathException {
    final double dev = x - mean;
    if (FastMath.abs(dev) > 40 * standardDeviation) {
        return dev < 0 ? 0.0d : 1.0d;
    }
    return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0))));
}"
751,Math,62,jira,https://issues.apache.org/jira/browse/MATH-413,High,src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java,142,147,"/**
 * {@inheritDoc}
 */
public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    return optimize(f, goal, min, max, min + 0.5 * (max - min));
}"
752,Math,62,jira,https://issues.apache.org/jira/browse/MATH-413,High,src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java,150,182,"/**
 * {@inheritDoc}
 */
public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {
    optima = new UnivariateRealPointValuePair[starts];
    totalEvaluations = 0;
    // Multi-start loop.
    for (int i = 0; i < starts; ++i) {
        try {
            final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
            optima[i] = optimizer.optimize(f, goal, min, max, s);
        } catch (FunctionEvaluationException fee) {
            optima[i] = null;
        } catch (ConvergenceException ce) {
            optima[i] = null;
        }
        final int usedEvaluations = optimizer.getEvaluations();
        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
        totalEvaluations += usedEvaluations;
    }
    sortPairs(goal);
    if (optima[0] == null) {
        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);
    }
    // Return the point with the best objective function value.
    return optima[0];
}"
753,Math,63,jira,https://issues.apache.org/jira/browse/MATH-370,Low,src/main/java/org/apache/commons/math/util/MathUtils.java,416,418,"/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */
public static boolean equals(double x, double y) {
    return equals(x, y, 1);
}"
754,Math,64,jira,https://issues.apache.org/jira/browse/MATH-405,High,src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,240,478,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] oldObj = new double[rows];
    double[] qtf = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        for (int i = 0; i < rows; i++) {
            qtf[i] = residuals[i];
        }
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(qtf);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * qtf[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            tmpVec = objective;
            objective = oldObj;
            oldObj = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(qtf, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
                current = new VectorialPointValuePair(point, objective);
                // tests for convergence.
                if (checker != null) {
                    // we use the vectorial convergence checker
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                }
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
                tmpVec = objective;
                objective = oldObj;
                oldObj = tmpVec;
            }
            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}"
755,Math,65,jira,https://issues.apache.org/jira/browse/MATH-377,High,src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java,239,241,"/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */
public double getRMS() {
    return Math.sqrt(getChiSquare() / rows);
}"
756,Math,65,jira,https://issues.apache.org/jira/browse/MATH-377,High,src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java,249,256,"/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */
public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual * residualsWeights[i];
    }
    return chiSquare;
}"
757,Math,66,jira,https://issues.apache.org/jira/browse/MATH-395,High,src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java,55,60,"/**
 * Perform the optimization.
 *
 * @return the optimum.
 */
protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {
    return localMin(getGoalType() == GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());
}"
758,Math,66,jira,https://issues.apache.org/jira/browse/MATH-395,High,src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java,86,233,"/**
 * Find the minimum of the function within the interval {@code (lo, hi)}.
 *
 * If the function is defined on the interval {@code (lo, hi)}, then
 * this method finds an approximation {@code x} to the point at which
 * the function attains its minimum.<br/>
 * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}
 * and the function is never evaluated at two points closer together than
 * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and
 * preferable not much less than <em>sqrt(macheps)</em>, where
 * <em>macheps</em> is the relative machine precision. {@code t} should be
 * positive.
 * @param isMinim {@code true} when minimizing the function.
 * @param lo Lower bound of the interval.
 * @param mid Point inside the interval {@code [lo, hi]}.
 * @param hi Higher bound of the interval.
 * @param eps Relative accuracy.
 * @param t Absolute accuracy.
 * @return the optimum point.
 * @throws MaxIterationsExceededException if the maximum iteration count
 * is exceeded.
 * @throws FunctionEvaluationException if an error occurs evaluating
 * the function.
 */
private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {
    if (eps <= 0) {
        throw new NotStrictlyPositiveException(eps);
    }
    if (t <= 0) {
        throw new NotStrictlyPositiveException(t);
    }
    double a, b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    while (true) {
        double m = 0.5 * (a + b);
        final double tol1 = eps * Math.abs(x) + t;
        final double tol2 = 2 * tol1;
        // Check stopping criterion.
        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (Math.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (Math.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || w == x) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || v == x || v == w) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // termination
            setFunctionValue(isMinim ? fx : -fx);
            return x;
        }
        incrementIterationsCounter();
    }
}"
759,Math,67,jira,https://issues.apache.org/jira/browse/MATH-393,Low,src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java,91,93,"/**
 * {@inheritDoc}
 */
public double getFunctionValue() {
    return optimaValues[0];
}"
760,Math,67,jira,https://issues.apache.org/jira/browse/MATH-393,Low,src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java,96,98,"/**
 * {@inheritDoc}
 */
public double getResult() {
    return optima[0];
}"
761,Math,68,jira,https://issues.apache.org/jira/browse/MATH-362,High,src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,220,454,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            // tests for convergence.
            if (checker != null) {
                // we use the vectorial convergence checker
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            } else {
                // we use the Levenberg-Marquardt specific convergence parameters
                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", orthoTolerance);
            }
        }
    }
}"
762,Math,69,jira,https://issues.apache.org/jira/browse/MATH-371,High,src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,160,176,"/**
 * Returns a matrix of p-values associated with the (two-sided) null
 * hypothesis that the corresponding correlation coefficient is zero.
 * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability
 * that a random variable distributed as <code>t<sub>n-2</sub></code> takes
 * a value with absolute value greater than or equal to <br>
 * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>
 * <p>The values in the matrix are sometimes referred to as the
 * <i>significance</i> of the corresponding correlation coefficients.</p>
 *
 * @return matrix of p-values
 * @throws MathException if an error occurs estimating probabilities
 */
public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                out[i][j] = 2 * tDistribution.cumulativeProbability(-t);
            }
        }
    }
    return new BlockRealMatrix(out);
}"
763,Math,70,jira,https://issues.apache.org/jira/browse/MATH-369,Low,src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java,70,73,"/**
 * {@inheritDoc}
 */
public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(f, min, max);
}"
764,Math,71,jira,https://issues.apache.org/jira/browse/MATH-358,Critical,src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,191,370,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[y0.length];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
                    }
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // we cannot simply truncate the step, reject the current computation
                        // and let the loop compute another state with the truncated step.
                        // it is so small (much probably exactly 0 due to limited accuracy)
                        // that the code above would fail handling it.
                        // So we set up an artificial 0 size step by copying states
                        interpolator.storeTime(stepStart);
                        System.arraycopy(y, 0, yTmp, 0, y0.length);
                        hNew = 0;
                        stepSize = 0;
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}"
765,Math,71,jira,https://issues.apache.org/jira/browse/MATH-358,Critical,src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java,95,223,"/**
 * {@inheritDoc}
 */
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        for (boolean loop = true; loop; ) {
            // first stage
            computeDerivatives(stepStart, y, yDotK[0]);
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                    // we cannot simply truncate the step, reject the current computation
                    // and let the loop compute another state with the truncated step.
                    // it is so small (much probably exactly 0 due to limited accuracy)
                    // that the code above would fail handling it.
                    // So we set up an artificial 0 size step by copying states
                    interpolator.storeTime(stepStart);
                    System.arraycopy(y, 0, yTmp, 0, y0.length);
                    stepSize = 0;
                    loop = false;
                } else {
                    // reject the step to match exactly the next switch time
                    stepSize = dt;
                }
            } else {
                loop = false;
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (manager.reset(stepStart, y) && !lastStep) {
            // some events handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        // make sure step size is set to default before next step
        stepSize = forward ? step : -step;
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}"
766,Math,72,jira,https://issues.apache.org/jira/browse/MATH-344,Critical,src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,98,144,"/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(min, 0);
        return result;
    }
    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(max, 0);
        return result;
    }
    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }
    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}"
767,Math,73,jira,https://issues.apache.org/jira/browse/MATH-343,Critical,src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,98,144,"/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }
    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}"
768,Math,74,jira,https://issues.apache.org/jira/browse/MATH-338,High,src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,191,362,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[y0.length];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
                    }
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // rejecting the step would lead to a too small next step, we accept it
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}"
769,Math,75,jira,https://issues.apache.org/jira/browse/MATH-329,Low,src/main/java/org/apache/commons/math/stat/Frequency.java,301,304,"// -------------------------------------------------------------
/**
 * Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).
 * <p>
 * Returns <code>Double.NaN</code> if no values have been added.</p>
 *
 * @param v the value to lookup
 * @return the proportion of values equal to v
 * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0
 */
@Deprecated
public double getPct(Object v) {
    return getPct((Comparable<?>) v);
}"
770,Math,76,jira,https://issues.apache.org/jira/browse/MATH-320,High,src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java,153,201,"/**
 * {@inheritDoc}
 */
public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p; ++i) {
                // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                if (i < n - 1) {
                    ei1 = eData[i + 1];
                    final double si = secondaryBidiagonal[i];
                    for (int j = 0; j < p; ++j) {
                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                    }
                } else {
                    for (int j = 0; j < p; ++j) {
                        wi[j] = mi * ei0[j] / singularValues[j];
                    }
                }
            }
            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
    // return the cached matrix
    return cachedU;
}"
771,Math,76,jira,https://issues.apache.org/jira/browse/MATH-320,High,src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java,236,283,"/**
 * {@inheritDoc}
 */
public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
            cachedV = transformer.getV().multiply(e);
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[n][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p; ++i) {
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                if (i < m - 1) {
                    ei1 = eData[i + 1];
                    final double si = secondaryBidiagonal[i];
                    for (int j = 0; j < p; ++j) {
                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                    }
                } else {
                    for (int j = 0; j < p; ++j) {
                        wi[j] = mi * ei0[j] / singularValues[j];
                    }
                }
            }
            for (int i = p; i < n; ++i) {
                wData[i] = new double[p];
            }
            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
        }
    }
    // return the cached matrix
    return cachedV;
}"
772,Math,77,jira,https://issues.apache.org/jira/browse/MATH-326,High,src/main/java/org/apache/commons/math/linear/ArrayRealVector.java,717,724,"/**
 * {@inheritDoc}
 */
@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max = Math.max(max, Math.abs(a));
    }
    return max;
}"
773,Math,78,jira,https://issues.apache.org/jira/browse/MATH-322,High,src/main/java/org/apache/commons/math/ode/events/EventState.java,167,274,"/**
 * Evaluate the impact of the proposed step on the event handler.
 * @param interpolator step interpolator for the proposed step
 * @return true if the event handler triggers an event before
 * the end of the proposed step (this implies the step should be
 * rejected)
 * @exception DerivativeException if the interpolator fails to
 * compute the switching function somewhere within the step
 * @exception EventException if the switching function
 * cannot be evaluated
 * @exception ConvergenceException if an event cannot be located
 */
public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {
    try {
        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
        final double h = (t1 - t0) / n;
        double ta = t0;
        double ga = g0;
        double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
        for (int i = 0; i < n; ++i) {
            // evaluate handler value at the end of the substep
            tb += h;
            interpolator.setInterpolatedTime(tb);
            final double gb = handler.g(tb, interpolator.getInterpolatedState());
            // check events occurrence
            if (g0Positive ^ (gb >= 0)) {
                if (ga * gb > 0) {
                    // this is a corner case:
                    // - there was an event near ta,
                    // - there is another event between ta and tb
                    // - when ta was computed, convergence was reached on the ""wrong side"" of the interval
                    // this implies that the real sign of ga is the same as gb, so we need to slightly
                    // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                    // about bracketing
                    final double epsilon = (forward ? 0.25 : -0.25) * convergence;
                    for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
                        ta += epsilon;
                        interpolator.setInterpolatedTime(ta);
                        ga = handler.g(ta, interpolator.getInterpolatedState());
                    }
                    if (ga * gb > 0) {
                        // this should never happen
                        throw MathRuntimeException.createInternalError(null);
                    }
                }
                // variation direction, with respect to the integration direction
                increasing = gb >= ga;
                final UnivariateRealFunction f = new UnivariateRealFunction() {

                    public double value(final double t) throws FunctionEvaluationException {
                        try {
                            interpolator.setInterpolatedTime(t);
                            return handler.g(t, interpolator.getInterpolatedState());
                        } catch (DerivativeException e) {
                            throw new FunctionEvaluationException(e, t);
                        } catch (EventException e) {
                            throw new FunctionEvaluationException(e, t);
                        }
                    }
                };
                final BrentSolver solver = new BrentSolver();
                solver.setAbsoluteAccuracy(convergence);
                solver.setMaximalIterationCount(maxIterationCount);
                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
                if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {
                    // we have either found nothing or found (again ?) a past event, we simply ignore it
                    ta = tb;
                    ga = gb;
                } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
                        // properly ends exactly at the event occurrence
                        return false;
                    }
                    // either we were not waiting for the event or it has
                    // moved in such a way the step cannot be accepted
                    pendingEvent = true;
                    return true;
                }
            } else {
                // no sign change: there is no event for now
                ta = tb;
                ga = gb;
            }
        }
        // no event during the whole step
        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;
    } catch (FunctionEvaluationException e) {
        final Throwable cause = e.getCause();
        if ((cause != null) && (cause instanceof DerivativeException)) {
            throw (DerivativeException) cause;
        } else if ((cause != null) && (cause instanceof EventException)) {
            throw (EventException) cause;
        }
        throw new EventException(e);
    }
}"
774,Math,79,jira,https://issues.apache.org/jira/browse/MATH-305,High,src/main/java/org/apache/commons/math/util/MathUtils.java,1623,1630,"/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */
public static double distance(int[] p1, int[] p2) {
    double sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}"
775,Math,80,jira,https://issues.apache.org/jira/browse/MATH-318,High,src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,1132,1147,"/**
 * Flip qd array if warranted.
 * @param n number of rows in the block
 * @param step within the array (1 for flipping all elements, 2 for flipping
 * only every other element)
 * @return true if qd array was flipped
 */
private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * (n - 1);
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k += step) {
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}"
776,Math,81,jira,https://issues.apache.org/jira/browse/MATH-308,High,src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,569,606,"/**
 * Compute the Gershgorin circles for all rows.
 */
private void computeGershgorinCircles() {
    final int m = main.length;
    final int lowerStart = 4 * m;
    final int upperStart = 5 * m;
    lowerSpectra = Double.POSITIVE_INFINITY;
    upperSpectra = Double.NEGATIVE_INFINITY;
    double eMax = 0;
    double eCurrent = 0;
    for (int i = 0; i < m - 1; ++i) {
        final double dCurrent = main[i];
        final double ePrevious = eCurrent;
        eCurrent = Math.abs(secondary[i]);
        eMax = Math.max(eMax, eCurrent);
        final double radius = ePrevious + eCurrent;
        final double lower = dCurrent - radius;
        work[lowerStart + i] = lower;
        lowerSpectra = Math.min(lowerSpectra, lower);
        final double upper = dCurrent + radius;
        work[upperStart + i] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
    }
    final double dCurrent = main[m - 1];
    final double lower = dCurrent - eCurrent;
    work[lowerStart + m - 1] = lower;
    lowerSpectra = Math.min(lowerSpectra, lower);
    final double upper = dCurrent + eCurrent;
    work[upperStart + m - 1] = upper;
    upperSpectra = Math.max(upperSpectra, upper);
    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
}"
777,Math,81,jira,https://issues.apache.org/jira/browse/MATH-308,High,src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,823,929,"/**
 * Find realEigenvalues using dqd/dqds algorithms.
 * <p>This implementation is based on Beresford N. Parlett
 * and Osni A. Marques paper <a
 * href=""http://www.netlib.org/lapack/lawnspdf/lawn155.pdf"">An
 * Implementation of the dqds Algorithm (Positive Case)</a> and on the
 * corresponding LAPACK routine DLASQ2.</p>
 * @param n number of rows of the block
 * @exception InvalidMatrixException if block cannot be diagonalized
 * after 30 * n iterations
 */
private void processGeneralBlock(final int n) throws InvalidMatrixException {
    // check decomposed matrix data range
    double sumOffDiag = 0;
    for (int i = 0; i < n - 1; ++i) {
        final int fourI = 4 * i;
        final double ei = work[fourI + 2];
        sumOffDiag += ei;
    }
    if (sumOffDiag == 0) {
        // matrix is already diagonal
        return;
    }
    // initial checks for splits (see Parlett & Marques section 3.3)
    flipIfWarranted(n, 2);
    // two iterations with Li's test for initial splits
    initialSplits(n);
    // initialize parameters used by goodStep
    tType = 0;
    dMin1 = 0;
    dMin2 = 0;
    dN = 0;
    dN1 = 0;
    dN2 = 0;
    tau = 0;
    // process split segments
    int i0 = 0;
    int n0 = n;
    while (n0 > 0) {
        // retrieve shift that was temporarily stored as a negative off-diagonal element
        sigma = (n0 == n) ? 0 : -work[4 * n0 - 2];
        sigmaLow = 0;
        // find start of a new split segment to process
        double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
        double offDiagMax = 0;
        double diagMax = work[4 * n0 - 4];
        double diagMin = diagMax;
        i0 = 0;
        for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
            if (work[i + 2] <= 0) {
                i0 = 1 + i / 4;
                break;
            }
            if (diagMin >= 4 * offDiagMax) {
                diagMin = Math.min(diagMin, work[i + 4]);
                offDiagMax = Math.max(offDiagMax, work[i + 2]);
            }
            diagMax = Math.max(diagMax, work[i] + work[i + 2]);
            offDiagMin = Math.min(offDiagMin, work[i + 2]);
        }
        work[4 * n0 - 2] = offDiagMin;
        // lower bound of Gershgorin disk
        dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));
        pingPong = 0;
        int maxIter = 30 * (n0 - i0);
        for (int k = 0; i0 < n0; ++k) {
            if (k >= maxIter) {
                throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
            }
            // perform one step
            n0 = goodStep(i0, n0);
            pingPong = 1 - pingPong;
            // when the last elements of qd array are very small
            if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
                int split = i0 - 1;
                diagMax = work[4 * i0];
                offDiagMin = work[4 * i0 + 2];
                double previousEMin = work[4 * i0 + 3];
                for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
                    if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) {
                        // insert a split
                        work[i + 2] = -sigma;
                        split = i / 4;
                        diagMax = 0;
                        offDiagMin = work[i + 6];
                        previousEMin = work[i + 7];
                    } else {
                        diagMax = Math.max(diagMax, work[i + 4]);
                        offDiagMin = Math.min(offDiagMin, work[i + 2]);
                        previousEMin = Math.min(previousEMin, work[i + 3]);
                    }
                }
                work[4 * n0 - 2] = offDiagMin;
                work[4 * n0 - 1] = previousEMin;
                i0 = split + 1;
            }
        }
    }
}"
778,Math,81,jira,https://issues.apache.org/jira/browse/MATH-308,High,src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,1431,1673,"/**
 * Compute the shift increment as an estimate of the smallest eigenvalue.
 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
 * @param start start index
 * @param end end index
 * @param deflated number of realEigenvalues just deflated
 */
private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;
    // tType records the type of shift.
    if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }
    int nn = 4 * end + pingPong - 1;
    switch(deflated) {
        case // no realEigenvalues deflated.
        0:
            if (dMin == dN || dMin == dN1) {
                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];
                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5] > work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4] > work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9] > work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }
                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;
                }
            } else if (dMin == dN2) {
                // case 5.
                tType = -5;
                double s = 0.25 * dMin;
                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
                // approximate contribution to norm squared from i < nn-2.
                if (end - start > 3) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }
                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }
            } else {
                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau = g * dMin;
                tType = -6;
            }
            break;
        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
        1:
            if (dMin1 == dN1 && dMin2 == dN2) {
                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {
                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;
        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
        2:
            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau = 0.25 * dMin2;
                tType = -11;
            }
            break;
        default:
            // case 12, more than two realEigenvalues deflated. no information.
            tau = 0.0;
            tType = -12;
    }
}"
779,Math,82,jira,https://issues.apache.org/jira/browse/MATH-288,High,src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,76,91,"/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
            final double ratio = rhs / entry;
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}"
780,Math,83,jira,https://issues.apache.org/jira/browse/MATH-286,High,src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,290,301,"/**
 * Checks whether the given column is basic.
 * @param col index of the column to check
 * @return the row that the variable is basic in.  null if the column is not basic
 */
private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
    Integer row = null;
    int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
    for (int i = start; i < getHeight(); i++) {
        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
            row = i;
        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
            return null;
        }
    }
    return row;
}"
781,Math,83,jira,https://issues.apache.org/jira/browse/MATH-286,High,src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,339,358,"/**
 * Get the current solution.
 *
 * @return current solution
 */
protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
    Set<Integer> basicRows = new HashSet<Integer>();
    for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
        if (basicRows.contains(basicRow)) {
            // if multiple variables can take a given value
            // then we choose the first and set the rest equal to 0
            coefficients[i] = 0;
        } else {
            basicRows.add(basicRow);
            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
782,Math,84,jira,https://issues.apache.org/jira/browse/MATH-283,Critical,src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java,60,108,"/**
 * {@inheritDoc}
 */
@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    final RealConvergenceChecker checker = getConvergenceChecker();
    while (true) {
        incrementIterationsCounter();
        // save the original vertex
        final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];
        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                // accept the reflected simplex
                simplex = reflectedSimplex;
            }
            return;
        }
        // compute the contracted simplex
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // accept the contracted simplex
            return;
        }
        // check convergence
        final int iter = getIterations();
        boolean converged = true;
        for (int i = 0; i < simplex.length; ++i) {
            converged &= checker.converged(iter, original[i], simplex[i]);
        }
        if (converged) {
            return;
        }
    }
}"
783,Math,85,jira,https://issues.apache.org/jira/browse/MATH-280,High,src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java,165,208,"/**
 * This method attempts to find two values a and b satisfying <ul>
 * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>
 * <li> <code> f(a) * f(b) <= 0 </code> </li>
 * </ul>
 * If f is continuous on <code>[a,b],</code> this means that <code>a</code>
 * and <code>b</code> bracket a root of f.
 * <p>
 * The algorithm starts by setting
 * <code>a := initial -1; b := initial +1,</code> examines the value of the
 * function at <code>a</code> and <code>b</code> and keeps moving
 * the endpoints out by one unit each time through a loop that terminates
 * when one of the following happens: <ul>
 * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>
 * <li> <code> a = lower </code> and <code> b = upper</code>
 * -- ConvergenceException </li>
 * <li> <code> maximumIterations</code> iterations elapse
 * -- ConvergenceException </li></ul></p>
 *
 * @param function the function
 * @param initial initial midpoint of interval being expanded to
 * bracket a root
 * @param lowerBound lower bound (a is never lower than this value)
 * @param upperBound upper bound (b never is greater than this
 * value)
 * @param maximumIterations maximum number of iterations to perform
 * @return a two element array holding {a, b}.
 * @throws ConvergenceException if the algorithm fails to find a and b
 * satisfying the desired conditions
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if function is null, maximumIterations
 * is not positive, or initial is not between lowerBound and upperBound
 */
public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException {
    if (function == null) {
        throw MathRuntimeException.createIllegalArgumentException(""function is null"");
    }
    if (maximumIterations <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(""bad value for maximum iterations number: {0}"", maximumIterations);
    }
    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
        throw MathRuntimeException.createIllegalArgumentException(""invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}"", lowerBound, initial, upperBound);
    }
    double a = initial;
    double b = initial;
    double fa;
    double fb;
    int numIterations = 0;
    do {
        a = Math.max(a - 1.0, lowerBound);
        b = Math.min(b + 1.0, upperBound);
        fa = function.value(a);
        fb = function.value(b);
        numIterations++;
    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));
    if (fa * fb > 0.0) {
        throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, "" + ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + ""final b value={6}, f(a)={7}, f(b)={8}"", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb);
    }
    return new double[] { a, b };
}"
784,Math,87,jira,https://issues.apache.org/jira/browse/MATH-273,High,src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,272,282,"/**
 * Checks whether the given column is basic.
 * @param col index of the column to check
 * @return the row that the variable is basic in.  null if the column is not basic
 */
private Integer getBasicRow(final int col) {
    Integer row = null;
    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
            row = i;
        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
            return null;
        }
    }
    return row;
}"
785,Math,88,jira,https://issues.apache.org/jira/browse/MATH-272,High,src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,324,344,"/**
 * Get the current solution.
 * <p>
 * {@link #solve} should be called first for this to be the optimal solution.
 * </p>
 * @return current solution
 */
protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
    Set<Integer> basicRows = new HashSet<Integer>();
    for (int i = 0; i < coefficients.length; i++) {
        basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRows.contains(basicRow)) {
            // if multiple variables can take a given value
            // then we choose the first and set the rest equal to 0
            coefficients[i] = 0;
        } else {
            basicRows.add(basicRow);
            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
786,Math,89,jira,https://issues.apache.org/jira/browse/MATH-259,High,src/java/org/apache/commons/math/stat/Frequency.java,108,115,"/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not Comparable,
 *         or is not comparable with previous entries
 * @deprecated use {@link #addValue(Comparable)} instead
 */
@Deprecated
public void addValue(Object v) {
    if (v instanceof Comparable<?>) {
        addValue((Comparable<?>) v);
    } else {
        throw new IllegalArgumentException(""Object must implement Comparable"");
    }
}"
787,Math,90,jira,https://issues.apache.org/jira/browse/MATH-259,High,src/java/org/apache/commons/math/stat/Frequency.java,108,111,"/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
 * @throws ClassCastException if <code>v</code> is not Comparable
 * @deprecated use {@link #addValue(Comparable)} instead
 */
@Deprecated
public void addValue(Object v) {
    addValue((Comparable<?>) v);
}"
788,Math,90,jira,https://issues.apache.org/jira/browse/MATH-259,High,src/java/org/apache/commons/math/stat/Frequency.java,123,139,"/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
 */
public void addValue(Comparable<?> v) {
    Object obj = v;
    if (v instanceof Integer) {
        obj = Long.valueOf(((Integer) v).longValue());
    }
    try {
        Long count = (Long) freqTable.get(obj);
        if (count == null) {
            freqTable.put(obj, Long.valueOf(1));
        } else {
            freqTable.put(obj, Long.valueOf(count.longValue() + 1));
        }
    } catch (ClassCastException ex) {
        // TreeMap will throw ClassCastException if v is not comparable
        throw new IllegalArgumentException(""Value not comparable to existing values."");
    }
}"
789,Math,91,jira,https://issues.apache.org/jira/browse/MATH-252,High,src/java/org/apache/commons/math/fraction/Fraction.java,258,262,"/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */
public int compareTo(Fraction object) {
    long nOd = ((long) numerator) * object.denominator;
    long dOn = ((long) denominator) * object.numerator;
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}"
790,Math,92,jira,https://issues.apache.org/jira/browse/MATH-241,High,src/java/org/apache/commons/math/util/MathUtils.java,169,222,"/**
 * Returns an exact representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which all coefficients are
 * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds
 * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is
 * thrown.</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 */
public static long binomialCoefficient(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    // Use symmetry for large k
    if (k > n / 2)
        return binomialCoefficient(n, n - k);
    // We use the formula
    // (n choose k) = n! / (n-k)! / k!
    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
    // which could be written
    // (n choose k) == (n-1 choose k-1) * n / k
    long result = 1;
    if (n <= 61) {
        // For n <= 61, the naive implementation cannot overflow.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            result = result * i / j;
        }
    } else if (n <= 66) {
        // but we must take care not to overflow intermediate values.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            // We know that (result * i) is divisible by j,
            // but (result * i) may overflow, so we split j:
            // Filter out the gcd, d, so j/d and i/d are integer.
            // result is divisible by (j/d) because (j/d)
            // is relative prime to (i/d) and is a divisor of
            // result * (i/d).
            long d = gcd(i, j);
            result = (result / (j / d)) * (i / d);
        }
    } else {
        // unnecessary.
        for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
            long d = gcd(i, j);
            result = mulAndCheck((result / (j / d)), (i / d));
        }
    }
    return result;
}"
791,Math,92,jira,https://issues.apache.org/jira/browse/MATH-241,High,src/java/org/apache/commons/math/util/MathUtils.java,246,274,"/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientDouble(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 1d;
    }
    if ((k == 1) || (k == n - 1)) {
        return n;
    }
    if (k > n / 2) {
        return binomialCoefficientDouble(n, n - k);
    }
    if (n < 67) {
        return binomialCoefficient(n, k);
    }
    double result = 1d;
    for (int i = 1; i <= k; i++) {
        result *= (double) (n - k + i) / (double) i;
    }
    return Math.floor(result + 0.5);
}"
792,Math,92,jira,https://issues.apache.org/jira/browse/MATH-241,High,src/java/org/apache/commons/math/util/MathUtils.java,294,342,"/**
 * Returns the natural <code>log</code> of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientLog(final int n, final int k) {
    if (n < k) {
        throw new IllegalArgumentException(""must have n >= k for binomial coefficient (n,k)"");
    }
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for binomial coefficient (n,k)"");
    }
    if ((n == k) || (k == 0)) {
        return 0;
    }
    if ((k == 1) || (k == n - 1)) {
        return Math.log((double) n);
    }
    /*
         * For values small enough to do exact integer computation,
         * return the log of the exact value 
         */
    if (n < 67) {
        return Math.log(binomialCoefficient(n, k));
    }
    /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
    if (n < 1030) {
        return Math.log(binomialCoefficientDouble(n, k));
    }
    /*
         * Sum logs for values that could overflow
         */
    double logSum = 0;
    // n!/k!
    for (int i = k + 1; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    // divide by (n-k)!
    for (int i = 2; i <= n - k; i++) {
        logSum -= Math.log((double) i);
    }
    return logSum;
}"
793,Math,93,jira,https://issues.apache.org/jira/browse/MATH-240,Low,src/java/org/apache/commons/math/util/MathUtils.java,344,353,"/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */
public static long factorial(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n > 20) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}"
794,Math,93,jira,https://issues.apache.org/jira/browse/MATH-240,Low,src/java/org/apache/commons/math/util/MathUtils.java,375,383,"/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */
public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    if (n < 21) {
        return factorial(n);
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}"
795,Math,93,jira,https://issues.apache.org/jira/browse/MATH-240,Low,src/java/org/apache/commons/math/util/MathUtils.java,398,410,"/**
 * Returns the natural logarithm of n!.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * </ul></p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double factorialLog(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n > 0 for n!"");
    }
    if (n < 21) {
        return Math.log(factorial(n));
    }
    double logSum = 0;
    for (int i = 2; i <= n; i++) {
        logSum += Math.log((double) i);
    }
    return logSum;
}"
796,Math,94,jira,https://issues.apache.org/jira/browse/MATH-238,Low,src/java/org/apache/commons/math/util/MathUtils.java,411,460,"/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 *
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */
public static int gcd(int u, int v) {
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}"
797,Math,95,jira,https://issues.apache.org/jira/browse/MATH-227,Low,src/java/org/apache/commons/math/distribution/FDistributionImpl.java,143,151,"/**
 * Access the initial domain value, based on <code>p</code>, used to
 * bracket a CDF root.  This method is used by
 * {@link #inverseCumulativeProbability(double)} to find critical values.
 *
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected double getInitialDomain(double p) {
    double ret = 1.0;
    double d = getDenominatorDegreesOfFreedom();
    if (d > 2.0) {
        // use mean
        ret = d / (d - 2.0);
    }
    return ret;
}"
798,Math,96,jira,https://issues.apache.org/jira/browse/MATH-221,Low,src/java/org/apache/commons/math/complex/Complex.java,245,267,"/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */
public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (real == rhs.real) && (imaginary == rhs.imaginary);
            }
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}"
799,Math,97,jira,https://issues.apache.org/jira/browse/MATH-204,Low,src/java/org/apache/commons/math/analysis/BrentSolver.java,125,166,"/**
 * Find a zero in the given interval.
 * <p>
 * Requires that the values of the function at the endpoints have opposite
 * signs. An <code>IllegalArgumentException</code> is thrown if this is not
 * the case.</p>
 *
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException if the maximum iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min is not less than max or the
 * signs of the values of the function at the endpoints are not opposites
 */
public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifyInterval(min, max);
    double ret = Double.NaN;
    double yMin = f.value(min);
    double yMax = f.value(max);
    // Verify bracketing
    double sign = yMin * yMax;
    if (sign > 0) {
        // check if either value is close to a zero
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(min, 0);
            ret = min;
        } else if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(max, 0);
            ret = max;
        } else {
            // neither value is close to zero and min and max do not bracket root.
            throw new IllegalArgumentException(""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" + ""  Values: ["" + yMin + "","" + yMax + ""]"");
        }
    } else if (sign < 0) {
        // solve using only the first endpoint as initial guess
        ret = solve(min, yMin, max, yMax, min, yMin);
    } else {
        // either min or max is a root
        if (yMin == 0.0) {
            ret = min;
        } else {
            ret = max;
        }
    }
    return ret;
}"
800,Math,98,jira,https://issues.apache.org/jira/browse/MATH-209,High,src/java/org/apache/commons/math/linear/BigMatrixImpl.java,985,1000,"/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */
public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[nRows];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}"
801,Math,98,jira,https://issues.apache.org/jira/browse/MATH-209,High,src/java/org/apache/commons/math/linear/RealMatrixImpl.java,773,789,"/**
 * @param v vector to operate on
 * @throws IllegalArgumentException if columnDimension != v.length
 * @return resulting vector
 */
public double[] operate(double[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    if (v.length != nCols) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final double[] out = new double[nRows];
    for (int row = 0; row < nRows; row++) {
        final double[] dataRow = data[row];
        double sum = 0;
        for (int i = 0; i < nCols; i++) {
            sum += dataRow[i] * v[i];
        }
        out[row] = sum;
    }
    return out;
}"
802,Math,99,jira,https://issues.apache.org/jira/browse/MATH-243,Low,src/java/org/apache/commons/math/util/MathUtils.java,539,597,"/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
            throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
        }
        return (Math.abs(u) + Math.abs(v));
    }
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}"
803,Math,99,jira,https://issues.apache.org/jira/browse/MATH-243,Low,src/java/org/apache/commons/math/util/MathUtils.java,714,723,"/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    if (lcm == Integer.MIN_VALUE) {
        throw new ArithmeticException(""overflow: lcm is 2^31"");
    }
    return lcm;
}"
804,Math,100,jira,https://issues.apache.org/jira/browse/MATH-200,Critical,src/java/org/apache/commons/math/estimation/AbstractEstimator.java,158,188,"/**
 * Get the covariance matrix of unbound estimated parameters.
 * @param problem estimation problem
 * @return covariance matrix
 * @exception EstimationException if the covariance matrix
 * cannot be computed (singular problem)
 */
public double[][] getCovariances(EstimationProblem problem) throws EstimationException {
    // set up the jacobian
    updateJacobian();
    // compute transpose(J).J, avoiding building big intermediate matrices
    final int rows = problem.getMeasurements().length;
    final int cols = problem.getUnboundParameters().length;
    final int max = cols * rows;
    double[][] jTj = new double[cols][cols];
    for (int i = 0; i < cols; ++i) {
        for (int j = i; j < cols; ++j) {
            double sum = 0;
            for (int k = 0; k < max; k += cols) {
                sum += jacobian[k + i] * jacobian[k + j];
            }
            jTj[i][j] = sum;
            jTj[j][i] = sum;
        }
    }
    try {
        // compute the covariances matrix
        return new RealMatrixImpl(jTj).inverse().getData();
    } catch (InvalidMatrixException ime) {
        throw new EstimationException(""unable to compute covariances: singular problem"", new Object[0]);
    }
}"
805,Math,100,jira,https://issues.apache.org/jira/browse/MATH-200,Critical,src/java/org/apache/commons/math/estimation/AbstractEstimator.java,199,214,"/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */
public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getUnboundParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getUnboundParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}"
806,Math,101,jira,https://issues.apache.org/jira/browse/MATH-198,High,src/java/org/apache/commons/math/complex/ComplexFormat.java,320,390,"/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Complex} object.
 */
public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch(c) {
        case 0:
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if ((startIndex >= source.length()) || (endIndex > source.length()) || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {
        // set index back to initial, error index should be the start index
        // character examined.
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);
    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}"
807,Math,102,jira,https://issues.apache.org/jira/browse/MATH-175,High,src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,64,98,"/**
 * {@inheritDoc}
 * <p><strong>Note: </strong>This implementation rescales the
 * <code>expected</code> array if necessary to ensure that the sum of the
 * expected and observed counts are equal.</p>
 *
 * @param observed array of observed frequency counts
 * @param expected array of expected frequency counts
 * @return chi-square test statistic
 * @throws IllegalArgumentException if preconditions are not met
 * or length is less than 2
 */
public double chiSquare(double[] expected, long[] observed) throws IllegalArgumentException {
    if ((expected.length < 2) || (expected.length != observed.length)) {
        throw new IllegalArgumentException(""observed, expected array lengths incorrect"");
    }
    if (!isPositive(expected) || !isNonNegative(observed)) {
        throw new IllegalArgumentException(""observed counts must be non-negative and expected counts must be postive"");
    }
    double sumExpected = 0d;
    double sumObserved = 0d;
    for (int i = 0; i < observed.length; i++) {
        sumExpected += expected[i];
        sumObserved += observed[i];
    }
    double ratio = 1.0d;
    boolean rescale = false;
    if (Math.abs(sumExpected - sumObserved) > 10E-6) {
        ratio = sumObserved / sumExpected;
        rescale = true;
    }
    double sumSq = 0.0d;
    double dev = 0.0d;
    for (int i = 0; i < observed.length; i++) {
        if (rescale) {
            dev = ((double) observed[i] - ratio * expected[i]);
            sumSq += dev * dev / (ratio * expected[i]);
        } else {
            dev = ((double) observed[i] - expected[i]);
            sumSq += dev * dev / expected[i];
        }
    }
    return sumSq;
}"
808,Math,103,jira,https://issues.apache.org/jira/browse/MATH-167,Low,src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,108,121,"/**
 * For this disbution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluted at <code>x</code>.
 * @throws MathException if the algorithm fails to converge; unless
 * x is more than 20 standard deviations from the mean, in which case the
 * convergence exception is caught and 0 or 1 is returned.
 */
public double cumulativeProbability(double x) throws MathException {
    try {
        return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));
    } catch (MaxIterationsExceededException ex) {
        if (x < (mean - 20 * standardDeviation)) {
            // JDK 1.5 blows at 38
            return 0.0d;
        } else if (x > (mean + 20 * standardDeviation)) {
            return 1.0d;
        } else {
            throw ex;
        }
    }
}"
809,Math,105,jira,https://issues.apache.org/jira/browse/MATH-85,High,src/java/org/apache/commons/math/stat/regression/SimpleRegression.java,263,265,"/**
 * Returns the <a href=""http://www.xycoon.com/SumOfSquares.htm"">
 * sum of squared errors</a> (SSE) associated with the regression
 * model.
 * <p>
 * The sum is computed using the computational formula
 * <p>
 * <code>SSE = SYY - (SXY * SXY / SXX)</code>
 * <p>
 * where <code>SYY</code> is the sum of the squared deviations of the y
 * values about their mean, <code>SXX</code> is similarly defined and
 * <code>SXY</code> is the sum of the products of x and y mean deviations.
 * <p>
 * The sums are accumulated using the updating algorithm referenced in
 * {@link #addData}.
 * <p>
 * The return value is constrained to be non-negative - i.e., if due to
 * rounding errors the computational formula returns a negative result,
 * 0 is returned.
 * <p>
 * <strong>Preconditions</strong>: <ul>
 * <li>At least two observations (with at least two different x values)
 * must have been added before invoking this method. If this method is
 * invoked before a model can be estimated, <code>Double,NaN</code> is
 * returned.
 * </li></ul>
 *
 * @return sum of squared errors associated with the regression model
 */
public double getSumSquaredErrors() {
    return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
}"
810,Time,13,sourceforge,https://sourceforge.net/p/joda-time/bugs/160,Low,src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,1088,1118,"public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
    long valueLong = getFieldValue(period);
    if (valueLong == Long.MAX_VALUE) {
        return 0;
    }
    int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);
    if (iFieldType >= SECONDS_MILLIS) {
        // valueLong contains the seconds and millis fields
        // the minimum output is 0.000, which is 4 or 5 digits with a negative
        sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
        // plus one for the decimal point
        sum++;
        if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {
            // remove three digits and decimal point
            sum -= 4;
        }
        // reset valueLong to refer to the seconds part for the prefic/suffix calculation
        valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;
    }
    int value = (int) valueLong;
    if (iPrefix != null) {
        sum += iPrefix.calculatePrintedLength(value);
    }
    if (iSuffix != null) {
        sum += iSuffix.calculatePrintedLength(value);
    }
    return sum;
}"
811,Time,13,sourceforge,https://sourceforge.net/p/joda-time/bugs/160,Low,src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,1120,1153,"public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
    long valueLong = getFieldValue(period);
    if (valueLong == Long.MAX_VALUE) {
        return;
    }
    int value = (int) valueLong;
    if (iFieldType >= SECONDS_MILLIS) {
        value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);
    }
    if (iPrefix != null) {
        iPrefix.printTo(buf, value);
    }
    int bufLen = buf.length();
    int minDigits = iMinPrintedDigits;
    if (minDigits <= 1) {
        FormatUtils.appendUnpaddedInteger(buf, value);
    } else {
        FormatUtils.appendPaddedInteger(buf, value, minDigits);
    }
    if (iFieldType >= SECONDS_MILLIS) {
        int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
        if (iFieldType == SECONDS_MILLIS || dp > 0) {
            if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
                buf.insert(bufLen, '-');
            }
            buf.append('.');
            FormatUtils.appendPaddedInteger(buf, dp, 3);
        }
    }
    if (iSuffix != null) {
        iSuffix.printTo(buf, value);
    }
}"
812,Time,14,sourceforge,https://sourceforge.net/p/joda-time/bugs/151,Medium,src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,203,225,"// -----------------------------------------------------------------------
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
    // 2004-02-29 + 48 months -> 2008-02-29 type dates
    if (valueToAdd == 0) {
        return values;
    }
    if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
        // month is largest field and being added to, such as month-day
        int curMonth0 = partial.getValue(0) - 1;
        int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
        return set(partial, 0, values, newMonth);
    }
    if (DateTimeUtils.isContiguous(partial)) {
        long instant = 0L;
        for (int i = 0, isize = partial.size(); i < isize; i++) {
            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);
        }
        instant = add(instant, valueToAdd);
        return iChronology.get(partial, instant);
    } else {
        return super.add(partial, fieldIndex, values, valueToAdd);
    }
}"
813,Time,15,sourceforge,https://sourceforge.net/p/joda-time/bugs/147,Medium,src/main/java/org/joda/time/field/FieldUtils.java,135,152,"/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */
public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            if (val1 == Long.MIN_VALUE) {
                throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
            }
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}"
814,Time,16,sourceforge,https://sourceforge.net/p/joda-time/bugs/148,Medium,src/main/java/org/joda/time/format/DateTimeFormatter.java,697,724,"// -----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}"
815,Time,17,sourceforge,https://sourceforge.net/p/joda-time/bugs/141,Medium,src/main/java/org/joda/time/DateTimeZone.java,1163,1193,"/**
 * Adjusts the offset to be the earlier or later one during an overlap.
 *
 * @param instant  the instant to adjust
 * @param earlierOrLater  false for earlier, true for later
 * @return the adjusted instant millis
 */
public long adjustOffset(long instant, boolean earlierOrLater) {
    // a bit messy, but will work in all non-pathological cases
    // evaluate 3 hours before and after to work out if anything is happening
    long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
    long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
    long offsetBefore = getOffset(instantBefore);
    long offsetAfter = getOffset(instantAfter);
    if (offsetBefore <= offsetAfter) {
        // not an overlap (less than is a gap, equal is normal case)
        return instant;
    }
    // work out range of instants that have duplicate local times
    long diff = offsetBefore - offsetAfter;
    long transition = nextTransition(instantBefore);
    long overlapStart = transition - diff;
    long overlapEnd = transition + diff;
    if (instant < overlapStart || instant >= overlapEnd) {
        // not an overlap
        return instant;
    }
    // calculate result
    long afterStart = instant - overlapStart;
    if (afterStart >= diff) {
        // currently in later offset
        return earlierOrLater ? instant : instant - diff;
    } else {
        // currently in earlier offset
        return earlierOrLater ? instant + diff : instant;
    }
}"
816,Time,18,sourceforge,https://sourceforge.net/p/joda-time/bugs/130,Low,src/main/java/org/joda/time/chrono/GJChronology.java,350,390,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    }
    // Assume date is Gregorian.
    long instant;
    try {
        instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
    } catch (IllegalFieldValueException ex) {
        if (monthOfYear != 2 || dayOfMonth != 29) {
            throw ex;
        }
        instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (instant >= iCutoverMillis) {
            throw ex;
        }
    }
    if (instant < iCutoverMillis) {
        // Maybe it's Julian.
        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        if (instant >= iCutoverMillis) {
            // Okay, it's in the illegal cutover gap.
            throw new IllegalArgumentException(""Specified date does not exist"");
        }
    }
    return instant;
}"
817,Time,19,sourceforge,https://sourceforge.net/p/joda-time/bugs/124,Medium,src/main/java/org/joda/time/DateTimeZone.java,880,911,"/**
 * Gets the millisecond offset to subtract from local time to get UTC time.
 * This offset can be used to undo adding the offset obtained by getOffset.
 *
 * <pre>
 * millisLocal == millisUTC   + getOffset(millisUTC)
 * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)
 * </pre>
 *
 * NOTE: After calculating millisLocal, some error may be introduced. At
 * offset transitions (due to DST or other historical changes), ranges of
 * local times may map to different UTC times.
 * <p>
 * This method will return an offset suitable for calculating an instant
 * after any DST gap. For example, consider a zone with a cutover
 * from 01:00 to 01:59:<br />
 * Input: 00:00  Output: 00:00<br />
 * Input: 00:30  Output: 00:30<br />
 * Input: 01:00  Output: 02:00<br />
 * Input: 01:30  Output: 02:30<br />
 * Input: 02:00  Output: 02:00<br />
 * Input: 02:30  Output: 02:30<br />
 * <p>
 * During a DST overlap (where the local time is ambiguous) this method will return
 * the earlier instant. The combination of these two rules is to always favour
 * daylight (summer) time over standard (winter) time.
 * <p>
 * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.
 * Prior to v1.5, the DST gap behaviour was also not defined.
 *
 * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for
 * @return the millisecond offset to subtract from local time to get UTC time
 */
public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    } else if (offsetLocal >= 0) {
        long prev = previousTransition(instantAdjusted);
        if (prev < instantAdjusted) {
            int offsetPrev = getOffset(prev);
            int diff = offsetPrev - offsetLocal;
            if (instantAdjusted - prev <= diff) {
                return offsetPrev;
            }
        }
    }
    return offsetAdjusted;
}"
818,Time,20,sourceforge,https://sourceforge.net/p/joda-time/bugs/126,Medium,src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,2540,2555,"public int parseInto(DateTimeParserBucket bucket, String text, int position) {
    String str = text.substring(position);
    String best = null;
    for (String id : ALL_IDS) {
        if (str.startsWith(id)) {
            if (best == null || id.length() > best.length()) {
                best = id;
            }
        }
    }
    if (best != null) {
        bucket.setZone(DateTimeZone.forID(best));
        return position + best.length();
    }
    return ~position;
}"
819,Time,23,sourceforge,https://sourceforge.net/p/joda-time/bugs/112,Medium,src/main/java/org/joda/time/DateTimeZone.java,558,599,"// -----------------------------------------------------------------------
/**
 * Converts an old style id to a new style id.
 *
 * @param id  the old style id
 * @return the new style id, null if not found
 */
private static synchronized String getConvertedId(String id) {
    Map<String, String> map = cZoneIdConversion;
    if (map == null) {
        // Backwards compatibility with TimeZone.
        map = new HashMap<String, String>();
        map.put(""GMT"", ""UTC"");
        map.put(""WET"", ""WET"");
        map.put(""CET"", ""CET"");
        map.put(""MET"", ""CET"");
        map.put(""ECT"", ""CET"");
        map.put(""EET"", ""EET"");
        map.put(""MIT"", ""Pacific/Apia"");
        // JDK 1.1 compatible
        map.put(""HST"", ""Pacific/Honolulu"");
        map.put(""AST"", ""America/Anchorage"");
        map.put(""PST"", ""America/Los_Angeles"");
        // JDK 1.1 compatible
        map.put(""MST"", ""America/Denver"");
        map.put(""PNT"", ""America/Phoenix"");
        map.put(""CST"", ""America/Chicago"");
        // JDK 1.1 compatible
        map.put(""EST"", ""America/New_York"");
        map.put(""IET"", ""America/Indiana/Indianapolis"");
        map.put(""PRT"", ""America/Puerto_Rico"");
        map.put(""CNT"", ""America/St_Johns"");
        map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
        map.put(""BET"", ""America/Sao_Paulo"");
        map.put(""ART"", ""Africa/Cairo"");
        map.put(""CAT"", ""Africa/Harare"");
        map.put(""EAT"", ""Africa/Addis_Ababa"");
        map.put(""NET"", ""Asia/Yerevan"");
        map.put(""PLT"", ""Asia/Karachi"");
        map.put(""IST"", ""Asia/Kolkata"");
        map.put(""BST"", ""Asia/Dhaka"");
        map.put(""VST"", ""Asia/Ho_Chi_Minh"");
        map.put(""CTT"", ""Asia/Shanghai"");
        map.put(""JST"", ""Asia/Tokyo"");
        map.put(""ACT"", ""Australia/Darwin"");
        map.put(""AET"", ""Australia/Sydney"");
        map.put(""SST"", ""Pacific/Guadalcanal"");
        map.put(""NST"", ""Pacific/Auckland"");
        cZoneIdConversion = map;
    }
    return map.get(id);
}"
820,Time,24,sourceforge,https://sourceforge.net/p/joda-time/bugs/107,Medium,src/main/java/org/joda/time/format/DateTimeParserBucket.java,331,383,"/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */
public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
        if (resetFields) {
            for (int i = 0; i < count; i++) {
                millis = savedFields[i].set(millis, i == (count - 1));
            }
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}"
821,Time,25,sourceforge,https://sourceforge.net/p/joda-time/bugs/90,Medium,src/main/java/org/joda/time/DateTimeZone.java,879,910,"/**
 * Gets the millisecond offset to subtract from local time to get UTC time.
 * This offset can be used to undo adding the offset obtained by getOffset.
 *
 * <pre>
 * millisLocal == millisUTC   + getOffset(millisUTC)
 * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)
 * </pre>
 *
 * NOTE: After calculating millisLocal, some error may be introduced. At
 * offset transitions (due to DST or other historical changes), ranges of
 * local times may map to different UTC times.
 * <p>
 * This method will return an offset suitable for calculating an instant
 * after any DST gap. For example, consider a zone with a cutover
 * from 01:00 to 01:59:<br />
 * Input: 00:00  Output: 00:00<br />
 * Input: 00:30  Output: 00:30<br />
 * Input: 01:00  Output: 02:00<br />
 * Input: 01:30  Output: 02:30<br />
 * Input: 02:00  Output: 02:00<br />
 * Input: 02:30  Output: 02:30<br />
 * <p>
 * During a DST overlap (where the local time is ambiguous) this method will return
 * the earlier instant. The combination of these two rules is to always favour
 * daylight (summer) time over standard (winter) time.
 * <p>
 * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.
 * Prior to v1.5, the DST gap behaviour was also not defined.
 *
 * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for
 * @return the millisecond offset to subtract from local time to get UTC time
 */
public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    } else if (offsetLocal > 0) {
        long prev = previousTransition(instantAdjusted);
        if (prev < instantAdjusted) {
            int offsetPrev = getOffset(prev);
            int diff = offsetPrev - offsetLocal;
            if (instantAdjusted - prev <= diff) {
                return offsetPrev;
            }
        }
    }
    return offsetAdjusted;
}"
822,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/DateTimeZone.java,936,944,"/**
 * Converts a local instant to a standard UTC instant with the same
 * local time attempting to use the same offset as the original.
 * <p>
 * This conversion is used after performing a calculation
 * where the calculation was done using a simple local zone.
 * Whenever possible, the same offset as the original offset will be used.
 * This is most significant during a daylight savings overlap.
 *
 * @param instantLocal  the local instant to convert to UTC
 * @param strict  whether the conversion should reject non-existent local times
 * @param originalInstantUTC  the original instant that the calculation is based on
 * @return the UTC instant with the same local time,
 * @throws ArithmeticException if the result overflows a long
 * @throws IllegalArgumentException if the zone has no equivalent local time
 * @since 2.0
 */
public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {
    int offsetOriginal = getOffset(originalInstantUTC);
    long instantUTC = instantLocal - offsetOriginal;
    int offsetLocalFromOriginal = getOffset(instantUTC);
    if (offsetLocalFromOriginal == offsetOriginal) {
        return instantUTC;
    }
    return convertLocalToUTC(instantLocal, strict);
}"
823,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,428,438,"public long add(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.add(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.add(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false, instant);
    }
}"
824,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,440,450,"public long add(long instant, long value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.add(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.add(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false, instant);
    }
}"
825,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,452,462,"public long addWrapField(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.addWrapField(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.addWrapField(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false, instant);
    }
}"
826,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,464,475,"public long set(long instant, int value) {
    long localInstant = iZone.convertUTCToLocal(instant);
    localInstant = iField.set(localInstant, value);
    long result = iZone.convertLocalToUTC(localInstant, false, instant);
    if (get(result) != value) {
        throw new IllegalFieldValueException(iField.getType(), new Integer(value), ""Illegal instant due to time zone offset transition: "" + DateTimeFormat.forPattern(""yyyy-MM-dd'T'HH:mm:ss.SSS"").print(new Instant(localInstant)) + "" ("" + iZone.getID() + "")"");
    }
    return result;
}"
827,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,477,482,"public long set(long instant, String text, Locale locale) {
    // cannot verify that new value stuck because set may be lenient
    long localInstant = iZone.convertUTCToLocal(instant);
    localInstant = iField.set(localInstant, text, locale);
    return iZone.convertLocalToUTC(localInstant, false, instant);
}"
828,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,520,530,"public long roundFloor(long instant) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        instant = iField.roundFloor(instant + offset);
        return instant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.roundFloor(localInstant);
        return iZone.convertLocalToUTC(localInstant, false, instant);
    }
}"
829,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/chrono/ZonedChronology.java,532,542,"public long roundCeiling(long instant) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        instant = iField.roundCeiling(instant + offset);
        return instant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.roundCeiling(localInstant);
        return iZone.convertLocalToUTC(localInstant, false, instant);
    }
}"
830,Time,26,sourceforge,https://sourceforge.net/p/joda-time/bugs/60,Medium,src/main/java/org/joda/time/field/LenientDateTimeField.java,69,76,"/**
 * Set values which may be out of bounds by adding the difference between
 * the new value and the current value.
 */
public long set(long instant, int value) {
    // lenient needs to handle time zone chronologies
    // so we do the calculation using local milliseconds
    long localInstant = iBase.getZone().convertUTCToLocal(instant);
    long difference = FieldUtils.safeSubtract(value, get(instant));
    localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);
    return iBase.getZone().convertLocalToUTC(localInstant, false, instant);
}"
831,Time,27,sourceforge,https://sourceforge.net/p/joda-time/bugs/64,High,src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,794,815,"// -----------------------------------------------------------------------
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {
    if (notPrinter && notParser) {
        throw new IllegalStateException(""Builder has created neither a printer nor a parser"");
    }
    int size = elementPairs.size();
    if (size >= 2 && elementPairs.get(0) instanceof Separator) {
        Separator sep = (Separator) elementPairs.get(0);
        if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
            sep = sep.finish(f.getPrinter(), f.getParser());
            return new PeriodFormatter(sep, sep);
        }
    }
    Object[] comp = createComposite(elementPairs);
    if (notPrinter) {
        return new PeriodFormatter(null, (PeriodParser) comp[1]);
    } else if (notParser) {
        return new PeriodFormatter((PeriodPrinter) comp[0], null);
    } else {
        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);
    }
}"
