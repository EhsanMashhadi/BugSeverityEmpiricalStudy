,IsBuggy,ProjectName,ProjectVersion,Priority,StartLine,EndLine,SLOC,IC,MCCABE,NBD,MCCLURE,DIFF,MI,TFO,READABILITY,EFFORT,SourceCode,average_sum,FixedCode
0,True,Math,77,High,498,506,-0.5208333333333334,-0.3715415019762846,-0.5,-0.3333333333333333,-0.5333333333333333,-0.45558958652373654,-0.5286773312524391,-0.35714285714285715,4.166666666666667,-0.2969024006368316,"public double getLInfNorm() {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        max += iter.value();
    }
    return max;
}",-3.897353677532149,"/**
 * {@inheritDoc}
 */
@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max = Math.max(max, Math.abs(a));
    }
    return max;
}"
1,True,Compress,4,High,334,340,-0.6041666666666666,-0.02371541501976281,-0.5,-0.3333333333333333,-0.5333333333333333,-0.4800918836140888,-0.5614514241123679,-0.5,16.5,-0.30919393512064175,"/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */
public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}",-3.8452859912001944,"/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */
public void close() throws IOException {
    if (!this.closed) {
        out.close();
        this.closed = true;
    }
}"
2,True,Math,91,High,258,262,-0.6875,-0.7457180500658762,-0.375,-0.6666666666666666,-0.4,-0.13246554364471666,-1.3246195864221613,-0.5,5.666666666666667,-0.2550568301579133,"/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */
public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}",-5.0870266769573345,"/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */
public int compareTo(Fraction object) {
    long nOd = ((long) numerator) * object.denominator;
    long dOn = ((long) denominator) * object.numerator;
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}"
3,True,Compress,4,High,529,537,-0.5208333333333334,-0.3715415019762846,-0.375,-0.3333333333333333,-0.4,-0.6776416539050536,-0.30159968786578306,-0.42857142857142855,16.333333333333332,-0.31878706692616415,"/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
public void close() throws IOException {
    finish();
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}",-3.72730800591138,"/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
public void close() throws IOException {
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}"
4,True,Math,49,High,379,389,-0.4375,-0.3715415019762846,-0.5,-0.3333333333333333,-0.5333333333333333,-0.40811638591117916,-0.5552087397580968,-0.07142857142857142,1.3333333333333335,-0.26585044087106413,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}",-3.4763123066118626,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}"
5,True,Lang,40,High,1044,1049,-0.6458333333333334,-0.32938076416337286,-0.5,-0.3333333333333333,-0.4,-0.40505359877488506,-1.0140460397971134,-0.42857142857142855,0.5,-0.2937824394116584,"/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */
public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    return contains(str.toUpperCase(), searchStr.toUpperCase());
}",-4.350000937385125,"/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */
public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (str.regionMatches(true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}"
6,True,Cli,3,High,158,170,-0.5625,-0.2872200263504611,-0.5,-0.3333333333333333,-0.6666666666666666,-0.6776416539050536,-0.6074912212251267,-0.42857142857142855,4.0,-0.31878706692616415,"/**
 * <p>Create a number from a String. If a . is present, it creates a
 *    Double, otherwise a Long. </p>
 *
 * @param str the value
 * @return the number represented by <code>str</code>, if <code>str</code>
 * is not a number, null is returned.
 */
public static Number createNumber(String str) {
    try {
        return NumberUtils.createNumber(str);
    } catch (NumberFormatException nfe) {
        System.err.println(nfe.getMessage());
    }
    return null;
}",-4.382211396978235,"/**
 * <p>Create a number from a String. If a . is present, it creates a
 *    Double, otherwise a Long. </p>
 *
 * @param str the value
 * @return the number represented by <code>str</code>, if <code>str</code>
 * is not a number, null is returned.
 */
public static Number createNumber(String str) {
    try {
        if (str != null) {
            if (str.indexOf('.') != -1) {
                return Double.valueOf(str);
            } else {
                return Long.valueOf(str);
            }
        }
    } catch (NumberFormatException nfe) {
        System.err.println(nfe.getMessage());
    }
    return null;
}"
7,True,Lang,26,High,819,823,-0.6875,-0.7457180500658762,-0.625,-0.6666666666666666,-0.6666666666666666,-0.6776416539050536,-1.2895044869293804,-0.42857142857142855,12.5,-0.31878706692616415,"/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */
public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}",-6.106056019731237,"/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */
public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}"
8,True,Math,65,High,239,246,-0.5625,-0.2872200263504611,-0.5,-0.3333333333333333,-0.4666666666666667,0.19984686064318538,-0.889192352711667,-0.5714285714285714,0.5,-0.17351199997432132,"/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */
public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}",-3.5840060898218358,"/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */
public double getRMS() {
    return Math.sqrt(getChiSquare() / rows);
}"
9,True,Cli,22,High,204,213,-0.6458333333333334,-0.32938076416337286,-0.5,-0.3333333333333333,-0.3333333333333333,-0.4831546707503828,-1.00780335544284,-0.5,7.833333333333333,-0.301158644036605,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    tokens.add(token);
}",-4.433997434393201,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    if (options.hasOption(token)) {
        currentOption = options.getOption(token);
    }
    tokens.add(token);
}"
10,True,Csv,6,High,179,185,-0.6041666666666666,-0.18708827404479578,-0.5,-0.3333333333333333,-0.6666666666666666,-0.6776416539050536,-1.0374561061256355,-0.2857142857142857,5.166666666666667,-0.31878706692616415,"/**
 * Puts all values of this record into the given Map.
 *
 * @param map The Map to populate.
 * @return the given map.
 */
<M extends Map<String, String>> M putIn(final M map) {
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue().intValue();
        map.put(entry.getKey(), values[col]);
    }
    return map;
}",-4.610854053382601,"/**
 * Puts all values of this record into the given Map.
 *
 * @param map The Map to populate.
 * @return the given map.
 */
<M extends Map<String, String>> M putIn(final M map) {
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue().intValue();
        if (col < values.length) {
            map.put(entry.getKey(), values[col]);
        }
    }
    return map;
}"
11,True,Lang,8,High,1132,1140,-0.5625,-0.13438735177865607,-0.5,-0.3333333333333333,-0.4,-0.4387442572741194,-0.9258681232930168,-0.21428571428571427,1.5,-0.2756276033112675,"/**
 * {@inheritDoc}
 */
@Override
public void appendTo(StringBuffer buffer, Calendar calendar) {
    if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
        buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
    } else {
        buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
    }
}",-3.7847463832761075,"/**
 * {@inheritDoc}
 */
@Override
public void appendTo(StringBuffer buffer, Calendar calendar) {
    TimeZone zone = calendar.getTimeZone();
    if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
        buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
    } else {
        buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
    }
}"
12,True,Lang,49,High,465,471,-0.6041666666666666,-0.4295125164690382,-0.5,-0.3333333333333333,-0.5333333333333333,-0.44027565084226644,-0.8985563792430759,-0.42857142857142855,12.5,-0.29234443259182546,"// Calculations
// -------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",-4.460093741050968,"// Calculations
// -------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    if (numerator == 0) {
        return equals(ZERO) ? this : ZERO;
    }
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}"
13,True,Codec,11,High,114,120,-0.6041666666666666,-0.8247694334650856,-0.625,-0.6666666666666666,-0.6666666666666666,-0.3606431852986217,-1.172454155286774,-0.14285714285714285,3.166666666666667,-0.25239908541054346,"/**
 * Encodes byte into its quoted-printable representation.
 *
 * @param b
 *            byte to encode
 * @param buffer
 *            the buffer to write to
 * @return The number of bytes written to the <code>buffer</code>
 */
private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
    buffer.write(ESCAPE_CHAR);
    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
    buffer.write(hex1);
    buffer.write(hex2);
}",-5.315623002318167,"/**
 * Encodes byte into its quoted-printable representation.
 *
 * @param b
 *            byte to encode
 * @param buffer
 *            the buffer to write to
 * @return The number of bytes written to the <code>buffer</code>
 */
private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
    buffer.write(ESCAPE_CHAR);
    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
    buffer.write(hex1);
    buffer.write(hex2);
    return 3;
}"
14,True,Compress,2,High,141,146,-0.6458333333333334,-0.782608695652174,-0.5,-0.6666666666666666,-0.5333333333333333,-0.39892802450229703,-1.147483417869685,-0.5714285714285714,0.16666666666666669,-0.28323491617511587,"public int read(byte[] b, final int off, final int len) throws IOException {
    int toRead = len;
    final int ret = this.input.read(b, off, toRead);
    offset += (ret > 0 ? ret : 0);
    return ret;
}",-5.529516958961176,"public int read(byte[] b, final int off, final int len) throws IOException {
    int toRead = len;
    if (currentEntry != null) {
        final long entryEnd = entryOffset + currentEntry.getLength();
        if (len > 0 && entryEnd > offset) {
            toRead = (int) Math.min(len, entryEnd - offset);
        } else {
            return -1;
        }
    }
    final int ret = this.input.read(b, off, toRead);
    offset += (ret > 0 ? ret : 0);
    return ret;
}"
15,True,Lang,11,Low,223,289,1.5208333333333333,1.225296442687747,1.375,1.0,1.6666666666666667,2.3514548238897395,1.0101443620756922,-0.21428571428571427,0.0,4.005909309275252,"/**
 * <p>Creates a random string based on a variety of options, using
 * supplied source of randomness.</p>
 *
 * <p>If start and end are both {@code 0}, start and end are set
 * to {@code ' '} and {@code 'z'}, the ASCII printable
 * characters, will be used, unless letters and numbers are both
 * {@code false}, in which case, start and end are set to
 * {@code 0} and {@code Integer.MAX_VALUE}.
 *
 * <p>If set is not {@code null}, characters between start and
 * end are chosen.</p>
 *
 * <p>This method accepts a user-supplied {@link Random}
 * instance to use as a source of randomness. By seeding a single
 * {@link Random} instance with a fixed seed and using it for each call,
 * the same random sequence of strings can be generated repeatedly
 * and predictably.</p>
 *
 * @param count  the length of random string to create
 * @param start  the position in set of chars to start at
 * @param end  the position in set of chars to end before
 * @param letters  only allow letters?
 * @param numbers  only allow numbers?
 * @param chars  the set of chars to choose randoms from, must not be empty.
 *  If {@code null}, then it will use the set of all chars.
 * @param random  a source of randomness.
 * @return the random string
 * @throws ArrayIndexOutOfBoundsException if there are not
 *  {@code (end - start) + 1} characters in the set array.
 * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.
 * @since 2.0
 */
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    }
    char[] buffer = new char[count];
    int gap = end - start;
    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }
        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 0) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[count] = ch;
                    count--;
                    buffer[count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 0) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[count] = (char) (56320 + random.nextInt(128));
                    count--;
                    buffer[count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}",13.941019223642716,"/**
 * <p>Creates a random string based on a variety of options, using
 * supplied source of randomness.</p>
 *
 * <p>If start and end are both {@code 0}, start and end are set
 * to {@code ' '} and {@code 'z'}, the ASCII printable
 * characters, will be used, unless letters and numbers are both
 * {@code false}, in which case, start and end are set to
 * {@code 0} and {@code Integer.MAX_VALUE}.
 *
 * <p>If set is not {@code null}, characters between start and
 * end are chosen.</p>
 *
 * <p>This method accepts a user-supplied {@link Random}
 * instance to use as a source of randomness. By seeding a single
 * {@link Random} instance with a fixed seed and using it for each call,
 * the same random sequence of strings can be generated repeatedly
 * and predictably.</p>
 *
 * @param count  the length of random string to create
 * @param start  the position in set of chars to start at
 * @param end  the position in set of chars to end before
 * @param letters  only allow letters?
 * @param numbers  only allow numbers?
 * @param chars  the set of chars to choose randoms from, must not be empty.
 *  If {@code null}, then it will use the set of all chars.
 * @param random  a source of randomness.
 * @return the random string
 * @throws ArrayIndexOutOfBoundsException if there are not
 *  {@code (end - start) + 1} characters in the set array.
 * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.
 * @since 2.0
 */
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {
    if (count == 0) {
        return """";
    } else if (count < 0) {
        throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
    }
    if (chars != null && chars.length == 0) {
        throw new IllegalArgumentException(""The chars array must not be empty"");
    }
    if (start == 0 && end == 0) {
        if (chars != null) {
            end = chars.length;
        } else {
            if (!letters && !numbers) {
                end = Integer.MAX_VALUE;
            } else {
                end = 'z' + 1;
                start = ' ';
            }
        }
    } else {
        if (end <= start) {
            throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
        }
    }
    char[] buffer = new char[count];
    int gap = end - start;
    while (count-- != 0) {
        char ch;
        if (chars == null) {
            ch = (char) (random.nextInt(gap) + start);
        } else {
            ch = chars[random.nextInt(gap) + start];
        }
        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {
            if (ch >= 56320 && ch <= 57343) {
                if (count == 0) {
                    count++;
                } else {
                    // low surrogate, insert high surrogate after putting it in
                    buffer[count] = ch;
                    count--;
                    buffer[count] = (char) (55296 + random.nextInt(128));
                }
            } else if (ch >= 55296 && ch <= 56191) {
                if (count == 0) {
                    count++;
                } else {
                    // high surrogate, insert low surrogate before putting it in
                    buffer[count] = (char) (56320 + random.nextInt(128));
                    count--;
                    buffer[count] = ch;
                }
            } else if (ch >= 56192 && ch <= 56319) {
                // private high surrogate, no effing clue, so skip it
                count++;
            } else {
                buffer[count] = ch;
            }
        } else {
            count++;
        }
    }
    return new String(buffer);
}"
16,True,Closure,32,Medium,1328,1429,1.8125,1.847167325428195,1.375,1.0,0.8666666666666667,0.6914241960183767,1.1232930159968797,1.2857142857142858,0.0,1.7902040065181084,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    do {
        switch(token) {
            case STAR:
                if (ignoreStar) {
                // Mark the position after the star as the new start of the line.
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // in the block are ok.
                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}",11.791969496342512,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    // Track the start of the line to count whitespace that
    // the tokenizer skipped. Because this case is rare, it's easier
    // to do this here than in the tokenizer.
    int lineStartChar = -1;
    do {
        switch(token) {
            case STAR:
                if (ignoreStar) {
                    // Mark the position after the star as the new start of the line.
                    lineStartChar = stream.getCharno() + 1;
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                lineStartChar = 0;
                token = next();
                continue;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                boolean isEOC = token == JsDocToken.EOC;
                if (!isEOC) {
                    if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
                        int numSpaces = stream.getCharno() - lineStartChar;
                        for (int i = 0; i < numSpaces; i++) {
                            builder.append(' ');
                        }
                        lineStartChar = -1;
                    } else if (builder.length() > 0) {
                        // All tokens must be separated by a space.
                        builder.append(' ');
                    }
                }
                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // in the block are ok.
                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}"
17,True,Closure,68,Medium,169,913,21.270833333333332,2.7588932806324107,23.5,3.3333333333333335,13.933333333333334,2.20750382848392,6.010534529847836,22.142857142857142,0.0,45.50311835630686,"/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                                    // If RETURN doesn't have a type annotation, record
                                    // it as the unknown type.
                                    typeNode = newNode(Token.QMARK);
                                } else {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                }
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                // error reported during recursive descent
                                // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}",140.66040713812816,"/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                                    // If RETURN doesn't have a type annotation, record
                                    // it as the unknown type.
                                    typeNode = newNode(Token.QMARK);
                                } else {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                }
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                // error reported during recursive descent
                                // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}"
18,True,Closure,169,Medium,520,606,1.1041666666666667,-0.22924901185770755,1.25,0.3333333333333333,1.8666666666666667,0.9027565084226646,0.864221615294576,2.0714285714285716,0.0,1.39770518078335,"/**
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {
    if (this == that) {
        return true;
    }
    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
        if (tolerateUnknowns) {
            // both unknown.
            return thisUnknown && thatUnknown;
        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
            // we won't unbox the unknowns further down.
            return false;
        }
    }
    if (isUnionType() && that.isUnionType()) {
        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), tolerateUnknowns);
    }
    if (isFunctionType() && that.isFunctionType()) {
        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), tolerateUnknowns);
    }
    if (isRecordType() && that.isRecordType()) {
        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), tolerateUnknowns);
    }
    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
        // Check if one type is parameterized, but the other is not.
        boolean paramsMatch = false;
        if (thisParamType != null && thatParamType != null) {
            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), tolerateUnknowns);
        } else if (tolerateUnknowns) {
            // If one of the type parameters is unknown, but the other is not,
            // then we consider these the same for the purposes of data flow
            // and invariance.
            paramsMatch = true;
        } else {
            paramsMatch = false;
        }
        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);
    }
    if (isNominalType() && that.isNominalType()) {
        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
    }
    // Unbox other proxies.
    if (this instanceof ProxyObjectType) {
        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, tolerateUnknowns);
    }
    if (that instanceof ProxyObjectType) {
        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);
    }
    // identical, then the type member must be different.
    return this == that;
}",9.561029530738121,"/**
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {
    if (this == that) {
        return true;
    }
    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
        if (eqMethod == EquivalenceMethod.INVARIANT) {
            // with everyone.
            return true;
        } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {
            // both unknown.
            return thisUnknown && thatUnknown;
        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
            // we won't unbox the unknowns further down.
            return false;
        }
    }
    if (isUnionType() && that.isUnionType()) {
        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), eqMethod);
    }
    if (isFunctionType() && that.isFunctionType()) {
        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), eqMethod);
    }
    if (isRecordType() && that.isRecordType()) {
        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), eqMethod);
    }
    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
        // Check if one type is parameterized, but the other is not.
        boolean paramsMatch = false;
        if (thisParamType != null && thatParamType != null) {
            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), eqMethod);
        } else if (eqMethod == EquivalenceMethod.IDENTITY) {
            paramsMatch = false;
        } else {
            // If one of the type parameters is unknown, but the other is not,
            // then we consider these the same for the purposes of data flow
            // and invariance.
            paramsMatch = true;
        }
        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);
    }
    if (isNominalType() && that.isNominalType()) {
        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
    }
    // Unbox other proxies.
    if (this instanceof ProxyObjectType) {
        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, eqMethod);
    }
    if (that instanceof ProxyObjectType) {
        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), eqMethod);
    }
    // identical, then the type member must be different.
    return this == that;
}"
19,True,Math,24,Low,108,271,4.604166666666667,1.6205533596837947,2.25,1.3333333333333333,3.533333333333333,4.945635528330781,1.7975029262582911,0.5714285714285714,0.0,20.056539132723536,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return current;
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return current;
        }
        ++iter;
    }
}",40.712492851758306,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}"
20,True,Closure,61,Medium,926,976,0.4375,0.6877470355731224,0.875,1.0,1.7333333333333334,0.501531393568147,0.38041357783847063,1.5,0.0,0.7250689312420893,"/**
 * Returns true if calls to this function have side effects.
 *
 * @param callNode The call node to inspected.
 * @param compiler A compiler object to provide program state changing
 *     context information. Can be null.
 */
static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
        throw new IllegalStateException(""Expected CALL node, got "" + Token.name(callNode.getType()));
    }
    if (callNode.isNoSideEffectsCall()) {
        return false;
    }
    Node nameNode = callNode.getFirstChild();
    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
        String name = nameNode.getString();
        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }
    } else if (nameNode.getType() == Token.GETPROP) {
        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {
            return false;
        }
        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {
            return false;
        }
        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                return false;
            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                Node param = nameNode.getNext();
                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))
                    return false;
            }
        }
    }
    return true;
}",7.840594271555163,"/**
 * Returns true if calls to this function have side effects.
 *
 * @param callNode The call node to inspected.
 * @param compiler A compiler object to provide program state changing
 *     context information. Can be null.
 */
static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
        throw new IllegalStateException(""Expected CALL node, got "" + Token.name(callNode.getType()));
    }
    if (callNode.isNoSideEffectsCall()) {
        return false;
    }
    Node nameNode = callNode.getFirstChild();
    // Built-in functions with no side effects.
    if (nameNode.getType() == Token.NAME) {
        String name = nameNode.getString();
        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
            return false;
        }
    } else if (nameNode.getType() == Token.GETPROP) {
        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {
            return false;
        }
        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {
            return false;
        }
        // Functions in the ""Math"" namespace have no side effects.
        if (nameNode.getFirstChild().getType() == Token.NAME) {
            String namespaceName = nameNode.getFirstChild().getString();
            if (namespaceName.equals(""Math"")) {
                return false;
            }
        }
        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                return false;
            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
                Node param = nameNode.getNext();
                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))
                    return false;
            }
        }
    }
    return true;
}"
21,True,Closure,173,Medium,107,768,20.354166666666668,0.5296442687747035,19.125,1.3333333333333333,10.733333333333333,3.205972434915773,5.3542723371049545,24.857142857142858,0.0,57.610889691823594,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = getContextForNoInOperator(context);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",143.1037549230952,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = getContextForNoInOperator(context);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}"
22,True,Closure,71,Medium,407,500,0.9791666666666666,0.6561264822134388,1.25,1.3333333333333333,1.7333333333333334,0.5199081163859113,0.6074912212251267,2.2857142857142856,0.0,1.6808684106065845,"/**
 * Determines whether the given property is visible in the current context.
 * @param t The current traversal.
 * @param getprop The getprop node.
 */
private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {
    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();
    if (objectType != null) {
        // Is this a normal property access, or are we trying to override
        // an existing property?
        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
        // information.
        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        JSDocInfo docInfo = null;
        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
        }
        if (objectType == null) {
            // We couldn't find a visibility modifier; assume it's public.
            return;
        }
        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            // Check an ASSIGN statement that's trying to override a property
            // on a superclass.
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();
            // visibility of the original property.
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {
                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                // private access is always allowed in the same file.
                return;
            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                // private access is not allowed outside the file from a different
                // enclosing class.
                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                // The first two have already been checked for.
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
                }
            }
        }
    }
}",11.04594184947868,"/**
 * Determines whether the given property is visible in the current context.
 * @param t The current traversal.
 * @param getprop The getprop node.
 */
private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {
    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
    String propertyName = getprop.getLastChild().getString();
    if (objectType != null) {
        // Is this a normal property access, or are we trying to override
        // an existing property?
        boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;
        // information.
        if (isOverride) {
            objectType = objectType.getImplicitPrototype();
        }
        JSDocInfo docInfo = null;
        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {
            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {
                break;
            }
        }
        if (objectType == null) {
            // We couldn't find a visibility modifier; assume it's public.
            return;
        }
        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());
        Visibility visibility = docInfo.getVisibility();
        JSType ownerType = normalizeClassType(objectType);
        if (isOverride) {
            // Check an ASSIGN statement that's trying to override a property
            // on a superclass.
            JSDocInfo overridingInfo = parent.getJSDocInfo();
            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();
            // visibility of the original property.
            if (visibility == Visibility.PRIVATE && !sameInput) {
                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));
            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {
                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));
            }
        } else {
            if (sameInput) {
                // private access is always allowed in the same file.
                return;
            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {
                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {
                    return;
                }
                // private access is not allowed outside the file from a different
                // enclosing class.
                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
            } else if (visibility == Visibility.PROTECTED) {
                // The first two have already been checked for.
                if (currentClass == null || !currentClass.isSubtype(ownerType)) {
                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));
                }
            }
        }
    }
}"
23,True,Math,40,Low,142,345,4.354166666666667,0.7299077733860342,3.0,0.6666666666666666,2.8666666666666667,6.091117917304748,1.8170113148653921,1.7142857142857142,0.0,26.015316270554997,"/**
 * {@inheritDoc}
 */
@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yB;
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            targetY = -REDUCTION_FACTOR * yA;
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        // (by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}",47.25513899039689,"/**
 * {@inheritDoc}
 */
@Override
protected double doSolve() {
    // prepare arrays with the first points
    final double[] x = new double[maximalOrder + 1];
    final double[] y = new double[maximalOrder + 1];
    x[0] = getMin();
    x[1] = getStartValue();
    x[2] = getMax();
    verifySequence(x[0], x[1], x[2]);
    // evaluate initial guess
    y[1] = computeObjectiveValue(x[1]);
    if (Precision.equals(y[1], 0.0, 1)) {
        // return the initial guess if it is a perfect root.
        return x[1];
    }
    // evaluate first  endpoint
    y[0] = computeObjectiveValue(x[0]);
    if (Precision.equals(y[0], 0.0, 1)) {
        // return the first endpoint if it is a perfect root.
        return x[0];
    }
    int nbPoints;
    int signChangeIndex;
    if (y[0] * y[1] < 0) {
        // reduce interval if it brackets the root
        nbPoints = 2;
        signChangeIndex = 1;
    } else {
        // evaluate second endpoint
        y[2] = computeObjectiveValue(x[2]);
        if (Precision.equals(y[2], 0.0, 1)) {
            // return the second endpoint if it is a perfect root.
            return x[2];
        }
        if (y[1] * y[2] < 0) {
            // use all computed point as a start sampling array for solving
            nbPoints = 3;
            signChangeIndex = 2;
        } else {
            throw new NoBracketingException(x[0], x[2], y[0], y[2]);
        }
    }
    // prepare a work array for inverse polynomial interpolation
    final double[] tmpX = new double[x.length];
    // current tightest bracketing of the root
    double xA = x[signChangeIndex - 1];
    double yA = y[signChangeIndex - 1];
    double absYA = FastMath.abs(yA);
    int agingA = 0;
    double xB = x[signChangeIndex];
    double yB = y[signChangeIndex];
    double absYB = FastMath.abs(yB);
    int agingB = 0;
    // search loop
    while (true) {
        // check convergence of bracketing interval
        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
            switch(allowed) {
                case ANY_SIDE:
                    return absYA < absYB ? xA : xB;
                case LEFT_SIDE:
                    return xA;
                case RIGHT_SIDE:
                    return xB;
                case BELOW_SIDE:
                    return (yA <= 0) ? xA : xB;
                case ABOVE_SIDE:
                    return (yA < 0) ? xB : xA;
                default:
                    // this should never happen
                    throw new MathInternalError(null);
            }
        }
        // target for the next evaluation point
        double targetY;
        if (agingA >= MAXIMAL_AGING) {
            // we keep updating the high bracket, try to compensate this
            final int p = agingA - MAXIMAL_AGING;
            final double weightA = (1 << p) - 1;
            final double weightB = p + 1;
            targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
        } else if (agingB >= MAXIMAL_AGING) {
            // we keep updating the low bracket, try to compensate this
            final int p = agingB - MAXIMAL_AGING;
            final double weightA = p + 1;
            final double weightB = (1 << p) - 1;
            targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
        } else {
            // bracketing is balanced, try to find the root itself
            targetY = 0;
        }
        // make a few attempts to guess a root,
        double nextX;
        int start = 0;
        int end = nbPoints;
        do {
            // guess a value for current target, using inverse polynomial interpolation
            System.arraycopy(x, start, tmpX, start, end - start);
            nextX = guessX(targetY, tmpX, y, start, end);
            if (!((nextX > xA) && (nextX < xB))) {
                // we try again with a lower interpolation order
                if (signChangeIndex - start >= end - signChangeIndex) {
                    // we have more points before the sign change, drop the lowest point
                    ++start;
                } else {
                    // we have more points after sign change, drop the highest point
                    --end;
                }
                // we need to do one more attempt
                nextX = Double.NaN;
            }
        } while (Double.isNaN(nextX) && (end - start > 1));
        if (Double.isNaN(nextX)) {
            // fall back to bisection
            nextX = xA + 0.5 * (xB - xA);
            start = signChangeIndex - 1;
            end = signChangeIndex;
        }
        // evaluate the function at the guessed root
        final double nextY = computeObjectiveValue(nextX);
        if (Precision.equals(nextY, 0.0, 1)) {
            // we don't need to bother about the allowed solutions setting
            return nextX;
        }
        if ((nbPoints > 2) && (end - start != nbPoints)) {
            // we have been forced to ignore some points to keep bracketing,
            // they are probably too far from the root, drop them from now on
            nbPoints = end - start;
            System.arraycopy(x, start, x, 0, nbPoints);
            System.arraycopy(y, start, y, 0, nbPoints);
            signChangeIndex -= start;
        } else if (nbPoints == x.length) {
            // we have to drop one point in order to insert the new one
            nbPoints--;
            // keep the tightest bracketing interval as centered as possible
            if (signChangeIndex >= (x.length + 1) / 2) {
                // we drop the lowest point, we have to shift the arrays and the index
                System.arraycopy(x, 1, x, 0, nbPoints);
                System.arraycopy(y, 1, y, 0, nbPoints);
                --signChangeIndex;
            }
        }
        // insert the last computed point
        // (by construction, we know it lies inside the tightest bracketing interval)
        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
        x[signChangeIndex] = nextX;
        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
        y[signChangeIndex] = nextY;
        ++nbPoints;
        // update the bracketing interval
        if (nextY * yA <= 0) {
            // the sign change occurs before the inserted point
            xB = nextX;
            yB = nextY;
            absYB = FastMath.abs(yB);
            ++agingA;
            agingB = 0;
        } else {
            // the sign change occurs after the inserted point
            xA = nextX;
            yA = nextY;
            absYA = FastMath.abs(yA);
            agingA = 0;
            ++agingB;
            // update the sign change index
            signChangeIndex++;
        }
    }
}"
24,True,Lang,62,Low,884,945,1.6458333333333333,3.570487483530962,1.25,2.0,0.8,1.391271056661562,1.1193913382754586,1.0,0.0,2.204904202425139,"/**
 * <p>Unescapes the escaped entities in the <code>String</code> passed and
 * writes the result to the <code>Writer</code> passed.</p>
 *
 * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.
 * @param string The <code>String</code> to write the results to; assumed to be non-null.
 * @throws IOException when <code>Writer</code> passed throws the exception from
 *                                       calls to the {@link Writer#write(int)} methods.
 *
 * @see #escape(String)
 * @see Writer
 */
public void unescape(Writer writer, String string) throws IOException {
    int firstAmp = string.indexOf('&');
    if (firstAmp < 0) {
        writer.write(string);
        return;
    }
    writer.write(string, 0, firstAmp);
    int len = string.length();
    for (int i = firstAmp; i < len; i++) {
        char c = string.charAt(i);
        if (c == '&') {
            int nextIdx = i + 1;
            int semiColonIdx = string.indexOf(';', nextIdx);
            if (semiColonIdx == -1) {
                writer.write(c);
                continue;
            }
            int amphersandIdx = string.indexOf('&', i + 1);
            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {
                // Then the text looks like &...&...;
                writer.write(c);
                continue;
            }
            String entityContent = string.substring(nextIdx, semiColonIdx);
            int entityValue = -1;
            int entityContentLen = entityContent.length();
            if (entityContentLen > 0) {
                if (entityContent.charAt(0) == '#') {
                    // escaped value content is an integer (decimal or hexidecimal)
                    if (entityContentLen > 1) {
                        char isHexChar = entityContent.charAt(1);
                        try {
                            switch(isHexChar) {
                                case 'X':
                                case 'x':
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                    }
                                default:
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                    }
                            }
                        } catch (NumberFormatException e) {
                        }
                    }
                } else {
                    // escaped value content is an entity name
                    entityValue = this.entityValue(entityContent);
                }
            }
            if (entityValue == -1) {
                writer.write('&');
                writer.write(entityContent);
                writer.write(';');
            } else {
                writer.write(entityValue);
            }
            // move index up to the semi-colon
            i = semiColonIdx;
        } else {
            writer.write(c);
        }
    }
}",14.981887414226454,"/**
 * <p>Unescapes the escaped entities in the <code>String</code> passed and
 * writes the result to the <code>Writer</code> passed.</p>
 *
 * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.
 * @param string The <code>String</code> to write the results to; assumed to be non-null.
 * @throws IOException when <code>Writer</code> passed throws the exception from
 *                                       calls to the {@link Writer#write(int)} methods.
 *
 * @see #escape(String)
 * @see Writer
 */
public void unescape(Writer writer, String string) throws IOException {
    int firstAmp = string.indexOf('&');
    if (firstAmp < 0) {
        writer.write(string);
        return;
    }
    writer.write(string, 0, firstAmp);
    int len = string.length();
    for (int i = firstAmp; i < len; i++) {
        char c = string.charAt(i);
        if (c == '&') {
            int nextIdx = i + 1;
            int semiColonIdx = string.indexOf(';', nextIdx);
            if (semiColonIdx == -1) {
                writer.write(c);
                continue;
            }
            int amphersandIdx = string.indexOf('&', i + 1);
            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {
                // Then the text looks like &...&...;
                writer.write(c);
                continue;
            }
            String entityContent = string.substring(nextIdx, semiColonIdx);
            int entityValue = -1;
            int entityContentLen = entityContent.length();
            if (entityContentLen > 0) {
                if (entityContent.charAt(0) == '#') {
                    // escaped value content is an integer (decimal or hexidecimal)
                    if (entityContentLen > 1) {
                        char isHexChar = entityContent.charAt(1);
                        try {
                            switch(isHexChar) {
                                case 'X':
                                case 'x':
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                        break;
                                    }
                                default:
                                    {
                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                    }
                            }
                            if (entityValue > 0xFFFF) {
                                entityValue = -1;
                            }
                        } catch (NumberFormatException e) {
                            entityValue = -1;
                        }
                    }
                } else {
                    // escaped value content is an entity name
                    entityValue = this.entityValue(entityContent);
                }
            }
            if (entityValue == -1) {
                writer.write('&');
                writer.write(entityContent);
                writer.write(';');
            } else {
                writer.write(entityValue);
            }
            // move index up to the semi-colon
            i = semiColonIdx;
        } else {
            writer.write(c);
        }
    }
}"
25,True,Closure,68,Medium,1757,1826,1.5208333333333333,1.6521739130434783,1.0,1.0,0.9333333333333333,0.03751914241960185,1.103004291845493,1.4285714285714286,0.0,0.39135505394130504,"/**
 * FunctionType := 'function' FunctionSignatureType
 * FunctionSignatureType :=
 *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token) {
    // just throw out TypeParameters.
    if (token != JsDocToken.LP) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
    }
    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        token = next();
        boolean hasParams = true;
        if (token == JsDocToken.STRING) {
            String tokenStr = stream.getString();
            boolean isThis = ""this"".equals(tokenStr);
            boolean isNew = ""new"".equals(tokenStr);
            if (isThis || isNew) {
                if (match(JsDocToken.COLON)) {
                    next();
                    skipEOLs();
                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));
                    if (contextType == null) {
                        return null;
                    }
                    functionType.addChildToFront(contextType);
                } else {
                    return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
                }
                if (match(JsDocToken.COMMA)) {
                    next();
                    skipEOLs();
                    token = next();
                } else {
                    hasParams = false;
                }
            }
        }
        if (hasParams) {
            parameters = parseParametersType(token);
            if (parameters == null) {
                return null;
            }
        }
    }
    if (parameters != null) {
        functionType.addChildToBack(parameters);
    }
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }
    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
        return null;
    } else {
        functionType.addChildToBack(resultType);
    }
    return functionType;
}",9.066790496487974,"/**
 * FunctionType := 'function' FunctionSignatureType
 * FunctionSignatureType :=
 *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token) {
    // just throw out TypeParameters.
    if (token != JsDocToken.LP) {
        restoreLookAhead(token);
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
    }
    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        token = next();
        boolean hasParams = true;
        if (token == JsDocToken.STRING) {
            String tokenStr = stream.getString();
            boolean isThis = ""this"".equals(tokenStr);
            boolean isNew = ""new"".equals(tokenStr);
            if (isThis || isNew) {
                if (match(JsDocToken.COLON)) {
                    next();
                    skipEOLs();
                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));
                    if (contextType == null) {
                        return null;
                    }
                    functionType.addChildToFront(contextType);
                } else {
                    return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
                }
                if (match(JsDocToken.COMMA)) {
                    next();
                    skipEOLs();
                    token = next();
                } else {
                    hasParams = false;
                }
            }
        }
        if (hasParams) {
            parameters = parseParametersType(token);
            if (parameters == null) {
                return null;
            }
        }
    }
    if (parameters != null) {
        functionType.addChildToBack(parameters);
    }
    skipEOLs();
    if (!match(JsDocToken.RP)) {
        return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }
    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
        return null;
    } else {
        functionType.addChildToBack(resultType);
    }
    return functionType;
}"
26,True,Closure,123,Medium,107,771,20.354166666666668,0.5296442687747035,19.125,1.3333333333333333,10.733333333333333,3.205972434915773,5.3542723371049545,24.785714285714285,0.0,57.610889691823594,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = Context.OTHER;
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",143.03232635166665,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(first, p, context);
            cc.addOp(opstr, true);
            addExpr(last, p, rhsContext);
        } else {
            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.isEmpty()) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.isComma()) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.PARAM_LIST:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            unrollBinaryOperator(n, Token.COMMA, "","", context, getContextForNoInOperator(context), 0, 0);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == 0);
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().isNumber()) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                Context rhsContext = getContextForNoInOperator(context);
                addExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1, rhsContext);
                cc.addOp("":"", true);
                addExpr(last, 1, rhsContext);
                break;
            }
        case Token.REGEXP:
            if (!first.isString() || !last.isString()) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            Preconditions.checkState(n.getParent().isObjectLit());
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.isFunction());
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GETTER_DEF) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // Unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                double d = getSimpleNumber(name);
                if (!Double.isNaN(d)) {
                    cc.addNumber(d);
                } else {
                    addJsString(n);
                }
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.isVar()) {
                        cc.endStatement();
                    }
                    if (c.isFunction()) {
                        cc.maybeLineBreak();
                    }
                    // because top-level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.isVar()) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.isString(), ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.isNumber());
                if (needsParens) {
                    add(""("");
                }
                addExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
                    // Check for ECMASCRIPT3 keywords.
                    add(""["");
                    add(last);
                    add(""]"");
                } else {
                    add(""."");
                    addIdentifier(last.getString());
                }
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
                add("")"");
            } else {
                addExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""null"");
            break;
        case Token.THIS:
            Preconditions.checkState(childCount == 0);
            add(""this"");
            break;
        case Token.FALSE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""false"");
            break;
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            cc.addConstant(""true"");
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (!first.isLabelName()) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence, Context.OTHER);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING_KEY:
            Preconditions.checkState(childCount == 1, ""Object lit key must have 1 child"");
            addJsString(n);
            break;
        case Token.STRING:
            Preconditions.checkState(childCount == 0, ""A string may not have children"");
            addJsString(n);
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.isGetterDef() || c.isSetterDef()) {
                        add(c);
                    } else {
                        Preconditions.checkState(c.isStringKey());
                        String key = c.getString();
                        // are not JavaScript keywords
                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && // were Unicode escaped.
                        NodeUtil.isLatin(key)) {
                            add(key);
                        } else {
                            // Determine if the string is a simple number.
                            double d = getSimpleNumber(key);
                            if (!Double.isNaN(d)) {
                                cc.addNumber(d);
                            } else {
                                addExpr(c, 1, Context.OTHER);
                            }
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1, Context.OTHER);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT_CASE:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (!first.isLabelName()) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        case Token.CAST:
            add(""("");
            add(first);
            add("")"");
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}"
27,True,Math,23,Low,114,281,4.604166666666667,1.6205533596837947,2.25,1.3333333333333333,3.533333333333333,4.959418070444105,1.7904799063597345,0.7142857142857143,0.0,20.470248559050834,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}",41.27581894315752,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).
    UnivariatePointValuePair best = current;
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            best = best(best, best(current, previous, isMinim), isMinim);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best;
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(best, best(current, previous, isMinim), isMinim);
        }
        ++iter;
    }
}"
28,True,Closure,18,Medium,1240,1362,2.5208333333333335,0.8142292490118577,2.125,0.6666666666666666,1.4666666666666666,0.02986217457886681,1.5009754194303542,2.2142857142857144,0.0,0.8362212946983131,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        hoistExterns(externsRoot);
        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        hoistNoCompileFiles();
        if (staleInputs) {
            repartitionInputs();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",12.174740518671774,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        hoistExterns(externsRoot);
        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement()) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        hoistNoCompileFiles();
        if (staleInputs) {
            repartitionInputs();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}"
29,True,Closure,17,Medium,1267,1317,0.5208333333333334,2.300395256916996,0.75,2.6666666666666665,1.8,0.20750382848392043,0.400702301989855,1.7857142857142858,0.0,0.5421446202602751,"/**
 * Look for a type declaration on a property assignment
 * (in an ASSIGN or an object literal key).
 *
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                JSType knownType = null;
                if (rValue != null) {
                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",10.973960293365332,"/**
 * Look for a type declaration on a property assignment
 * (in an ASSIGN or an object literal key).
 *
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                JSType knownType = null;
                if (rValue != null) {
                    JSDocInfo rValueInfo = rValue.getJSDocInfo();
                    if (rValueInfo != null && rValueInfo.hasType()) {
                        // If rValue has a type-cast, we use the type in the type-cast.
                        return rValueInfo.getType().evaluate(scope, typeRegistry);
                    } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}"
